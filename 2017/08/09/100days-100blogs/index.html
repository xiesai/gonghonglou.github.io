<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="与佳期的个人博客" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="一直以来都活跃在微博、简书等各大网站搜罗技术博客，每当看到大牛发布或者转发技术博客都会点进去搂一眼，内容比较好或者比较感兴趣的话就会转发收藏。但这些都是零零碎碎的，大多时候都是路上、睡觉前或者什么间隙看到一篇好文章，简单看一下就收藏了，当时来不及 想着以后细读，但往往是在这之后基本上不会再次翻阅了。所以计划从今天起每天仔细阅读一篇技术博客，在这里做一做笔记。
微博每日打卡：#100days,100">
<meta property="og:type" content="article">
<meta property="og:title" content="100 Days, 100 Blogs">
<meta property="og:url" content="http://gonghonglou.com/2017/08/09/100days-100blogs/index.html">
<meta property="og:site_name" content="与佳期的个人博客">
<meta property="og:description" content="一直以来都活跃在微博、简书等各大网站搜罗技术博客，每当看到大牛发布或者转发技术博客都会点进去搂一眼，内容比较好或者比较感兴趣的话就会转发收藏。但这些都是零零碎碎的，大多时候都是路上、睡觉前或者什么间隙看到一篇好文章，简单看一下就收藏了，当时来不及 想着以后细读，但往往是在这之后基本上不会再次翻阅了。所以计划从今天起每天仔细阅读一篇技术博客，在这里做一做笔记。
微博每日打卡：#100days,100">
<meta property="og:updated_time" content="2017-11-06T10:26:29.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="100 Days, 100 Blogs">
<meta name="twitter:description" content="一直以来都活跃在微博、简书等各大网站搜罗技术博客，每当看到大牛发布或者转发技术博客都会点进去搂一眼，内容比较好或者比较感兴趣的话就会转发收藏。但这些都是零零碎碎的，大多时候都是路上、睡觉前或者什么间隙看到一篇好文章，简单看一下就收藏了，当时来不及 想着以后细读，但往往是在这之后基本上不会再次翻阅了。所以计划从今天起每天仔细阅读一篇技术博客，在这里做一做笔记。
微博每日打卡：#100days,100">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"hide","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://gonghonglou.com/2017/08/09/100days-100blogs/"/>





  <title>100 Days, 100 Blogs | 与佳期的个人博客</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">与佳期的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">登白薠兮骋望，与佳期兮夕张。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://gonghonglou.com/2017/08/09/100days-100blogs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="与佳期">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="与佳期的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">100 Days, 100 Blogs</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-09T11:57:11+08:00">
                2017-08-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/08/09/100days-100blogs/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/08/09/100days-100blogs/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>一直以来都活跃在微博、简书等各大网站搜罗技术博客，每当看到大牛发布或者转发技术博客都会点进去搂一眼，内容比较好或者比较感兴趣的话就会转发收藏。<br>但这些都是零零碎碎的，大多时候都是路上、睡觉前或者什么间隙看到一篇好文章，简单看一下就收藏了，当时来不及 想着以后细读，但往往是在这之后基本上不会再次翻阅了。所以计划从今天起每天仔细阅读一篇技术博客，在这里做一做笔记。</p>
<p>微博每日打卡：<a href="https://weibo.com/p/100808e7a8991364ef294db915427e9aeb2a7e" target="_blank" rel="external">#100days,100blogs#</a></p>
<h1 id="持续更新中……"><a href="#持续更新中……" class="headerlink" title="# 持续更新中……"></a># 持续更新中……</h1><h1 id="Day-90-《招聘一个靠谱的-iOS》—参考答案（二）"><a href="#Day-90-《招聘一个靠谱的-iOS》—参考答案（二）" class="headerlink" title="# Day 90 : 《招聘一个靠谱的 iOS》—参考答案（二）"></a># Day 90 : <a href="http://www.jianshu.com/p/10b65df06e44" target="_blank" rel="external">《招聘一个靠谱的 iOS》—参考答案（二）</a></h1><p>由 <a href="http://www.jianshu.com/u/96a14318a4de" target="_blank" rel="external">iOS程序犭袁</a> 发布</p>
<h1 id="Day-89-《招聘一个靠谱的-iOS》—参考答案（一）"><a href="#Day-89-《招聘一个靠谱的-iOS》—参考答案（一）" class="headerlink" title="# Day 89 : 《招聘一个靠谱的 iOS》—参考答案（一）"></a># Day 89 : <a href="http://www.jianshu.com/p/a9e4c8914e67" target="_blank" rel="external">《招聘一个靠谱的 iOS》—参考答案（一）</a></h1><p>由 <a href="http://www.jianshu.com/u/96a14318a4de" target="_blank" rel="external">iOS程序犭袁</a> 发布</p>
<h1 id="Day-88-iOS-面试大全从简单到复杂-简单篇"><a href="#Day-88-iOS-面试大全从简单到复杂-简单篇" class="headerlink" title="# Day 88 : iOS 面试大全从简单到复杂(简单篇)"></a># Day 88 : <a href="http://www.jianshu.com/p/a2435b29875b?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=writer_share&amp;utm_source=weibo" target="_blank" rel="external">iOS 面试大全从简单到复杂(简单篇)</a></h1><p>由 <a href="http://www.jianshu.com/u/8d704c0faf00" target="_blank" rel="external">kissGod</a> 发布</p>
<p>接下来几篇面试题打打基础，没什么要总结的。</p>
<h1 id="Day-87-WWDC2016-Session笔记-iOS-10-UICollectionView新特性"><a href="#Day-87-WWDC2016-Session笔记-iOS-10-UICollectionView新特性" class="headerlink" title="# Day 87 : WWDC2016 Session笔记 - iOS 10 UICollectionView新特性"></a># Day 87 : <a href="https://juejin.im/entry/57b013516be3ff006ba7e5f8/view" target="_blank" rel="external">WWDC2016 Session笔记 - iOS 10 UICollectionView新特性</a></h1><p>由 <a href="">halfrost</a> 发布</p>
<p>– UICollectionView cell pre-fetching 预加载机制<br>– UICollectionView and UITableView prefetchDataSource 新增的API<br>– 针对self-sizing cells 的改进<br>– Interactive reordering</p>
<h1 id="Day-86-深入剖析-iOS-性能优化"><a href="#Day-86-深入剖析-iOS-性能优化" class="headerlink" title="# Day 86 : 深入剖析 iOS 性能优化"></a># Day 86 : <a href="https://github.com/ming1016/study/wiki/%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90-iOS-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96" target="_blank" rel="external">深入剖析 iOS 性能优化</a></h1><p>由 <a href="https://github.com/ming1016" target="_blank" rel="external">戴铭（ming1016）</a> 发布</p>
<ol>
<li>时间复杂度<br>– NSArray / NSMutableArray<br>– NSSet / NSMutableSet / NSCountedSet<br>– NSDictionary / NSMutableDictionary<br>– containsObject 方法在数组和 Set 里不同的实现</li>
<li>用 GCD 来做优化<br>– 异步处理事件<br>– 需要耗时长的任务<br>– 避免线程爆炸<br>– GCD 相关 Crash 日志</li>
<li>I/O 性能优化<br>– NSCache</li>
<li>控制 App 的 Wake 次数</li>
</ol>
<p>通过自动化代码检查的方式来避免问题<br>一系列牛逼操作……</p>
<h1 id="Day-85-检测iOS的APP性能的一些方法"><a href="#Day-85-检测iOS的APP性能的一些方法" class="headerlink" title="# Day 85 : 检测iOS的APP性能的一些方法"></a># Day 85 : <a href="https://github.com/ming1016/study/wiki/%E6%A3%80%E6%B5%8BiOS%E7%9A%84APP%E6%80%A7%E8%83%BD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95" target="_blank" rel="external">检测iOS的APP性能的一些方法</a></h1><p>由 <a href="https://github.com/ming1016" target="_blank" rel="external">戴铭（ming1016）</a> 发布</p>
<p>– Time Profiler<br>– Allocations<br>– Leak<br>– 开发时需要注意如何避免一些性能问题：<br>– NSDateFormatter<br>– UIImage<br>– 页面加载<br>– 优化首次加载时间<br>– 监控卡顿的方法<br>– 堆栈dump的方法</p>
<h1 id="Day-84-深入理解Objective-C：方法缓存"><a href="#Day-84-深入理解Objective-C：方法缓存" class="headerlink" title="# Day 84 : 深入理解Objective-C：方法缓存"></a># Day 84 : <a href="https://tech.meituan.com/DiveIntoMethodCache.html" target="_blank" rel="external">深入理解Objective-C：方法缓存</a></h1><p>由 <a href="https://tech.meituan.com" target="_blank" rel="external">美团点评技术团队</a> 发布</p>
<p>objc_msgSend（就arm平台而言）的消息分发分为以下几个步骤：</p>
<ol>
<li>判断receiver是否为nil，也就是objc_msgSend的第一个参数self，也就是要调用的那个方法所属对象</li>
<li>从缓存里寻找，找到了则分发，否则</li>
<li>利用objc-class.mm中_class_lookupMethodAndLoadCache3（为什么有个这么奇怪的方法。本文末尾会解释）方法去寻找selector<br>3.1. 如果支持GC，忽略掉非GC环境的方法（retain等）<br>3.2. 从本class的method list寻找selector，如果找到，填充到缓存中，并返回selector，否则<br>3.3. 寻找父类的method list，并依次往上寻找，直到找到selector，填充到缓存中，并返回selector，否则<br>3.4. 调用_class_resolveMethod，如果可以动态resolve为一个selector，不缓存，方法返回，否则<br>3.5. 转发这个selector，否则</li>
<li>报错，抛出异常</li>
</ol>
<h1 id="Day-83-ReactiveCocoa核心元素与信号流"><a href="#Day-83-ReactiveCocoa核心元素与信号流" class="headerlink" title="# Day 83 : ReactiveCocoa核心元素与信号流"></a># Day 83 : <a href="https://tech.meituan.com/ReactiveCocoaSignalFlow.html" target="_blank" rel="external">ReactiveCocoa核心元素与信号流</a></h1><p>由 <a href="https://tech.meituan.com" target="_blank" rel="external">美团点评技术团队</a> 发布</p>
<ol>
<li>RAC核心元素与管线<br>1.1. 管线的设计 － createSignal:<br>1.2. 管线工人 － Subscriber:<br>1.3. 启动管线 － subscribe：</li>
<li>RAC信号流<br>2.1. bind函数会返回一个新的信号N。<br>2.2. flattenMap：在RAC的使用中，flattenMap这个操作较为常见。事实上flattenMap是对bind的包装，为bind提供bindBlock。<br>2.3. map ：map操作可将原信号输出的数据通过自定义的方法转换成所需的数据， 同时将变化后的数据作为新信号的输出。它实际调用了flattenMap, 只不过中间信号是直接将mapBlock处理的值返回。<br>2.4. flatten: 该操作主要作用于信号的信号。flatten内部调用了flattenMap ，flattenMap里对应的中间信号就是原信号O输出signalValue。<br>2.5. switchToLatest：与flatten相同，其主要目的也是用于”压平”信号的信号。<br>2.6. scanWithStart : 该操作可将上次reduceBlock处理后输出的结果作为参数，传入当次reduceBlock操作，往往用于信号输出值的聚合处理。<br>2.7. throttle:这个操作接收一个时间间隔interval作为参数，如果Signal发出的next事件之后interval时间内不再发出next事件，那么它返回的Signal会将这个next事件发出。</li>
<li>RACCommand</li>
<li>RACChannel</li>
</ol>
<h1 id="Day-82-ReactiveCocoa中潜在的内存泄漏及解决方案"><a href="#Day-82-ReactiveCocoa中潜在的内存泄漏及解决方案" class="headerlink" title="# Day 82 : ReactiveCocoa中潜在的内存泄漏及解决方案"></a># Day 82 : <a href="https://tech.meituan.com/potential-memory-leak-in-reactivecocoa.html" target="_blank" rel="external">ReactiveCocoa中潜在的内存泄漏及解决方案</a></h1><p>由 <a href="https://tech.meituan.com" target="_blank" rel="external">美团点评技术团队</a> 发布</p>
<p>– 对 RACObserve 使用 @weakify 和 @strongify 避免循环引用<br>– 使用ReactiveCocoa必须要保证信号发送完成或者发送错误，避免内存泄漏。</p>
<h1 id="Day-81-细说ReactiveCocoa的冷信号与热信号（三）：怎么处理冷信号与热信号"><a href="#Day-81-细说ReactiveCocoa的冷信号与热信号（三）：怎么处理冷信号与热信号" class="headerlink" title="# Day 81 : 细说ReactiveCocoa的冷信号与热信号（三）：怎么处理冷信号与热信号"></a># Day 81 : <a href="https://tech.meituan.com/talk-about-reactivecocoas-cold-signal-and-hot-signal-part-3.html" target="_blank" rel="external">细说ReactiveCocoa的冷信号与热信号（三）：怎么处理冷信号与热信号</a></h1><p>由 <a href="https://tech.meituan.com" target="_blank" rel="external">美团点评技术团队</a> 发布</p>
<p>给出了冷信号转换成热信号的方法。</p>
<h1 id="Day-80-细说ReactiveCocoa的冷信号与热信号（二）：为什么要区分冷热信号"><a href="#Day-80-细说ReactiveCocoa的冷信号与热信号（二）：为什么要区分冷热信号" class="headerlink" title="# Day 80 : 细说ReactiveCocoa的冷信号与热信号（二）：为什么要区分冷热信号"></a># Day 80 : <a href="https://tech.meituan.com/talk-about-reactivecocoas-cold-signal-and-hot-signal-part-2.html" target="_blank" rel="external">细说ReactiveCocoa的冷信号与热信号（二）：为什么要区分冷热信号</a></h1><p>由 <a href="https://tech.meituan.com" target="_blank" rel="external">美团点评技术团队</a> 发布</p>
<p>举例说明冷信号在发送网络请求时可能引发的问题。</p>
<h1 id="Day-79-细说ReactiveCocoa的冷信号与热信号（一）"><a href="#Day-79-细说ReactiveCocoa的冷信号与热信号（一）" class="headerlink" title="# Day 79 : 细说ReactiveCocoa的冷信号与热信号（一）"></a># Day 79 : <a href="https://tech.meituan.com/talk-about-reactivecocoas-cold-signal-and-hot-signal-part-1.html" target="_blank" rel="external">细说ReactiveCocoa的冷信号与热信号（一）</a></h1><p>由 <a href="https://tech.meituan.com" target="_blank" rel="external">美团点评技术团队</a> 发布</p>
<p><code>- [RACSignal publish]</code>、<code>- [RACMulticastConnection connect]</code>、<code>- [RACMulticastConnection signal]</code>这几个操作生成了一个热信号。</p>
<p>冷热信号的如下特点：<br>– 热信号是主动的，即使你没有订阅事件，它仍然会时刻推送。如第二个例子，信号在50秒被创建，51秒的时候1这个值就推送出来了，但是当时还没有订阅者。<br>– 而冷信号是被动的，只有当你订阅的时候，它才会发送消息。如第一个例子。</p>
<p>– 热信号可以有多个订阅者，是一对多，信号可以与订阅者共享信息。如第二个例子，订阅者1和订阅者2是共享的，他们都能在同一时间接收到3这个值。<br>– 而冷信号只能一对一，当有不同的订阅者，消息会从新完整发送。如第一个例子，我们可以观察到两个订阅者没有联系，都是基于各自的订阅时间开始接收消息的。</p>
<h1 id="Day-78-RACSignal的Subscription深入分析"><a href="#Day-78-RACSignal的Subscription深入分析" class="headerlink" title="# Day 78 : RACSignal的Subscription深入分析"></a># Day 78 : <a href="https://tech.meituan.com/RACSignalSubscription.html" target="_blank" rel="external">RACSignal的Subscription深入分析</a></h1><p>由 <a href="https://tech.meituan.com" target="_blank" rel="external">美团点评技术团队</a> 发布</p>
<p>主要分析RACSignal的subscription过程。</p>
<h1 id="Day-77-ReactiveCocoa-Tutorial-–-The-Definitive-Introduction-Part-2-2"><a href="#Day-77-ReactiveCocoa-Tutorial-–-The-Definitive-Introduction-Part-2-2" class="headerlink" title="# Day 77 : [ReactiveCocoa Tutorial – The Definitive Introduction: Part 2/2"></a># Day 77 : [ReactiveCocoa Tutorial – The Definitive Introduction: Part 2/2</h1><p>](<a href="https://www.raywenderlich.com/62796/reactivecocoa-tutorial-pt2" target="_blank" rel="external">https://www.raywenderlich.com/62796/reactivecocoa-tutorial-pt2</a>)</p>
<p>由 <a href="https://www.raywenderlich.com/" target="_blank" rel="external">raywenderlich.com</a> 发布</p>
<p>In this, the second part of the series, you’re going to learn about the more advanced features of ReactiveCocoa. Including:<br>– Validating the Search Text<br>– Formatting of Pipelines<br>– Memory Management<br>– Avoiding Retain Cycles<br>– Requesting Access to Twitter<br>– Chaining Signals<br>– Searching Twitter<br>– Threading<br>– Updating the UI<br>– Asynchronous Loading of Images<br>– Throttling<br>– Wrap Up</p>
<h1 id="Day-76-ReactiveCocoa-Tutorial-–-The-Definitive-Introduction-Part-1-2"><a href="#Day-76-ReactiveCocoa-Tutorial-–-The-Definitive-Introduction-Part-1-2" class="headerlink" title="# Day 76 : ReactiveCocoa Tutorial – The Definitive Introduction: Part 1/2"></a># Day 76 : <a href="https://www.raywenderlich.com/62699/reactivecocoa-tutorial-pt1" target="_blank" rel="external">ReactiveCocoa Tutorial – The Definitive Introduction: Part 1/2</a></h1><p>由 <a href="https://www.raywenderlich.com/" target="_blank" rel="external">raywenderlich.com</a> 发布</p>
<p>With the first installment of this two-part ReactiveCocoa tutorial series you learned how to replace standard actions and event handling logic with signals that emit streams of events. You also learned how to transform, split and combine these signals.<br>– Time To Play<br>– A Little Cast<br>– What’s An Event?<br>– Creating Valid State Signals<br>– Combining signals<br>– Reactive Sign-in<br>– Creating Signals<br>– Signal of Signals<br>– Adding side-effects<br>– Conclusions</p>
<h1 id="Day-75-MVVM-With-ReactiveCocoa"><a href="#Day-75-MVVM-With-ReactiveCocoa" class="headerlink" title="# Day 75 : MVVM With ReactiveCocoa"></a># Day 75 : <a href="http://blog.leichunfeng.com/blog/2016/02/27/mvvm-with-reactivecocoa/" target="_blank" rel="external">MVVM With ReactiveCocoa</a></h1><p>由 <a href="http://blog.leichunfeng.com/" target="_blank" rel="external">雷纯锋的技术博客</a> 发布</p>
<ol>
<li>介绍了 MVC 及 MVVM 设计模式</li>
<li>介绍了 MVVMReactiveCocoa 开源项目<br>2.1. viewModel 通过调用 MRCViewModelServicesImpl 中的空操作来表明需要执行相应的导航操作，而 MRCNavigationControllerStack 则通过 Hook 来捕获这些空操作，然后使用栈顶的 NavigationController 来执行真正的导航操作。<br>2.2. 配置了一个从 viewModel 到 view 的映射，并且约定了一个统一的初始化 view 的方法 initWithViewModel:</li>
</ol>
<h1 id="Day-74-ReactiveCocoa-v2-5-源码解析之架构总览"><a href="#Day-74-ReactiveCocoa-v2-5-源码解析之架构总览" class="headerlink" title="# Day 74 : ReactiveCocoa v2.5 源码解析之架构总览"></a># Day 74 : <a href="http://blog.leichunfeng.com/blog/2015/12/25/reactivecocoa-v2-dot-5-yuan-ma-jie-xi-zhi-jia-gou-zong-lan/" target="_blank" rel="external">ReactiveCocoa v2.5 源码解析之架构总览</a></h1><p>由 <a href="http://blog.leichunfeng.com/" target="_blank" rel="external">雷纯锋的技术博客</a> 发布</p>
<p>介绍了 ReactiveCocoa 的四大核心组件，对它的架构有了宏观上的认识。</p>
<ol>
<li>信号源<br>1.1. RACStream<br>1.2. RACSignal<br>1.3. RACSubject<br>1.4. RACSequence</li>
<li>订阅者<br>2.1. RACSubscriber<br>2.2. RACMulticastConnection</li>
<li>调度器<br>3.1. RACScheduler</li>
<li>清洁工<br>4.1. RACDisposable</li>
</ol>
<h1 id="Day-73-美团App-iOS开发与FRP"><a href="#Day-73-美团App-iOS开发与FRP" class="headerlink" title="# Day 73 : 美团App iOS开发与FRP"></a># Day 73 : <a href="https://mp.weixin.qq.com/s/e4WlFrCRxSU4gniCLKBw_g" target="_blank" rel="external">美团App iOS开发与FRP</a></h1><p>由 <a href="">臧成威的专栏公众平台</a> 发布</p>
<p>介绍了 MVVM 设计模式及函数响应式编程（Functional Reactive Programming，简称FRP）的使用。</p>
<h1 id="Day-72-iOS-开发中，怎样用好-Notifications？"><a href="#Day-72-iOS-开发中，怎样用好-Notifications？" class="headerlink" title="# Day 72 : iOS 开发中，怎样用好 Notifications？"></a># Day 72 : <a href="http://www.jianshu.com/p/f20b00c1fc24" target="_blank" rel="external">iOS 开发中，怎样用好 Notifications？</a></h1><p>由 <a href="http://www.jianshu.com/u/8d5b91490ca5" target="_blank" rel="external">故胤道长</a> 发布</p>
<p>目录：<br>– UserNotifications 介绍<br>– 本地通知（Local Notifications）<br>– 远程通知（Remote Notifications）<br>– 观察者模式（Observer Pattern）</p>
<h1 id="Day-71-NSNotificationCenter实现原理？"><a href="#Day-71-NSNotificationCenter实现原理？" class="headerlink" title="# Day 71 : NSNotificationCenter实现原理？"></a># Day 71 : <a href="http://www.jianshu.com/p/051a9a3af1a4" target="_blank" rel="external">NSNotificationCenter实现原理？</a></h1><p>由 <a href="http://www.jianshu.com/u/fa2065ad703a" target="_blank" rel="external">Vein_</a> 发布</p>
<p>– NSNotificatinonCenter是使用观察者模式来实现的用于跨层传递消息，用来降低耦合度。<br>– NSNotificatinonCenter用来管理通知，将观察者注册到NSNotificatinonCenter的通知调度表中，然后发送通知时利用标识符name和object识别出调度表中的观察者，然后调用相应的观察者的方法，即传递消息（在Objective-C中对象调用方法，就是传递消息，消息有name或者selector，可以接受参数，而且可能有返回值），如果是基于block创建的通知就调用NSNotification的block。</p>
<h1 id="Day-70-iOS-性能优化：Instruments-工具的救命三招"><a href="#Day-70-iOS-性能优化：Instruments-工具的救命三招" class="headerlink" title="# Day 70 : iOS 性能优化：Instruments 工具的救命三招"></a># Day 70 : <a href="https://blog.leancloud.cn/2835/" target="_blank" rel="external">iOS 性能优化：Instruments 工具的救命三招</a></h1><p>由 <a href="https://blog.leancloud.cn/" target="_blank" rel="external">LeanCloud Blog</a> 发布</p>
<ol>
<li>Time Profiler。Call Tree 的选项设置：<br>1.1. Separate by Thread：按线程分开做分析，这样更容易揪出那些吃资源的问题线程。特别是对于主线程，它要处理和渲染所有的接口数据，一旦受到阻塞，程序必然卡顿或停止响应。<br>1.2. Invert Call Tree：反向输出调用树。把调用层级最深的方法显示在最上面，更容易找到最耗时的操作。<br>1.3. Hide Missing Symbols：隐藏缺失符号。如果 dSYM 文件或其他系统架构缺失，列表中会出现很多奇怪的十六进制的数值，用此选项把这些干扰元素屏蔽掉，让列表回归清爽。<br>1.4. Hide System Libraries：隐藏系统库文件。过滤掉各种系统调用，只显示自己的代码调用。<br>1.5. Flattern Recursion：拼合递归。将同一递归函数产生的多条堆栈（因为递归函数会调用自己）合并为一条。<br>1.6. Top Functions：找到最耗时的函数或方法。</li>
<li>Allocations：内存分配</li>
<li>Leaks：内存泄漏</li>
</ol>
<h1 id="Day-69-放肆的使用UIBezierPath和CAShapeLayer画各种图形"><a href="#Day-69-放肆的使用UIBezierPath和CAShapeLayer画各种图形" class="headerlink" title="# Day 69 : 放肆的使用UIBezierPath和CAShapeLayer画各种图形"></a># Day 69 : <a href="http://www.jianshu.com/p/c5cbb5e05075" target="_blank" rel="external">放肆的使用UIBezierPath和CAShapeLayer画各种图形</a></h1><p>由 <a href="http://www.jianshu.com/u/68377bdd5d6d" target="_blank" rel="external">J0hnnny</a> 发布</p>
<p>评论区发现很有趣有用的<a href="https://github.com/CYBoys/BezierPath" target="_blank" rel="external">Demo：BezierPath</a></p>
<h1 id="Day-68-APP-缓存数据线程安全问题探讨"><a href="#Day-68-APP-缓存数据线程安全问题探讨" class="headerlink" title="# Day 68 : APP 缓存数据线程安全问题探讨"></a># Day 68 : <a href="http://blog.cnbang.net/tech/3262/" target="_blank" rel="external">APP 缓存数据线程安全问题探讨</a></h1><p>由 <a href="http://blog.cnbang.net/" target="_blank" rel="external">bang’s blog</a> 发布</p>
<p>解决方案：<br>– 1.加锁<br>– 2.分线程cache<br>– 3.数据不可变</p>
<p>对于 APP 缓存数据线程安全问题，分线程 cache 和数据不可变是比较常见的解决方案，都有着不同的实现代价，分线程 cache 接口不友好，数据不可变需要配合单向数据流之类的规则或框架才会变得好用，可以按需选择合适的方案。</p>
<h1 id="Day-67（yesterday）-优化-App-的启动时间"><a href="#Day-67（yesterday）-优化-App-的启动时间" class="headerlink" title="# Day 67（yesterday） : 优化 App 的启动时间"></a># Day 67（yesterday） : <a href="http://yulingtianxia.com/blog/2016/10/30/Optimizing-App-Startup-Time/" target="_blank" rel="external">优化 App 的启动时间</a></h1><p>由 <a href="http://yulingtianxia.com/" target="_blank" rel="external">玉令天下的博客</a> 发布</p>
<p>这是一篇 WWDC 2016 Session 406 的学习笔记，从原理到实践讲述了如何优化 App 的启动时间。</p>
<p>测量启动时间：<br>在 main() 方法执行前测量是很难的，好在 dyld 提供了内建的测量方法：在 Xcode 中 Edit scheme -&gt; Run -&gt; Auguments 将环境变量 DYLD_PRINT_STATISTICS 设为 1。</p>
<h1 id="Day-66-今日头条iOS客户端启动速度优化"><a href="#Day-66-今日头条iOS客户端启动速度优化" class="headerlink" title="# Day 66 : 今日头条iOS客户端启动速度优化"></a># Day 66 : <a href="https://techblog.toutiao.com/2017/01/17/iosspeed/" target="_blank" rel="external">今日头条iOS客户端启动速度优化</a></h1><p>由 <a href="https://techblog.toutiao.com/" target="_blank" rel="external">今日头条技术博客</a> 发布</p>
<ol>
<li>main()调用之前的加载过程<br>1.1. 什么是image<br>1.2. 系统使用动态链接有几点好处<br>1.3. 什么是ImageLoader<br>1.4. 动态链接库加载的具体流程<br>1.4.1. load dylibs image<br>1.4.2. rebase/bind<br>1.4.3. Objc setup<br>1.4.4. initializers</li>
<li>main()之前的加载时间如何衡量<br>总结一下：对于main()调用之前的耗时我们可以优化的点有：<br>2.1.    减少不必要的framework，因为动态链接比较耗时<br>2.2.    check framework应当设为optional和required，如果该framework在当前App支持的所有iOS系统版本都存在，那么就设为required，否则就设为optional，因为optional会有些额外的检查<br>2.3. 合并或者删减一些OC类<br>2.3.1. 删减一些无用的静态变量<br>2.3.2. 删减没有被调用到或者已经废弃的方法<br>2.3.3. 将不必须在+load方法中做的事情延迟到+initialize中<br>2.3.4. 尽量不要用C++虚函数(创建虚函数表有开销)</li>
<li>main()调用之后的加载时间</li>
</ol>
<h1 id="Day-65-IOS-App-启动优化"><a href="#Day-65-IOS-App-启动优化" class="headerlink" title="# Day 65 : IOS App 启动优化"></a># Day 65 : <a href="http://www.jianshu.com/p/6f14fad90d5e" target="_blank" rel="external">IOS App 启动优化</a></h1><p>由 <a href="http://www.jianshu.com/u/02ec002ab1b2" target="_blank" rel="external">我爱水果</a> 发布</p>
<ol>
<li>App总启动时间 = t1(main()之前的加载时间) + t2(main()之后的加载时间)。</li>
<li>t1 = 系统dylib(动态链接库)和自身App可执行文件的加载；</li>
<li>t2 = main方法执行之后到AppDelegate类中的- (BOOL)Application:(UIApplication <em>)Application didFinishLaunchingWithOptions:(NSDictionary </em>)launchOptions方法执行结束前这段时间，主要是构建第一个界面，并完成渲染展示。</li>
<li>main()调用之前加载过程,优化内容<br>4.1.    减少framework引用<br>4.2.    删除无用类，无用函数<br>4.3.    减少+load 函数使用</li>
<li>main()调用之后, 优化内容<br>5.1. launcherImage图片尽量小，实测这个大小会影响启动速度<br>5.2. Splash 不要Xib，直接用代码尽量简单<br>5.3. 将需要执行的处理，放入不同的block内，并发到不同的queue中进行。<br>5.4. 提供串行队列，执行有依赖的逻辑<br>5.5. 提供group，对彼此依赖不明确，但需要整体执行完成后，进行处理的业务，提供dispatch_group功能满足需求。<br>5.6. 对于MainThread有需要的业务，提供mainThread 支持。</li>
</ol>
<h1 id="Day-64-深入理解-weak-strong-dance"><a href="#Day-64-深入理解-weak-strong-dance" class="headerlink" title="# Day 64 : 深入理解 weak-strong dance"></a># Day 64 : <a href="http://www.jianshu.com/p/4e6153ea2734" target="_blank" rel="external">深入理解 weak-strong dance</a></h1><p>由 <a href="http://www.jianshu.com/u/71a9f866a9f5" target="_blank" rel="external">Sheepy</a> 发布</p>
<p>– 问：self指向的对象已经被废弃的情况下，_handler成员变量也不存在了，在 ARC 下会自动释放它指向的 Block 对象，这个时候 Block 对象应该已经没有被变量所持有了，它的引用计数应该已经为0了，它应该被废弃了啊，为什么它还能继续存在并执行？<br>– 答：把 Block 赋值给self.handler的时候，在栈上生成的 Block 被复制了一份，放到堆上，并被_handler持有。而之后如果你把这个 Block 当作 GCD 参数使用（比较常见的需要使用 weak-strong dance 的情况），GCD 函数内部会把该 Block 再 copy 一遍，而此时 Block 已经在堆上，则该 Block 的引用计数加1。所以此时 Block 的引用计数是大于1的，即使self对象被废弃（譬如执行了退出当前页面之类的操作），Block 会被 release 一次，但它的引用计数仍然大于0，故而不会被废弃。</p>
<p>– 问：本来在 Block 内部使用weakSelf就是为了让 Block 对象不持有self指向的对象，那在 Block 内部又把weakSelf赋给strongSelf不就又持有self对象了么？又循环引用了？<br>– 答：<strong>weak是个神奇的东西，每次使用</strong>weak变量的时候，都会取出该变量指向的对象并 retain，然后将该对象注册到 autoreleasepool 中。通过上述代码我们可以发现，在__xx_block_func_y中，局部变量occlass会持有捕获的对象，然后对象会被注册到 autoreleasepool。这是延长对象生命周期的关键（保证在执行 Block 期间对象不会被废弃），但这不会造成循环引用，当函数执行结束，变量occlass超出作用域，过一会儿（一般一次 RunLoop 之后），对象就被释放了。所以 weak-strong dance 的行为非常符合预期：延长捕获对象的生命周期，一旦 Block 执行完，对象被释放，而 Block 也会被释放（如果被 GCD 之类的 API copy 过一次增加了引用计数，那最终也会被 GCD 释放）</p>
<p>关于<strong>weak：<br>– </strong>weak修饰的变量不会持有对象，它用一张 weak 表（类似于引用计数表的散列表）来管理对象和变量。赋值的时候它会以赋值对象的地址作为 key，变量的地址为 value，注册到 weak 表中。一旦该对象被废弃，就通过对象地址在 weak 表中找到变量的地址，赋值为 nil，然后将该条记录从 weak 表中删除。<br>– 每使用一次_weak变量就会把对象注册到 autoreleasepool 中，所以如果短时间内大量使用_weak变量的话，会导致注册到 autoreleasepool 中的对象大量增加，占用一定内存。而 weak-strong dance 恰好无意中解决了这个隐患，在执行 Block 时，把_weak变量（weakSelf）赋值给一个临时变量（strongSelf），之后一直都使用这个临时变量，所以_weak变量只使用了一次，也就只有一个对象注册到 autoreleasepool 中。</p>
<h1 id="Day-63-小笨狼漫谈多线程：GCD-一"><a href="#Day-63-小笨狼漫谈多线程：GCD-一" class="headerlink" title="# Day 63 : 小笨狼漫谈多线程：GCD(一)"></a># Day 63 : <a href="http://www.jianshu.com/p/c2b14bb999de" target="_blank" rel="external">小笨狼漫谈多线程：GCD(一)</a></h1><p>由 <a href="http://www.jianshu.com/u/1f93e3b1f3da" target="_blank" rel="external">小笨狼</a> 发布</p>
<p>– dispatch_queue_t<br>– async：<br><code>void dispatch_async(dispatch_queue_t queue, dispatch_block_t block);</code><br><code>void dispatch_async_f(dispatch_queue_t queue, void *context, dispatch_function_t work);</code><br>– sync：<br><code>void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);</code><br><code>void dispatch_sync_f(dispatch_queue_t queue, void *context, dispatch_function_t work);</code><br>– 获取主线程队列：<br><code>dispatch_queue_t dispatch_get_main_queue(void)</code><br>– 获取全局队列：<br><code>dispatch_queue_t dispatch_get_global_queue(long identifier, unsigned long flags);</code><br>– 创建队列：<br><code>dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr);</code><br>– 设置目标队列：<br><code>void dispatch_set_target_queue(dispatch_object_t object, dispatch_queue_t queue);</code><br>注意：当目标队列串行时，任何在目标队列中执行的block都会串行执行，无论原队列是否串行<br>– 延时：<br><code>dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block);</code><br><code>void dispatch_after_f(dispatch_time_t when, dispatch_queue_t queue, void *context, dispatch_function_t work);</code><br>– dispatch_barrier：<br>使用dispatch_barrier将任务加入到并行队列之后，任务会在前面任务全部执行完成之后执行，任务执行过程中，其他任务无法执行，直到barrier任务执行完成<br>– set_specific &amp; get_specific：<br><code>void dispatch_queue_set_specific(dispatch_queue_t queue, const void *key, void *context, dispatch_function_t destructor);</code></p>
<p><code>void *dispatch_queue_get_specific(dispatch_queue_t queue, const void *key);</code><br><code>void *dispatch_get_specific(const void *key);</code></p>
<h1 id="Day-62-iOS-OS-X内存管理-二-：借助工具解决内存问题"><a href="#Day-62-iOS-OS-X内存管理-二-：借助工具解决内存问题" class="headerlink" title="# Day 62 : iOS/OS X内存管理(二)：借助工具解决内存问题"></a># Day 62 : <a href="http://www.jianshu.com/p/09c5141d4531" target="_blank" rel="external">iOS/OS X内存管理(二)：借助工具解决内存问题</a></h1><p>由 <a href="http://www.jianshu.com/u/256fb15baf75" target="_blank" rel="external">Sam_Lau</a> 发布</p>
<ol>
<li>悬挂指针问题：悬挂指针(Dangling Pointer)就是当指针指向的对象已经释放或回收后，但没有对指针做任何修改(一般来说，将它指向空指针)，而是仍然指向原来已经回收的地址。如果指针指向的对象已经释放，但仍然使用，那么就会导致程序crash。</li>
<li>启用NSZombieEnabled</li>
<li>内存泄露问题<br>3.1. 手动静态分析（菜单栏的Product -&gt; Analyze或快捷键shift + command + b）<br>3.2. 自动静态分析（在Build Settings启用Analyze During ‘Build’，每次编译时都会自动静态分析）<br>3.3. 启动Instruments（Xcode的菜单栏的 Product -&gt; Profile）</li>
</ol>
<h1 id="Day-61-Xcode中断点的威力"><a href="#Day-61-Xcode中断点的威力" class="headerlink" title="# Day 61 : Xcode中断点的威力"></a># Day 61 : <a href="http://www.cocoachina.com/industry/20130701/6514.html" target="_blank" rel="external">Xcode中断点的威力</a></h1><p>由<a href="">破船</a>译自：<a href="http://www.albertopasca.it/whiletrue/2013/06/xcode-power-of-breakpoints/" target="_blank" rel="external">albertopasca</a></p>
<ol>
<li>添加一个特殊的断点<br>1.1. 异常断点(Exception breakpoint)<br>1.2. 符号断点(Symbolic breakpoint)</li>
<li>打印到控制台<br>2.1.使用NSLog打印字符串<br>2.2. 使用NSLog打印对象(po)<br>2.3. 带条件的打印<br>2.4. 在循环里面打印一些东西</li>
<li>运行时设置断点</li>
<li>调试中播放声音</li>
<li>LLDB中有用的一些命令<br>5.1. 打印帮助(help)<br>5.2. 打印调用栈(bt)<br>5.3. 打印最基本的内容 (p)<br>5.4. 打印对象(po)<br>5.5. 打印表达式(expr)<br>5.6. 打印线程中的一些东西(help frame)</li>
</ol>
<h1 id="Day-60-小笨狼与LLDB的故事"><a href="#Day-60-小笨狼与LLDB的故事" class="headerlink" title="# Day 60 : 小笨狼与LLDB的故事"></a># Day 60 : <a href="http://www.jianshu.com/p/e89af3e9a8d7" target="_blank" rel="external">小笨狼与LLDB的故事</a></h1><p>由 <a href="http://www.jianshu.com/u/1f93e3b1f3da" target="_blank" rel="external">小笨狼</a> 发布</p>
<p>文章介绍了很多LLDB命令。</p>
<h1 id="Day-59-线程安全类的设计"><a href="#Day-59-线程安全类的设计" class="headerlink" title="# Day 59 : 线程安全类的设计"></a># Day 59 : <a href="https://objccn.io/issue-2-4/" target="_blank" rel="external">线程安全类的设计</a></h1><p>由 <a href="https://objccn.io/" target="_blank" rel="external">ObjC 中国</a> 发布</p>
<h1 id="Day-58-CFRunLoop"><a href="#Day-58-CFRunLoop" class="headerlink" title="# Day 58 : CFRunLoop"></a># Day 58 : <a href="https://github.com/ming1016/study/wiki/CFRunLoop" target="_blank" rel="external">CFRunLoop</a></h1><p>由 <a href="https://github.com/ming1016" target="_blank" rel="external">戴铭（ming1016）</a> 发布</p>
<ol>
<li>Thread包含一个CFRunLoop，一个CFRunLoop包含一种CFRunLoopMode，mode包含CFRunLoopSource，CFRunLoopTimer和CFRunLoopObserver。</li>
<li>CFRunLoopMode：<br>2.1. NSDefaultRunLoopMode：默认，空闲状态<br>2.2. UITrackingRunLoopMode：ScrollView滑动时<br>2.3. UIInitializationRunLoopMode：启动时<br>2.4. NSRunLoopCommonModes：Mode集合 Timer计时会被scrollView的滑动影响的问题可以通过将timer添加到NSRunLoopCommonModes来解决</li>
<li>CFRunLoopTimer</li>
<li>CFRunLoopSource<br>4.1. source0：处理如UIEvent，CFSocket这样的事件<br>4.2. source1：Mach port驱动，CFMachport，CFMessagePort</li>
<li>CFRunLoopObserver</li>
<li>使用RunLoop的案例<br>6.1. AFNetworking<br>6.2. TableView中实现平滑滚动延迟加载图片<br>6.3. 接到程序崩溃时的信号进行自主处理例如弹出提示等<br>6.4. 异步测试</li>
</ol>
<h1 id="Day-57-离屏渲染优化"><a href="#Day-57-离屏渲染优化" class="headerlink" title="# Day 57 : 离屏渲染优化"></a># Day 57 : <a href="https://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&amp;mid=2709544818&amp;idx=1&amp;sn=62d0d2e9a363d250beb2d6887dca54b3" target="_blank" rel="external">离屏渲染优化</a></h1><p>由 <a href="">iOS开发by唐巧</a> 公众号发布</p>
<p>总结：<br>– RoundedCorner 在仅指定cornerRadius时不会触发离屏渲染，仅适用于特殊情况：contents为 nil 或者contents不会遮挡背景色圆角<br>– Shawdow 可以通过指定路径来取消离屏渲染<br>– Mask 无法取消离屏渲染</p>
<p>以上效果在同等数量的规模下，对性能的影响等级：Shadow &gt; RoundedCorner &gt; Mask &gt; GroupOpacity(迷之效果)。</p>
<p>任何时候优先考虑避免触发离屏渲染，无法避免时优化方案有两种：<br>– Rasterization：适用于静态内容的视图，也就是内部结构和内容不发生变化的视图，对上面的所有效果而言，在实现成本以及性能上最均衡的。即使是动态变化的视图，开启 Rasterization 后能够有效降低 GPU 的负荷，不过在动态视图里是否启用还是看 Instruments 的数据<br>– 规避离屏渲染，用其他手法来模拟效果，混合图层是个性能最好、耗能最少的通用优化方案，尤其对于 rounded corer 和 mask</p>
<h1 id="Day-56-iOS-事件处理机制与图像渲染过程"><a href="#Day-56-iOS-事件处理机制与图像渲染过程" class="headerlink" title="# Day 56 : iOS 事件处理机制与图像渲染过程"></a># Day 56 : <a href="https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=400417748&amp;idx=1&amp;sn=0c5f6747dd192c5a0eea32bb4650c160" target="_blank" rel="external">iOS 事件处理机制与图像渲染过程</a></h1><p>由 <a href="">WeMobileDev</a> 公众号发布</p>
<p>– iOS RunLoop都干了什么<br>– iOS 为什么必须在主线程中操作UI<br>– 事件响应<br>– CALayer<br>– CADisplayLink 和 NSTimer<br>– iOS 渲染过程<br>– 渲染时机<br>– CPU 和 GPU渲染<br>– Core Animation<br>– Facebook Pop介绍<br>– AsyncDisplay介绍<br>– 参考文章</p>
<h1 id="Day-55-iOS-组件化方案探索"><a href="#Day-55-iOS-组件化方案探索" class="headerlink" title="# Day 55 : iOS 组件化方案探索"></a># Day 55 : <a href="http://blog.cnbang.net/tech/3080/" target="_blank" rel="external">iOS 组件化方案探索</a></h1><p>由 <a href="http://blog.cnbang.net/" target="_blank" rel="external">bang’s blog</a> 发布</p>
<p>分别介绍了Limboy的蘑菇街组件化方案和Casa的组件化方案，通过简练的总结和简单的代码示例令这两种方案的原理更加易懂。</p>
<h1 id="Day-54-iOS应用架构谈-组件化方案"><a href="#Day-54-iOS应用架构谈-组件化方案" class="headerlink" title="# Day 54 : iOS应用架构谈 组件化方案"></a># Day 54 : <a href="https://casatwy.com/iOS-Modulization.html" target="_blank" rel="external">iOS应用架构谈 组件化方案</a></h1><p>由 <a href="https://casatwy.com/" target="_blank" rel="external">Casa Taloyum</a> 发布</p>
<p>iOS应用架构谈 系列文章。对比了蘑菇街的组件化方案和CTMediator组件化方案。</p>
<h1 id="Day-53-iOS应用架构谈-本地持久化方案及动态部署"><a href="#Day-53-iOS应用架构谈-本地持久化方案及动态部署" class="headerlink" title="# Day 53 : iOS应用架构谈 本地持久化方案及动态部署"></a># Day 53 : <a href="https://casatwy.com/iosying-yong-jia-gou-tan-ben-di-chi-jiu-hua-fang-an-ji-dong-tai-bu-shu.html" target="_blank" rel="external">iOS应用架构谈 本地持久化方案及动态部署</a></h1><p>由 <a href="https://casatwy.com/" target="_blank" rel="external">Casa Taloyum</a> 发布</p>
<p>iOS应用架构谈 系列文章。</p>
<h1 id="Day-52-iOS应用架构谈-网络层设计方案"><a href="#Day-52-iOS应用架构谈-网络层设计方案" class="headerlink" title="# Day 52 : iOS应用架构谈 网络层设计方案"></a># Day 52 : <a href="https://casatwy.com/iosying-yong-jia-gou-tan-wang-luo-ceng-she-ji-fang-an.html" target="_blank" rel="external">iOS应用架构谈 网络层设计方案</a></h1><p>由 <a href="https://casatwy.com/" target="_blank" rel="external">Casa Taloyum</a> 发布</p>
<p>iOS应用架构谈 系列文章。</p>
<h1 id="Day-51-yesterday-iOS应用架构谈-view层的组织和调用方案"><a href="#Day-51-yesterday-iOS应用架构谈-view层的组织和调用方案" class="headerlink" title="# Day 51(yesterday) : iOS应用架构谈 view层的组织和调用方案"></a># Day 51(yesterday) : <a href="https://casatwy.com/iosying-yong-jia-gou-tan-viewceng-de-zu-zhi-he-diao-yong-fang-an.html" target="_blank" rel="external">iOS应用架构谈 view层的组织和调用方案</a></h1><p>由 <a href="https://casatwy.com/" target="_blank" rel="external">Casa Taloyum</a> 发布</p>
<p>iOS应用架构谈 系列文章。</p>
<h1 id="Day-50-iOS应用架构谈-开篇"><a href="#Day-50-iOS应用架构谈-开篇" class="headerlink" title="# Day 50 : iOS应用架构谈 开篇"></a># Day 50 : <a href="https://casatwy.com/iosying-yong-jia-gou-tan-kai-pian.html" target="_blank" rel="external">iOS应用架构谈 开篇</a></h1><p>由 <a href="https://casatwy.com/" target="_blank" rel="external">Casa Taloyum</a> 发布</p>
<p>iOS应用架构谈 系列文章。<br>评论区也是值得看的地方。</p>
<h1 id="Day-49-组件化架构漫谈"><a href="#Day-49-组件化架构漫谈" class="headerlink" title="# Day 49 : 组件化架构漫谈"></a># Day 49 : <a href="http://www.jianshu.com/p/67a6004f6930" target="_blank" rel="external">组件化架构漫谈</a></h1><p>由 <a href="http://www.jianshu.com/u/2de707c93dc4" target="_blank" rel="external">刘小壮</a> 发布</p>
<p>主要以蘑菇街组件化架构和casatwy组件化方案讲解组件化实现思路，并介绍了滴滴淘宝的组件化过程。</p>
<h1 id="Day-48-细说GCD（Grand-Central-Dispatch）如何用"><a href="#Day-48-细说GCD（Grand-Central-Dispatch）如何用" class="headerlink" title="# Day 48 : 细说GCD（Grand Central Dispatch）如何用"></a># Day 48 : <a href="https://github.com/ming1016/study/wiki/%E7%BB%86%E8%AF%B4GCD%EF%BC%88Grand-Central-Dispatch%EF%BC%89%E5%A6%82%E4%BD%95%E7%94%A8" target="_blank" rel="external">细说GCD（Grand Central Dispatch）如何用</a></h1><p>由 <a href="https://github.com/ming1016" target="_blank" rel="external">戴铭（ming1016）</a> 发布</p>
<p>文中较详细介绍GCD队列，各种GCD使用方法，实例如何使用Dispatch Source监听系统底层对象，分析不同锁的性能对比，实例GCD死锁情况。</p>
<h1 id="Day-47-不再安全的-OSSpinLock"><a href="#Day-47-不再安全的-OSSpinLock" class="headerlink" title="# Day 47 : 不再安全的 OSSpinLock"></a># Day 47 : <a href="https://blog.ibireme.com/2016/01/16/spinlock_is_unsafe_in_ios/" target="_blank" rel="external">不再安全的 OSSpinLock</a></h1><p>由 <a href="https://blog.ibireme.com/" target="_blank" rel="external">Garan no Dou (ibireme)</a> 发布</p>
<p>– 最终的结论就是，除非开发者能保证访问锁的线程全部都处于同一优先级，否则 iOS 系统中所有类型的自旋锁都不能再使用了。<br>– 可以看到除了 OSSpinLock 外，dispatch_semaphore 和 pthread_mutex 性能是最高的。有消息称，苹果在新系统中已经优化了 pthread_mutex 的性能，所以它看上去和 OSSpinLock 差距并没有那么大了。</p>
<h1 id="Day-46-yesterday-iOS-保持界面流畅的技巧"><a href="#Day-46-yesterday-iOS-保持界面流畅的技巧" class="headerlink" title="# Day 46(yesterday) : iOS 保持界面流畅的技巧"></a># Day 46(yesterday) : <a href="https://blog.ibireme.com/2015/11/12/smooth_user_interfaces_for_ios/" target="_blank" rel="external">iOS 保持界面流畅的技巧</a></h1><p>由 <a href="https://blog.ibireme.com/" target="_blank" rel="external">Garan no Dou (ibireme)</a> 发布</p>
<ol>
<li>演示项目</li>
<li>屏幕显示图像的原理</li>
<li>卡顿产生的原因和解决方案<br>3.1. CPU 资源消耗原因和解决方案<br>3.2. GPU 资源消耗原因和解决方案</li>
<li>AsyncDisplayKit<br>4.1. ASDK 的由来<br>4.2. ASDK 的资料<br>4.3. ASDK 的基本原理<br>4.4. ASDK 的图层预合成<br>4.5. ASDK 异步并发操作<br>4.6. Runloop 任务分发</li>
<li>微博 Demo 性能优化技巧<br>5.1. 预排版<br>5.2. 预渲染<br>5.3. 异步绘制<br>5.4. 全局并发控制<br>5.5. 更高效的异步图片加载<br>5.6. 其他可以改进的地方</li>
<li>如何评测界面的流畅度</li>
</ol>
<p>YY大神的深度好文，之前已经读过，温故而知新！</p>
<h1 id="Day-45-iOS-处理图片的一些小-Tip"><a href="#Day-45-iOS-处理图片的一些小-Tip" class="headerlink" title="# Day 45 : iOS 处理图片的一些小 Tip"></a># Day 45 : <a href="https://blog.ibireme.com/2015/11/02/ios_image_tips/" target="_blank" rel="external">iOS 处理图片的一些小 Tip</a></h1><p>由 <a href="https://blog.ibireme.com/" target="_blank" rel="external">Garan no Dou (ibireme)</a> 发布</p>
<p>– 如何把 GIF 动图保存到相册<br>– 将 UIImage 保存到磁盘，用什么方式最好<br>– UIImage 缓存是怎么回事<br>– 用 imageWithData 能不能避免缓存<br>– 怎么能避免缓存<br>– 能直接取到图片解码后的数据，而不是通过画布取到吗<br>– 如何判断一个文件的图片类型<br>– 怎样像浏览器那样边下载边显示图片</p>
<h1 id="Day-44-移动端图片格式调研"><a href="#Day-44-移动端图片格式调研" class="headerlink" title="# Day 44 : 移动端图片格式调研"></a># Day 44 : <a href="https://blog.ibireme.com/2015/11/02/mobile_image_benchmark/" target="_blank" rel="external">移动端图片格式调研</a></h1><p>由 <a href="https://blog.ibireme.com/" target="_blank" rel="external">Garan no Dou (ibireme)</a> 发布</p>
<ol>
<li>几种图片格式简介</li>
<li>移动端图片类型的支持情况</li>
<li>静态图片的编码与解码<br>3.1. JPEG<br>3.2. PNG<br>3.3. WebP<br>3.4. BPG</li>
<li>动态图片的编码与解码<br>4.1. GIF<br>4.2. APNG<br>4.3. WebP<br>4.4. BPG<br>4.5. 动图性能对比</li>
</ol>
<p>分析了目前主流和新兴的几种图片格式的特点、性能分析、参数调优，以及相关开源库的选择。</p>
<h1 id="Day-43-深入理解RunLoop"><a href="#Day-43-深入理解RunLoop" class="headerlink" title="# Day 43 : 深入理解RunLoop"></a># Day 43 : <a href="https://blog.ibireme.com/2015/05/18/runloop/" target="_blank" rel="external">深入理解RunLoop</a></h1><p>由 <a href="https://blog.ibireme.com/" target="_blank" rel="external">Garan no Dou (ibireme)</a> 发布</p>
<ol>
<li>RunLoop 的概念</li>
<li>RunLoop 与线程的关系</li>
<li>RunLoop 对外的接口</li>
<li>RunLoop 的 Mode</li>
<li>RunLoop 的内部逻辑</li>
<li>RunLoop 的底层实现</li>
<li>苹果用 RunLoop 实现的功能<br>7.1. AutoreleasePool<br>7.2. 事件响应<br>7.3. 手势识别<br>7.4. 界面更新<br>7.5. 定时器<br>7.6. PerformSelecter<br>7.7 关于GCD<br>7.8 关于网络请求</li>
<li>RunLoop 的实际应用举例<br>8.1. AFNetworking<br>8.2. AsyncDisplayKit</li>
</ol>
<p>YY大神的经典文章，文章太长就不做笔记了，目录贴出来，适合再次阅读。<br>还有阳神关于 RunLoop 的线下分享视频：<a href="http://v.youku.com/v_show/id_XODgxODkzODI0.html" target="_blank" rel="external">http://v.youku.com/v_show/id_XODgxODkzODI0.html</a></p>
<h1 id="Day-42-Clang-Attributes-黑魔法小记"><a href="#Day-42-Clang-Attributes-黑魔法小记" class="headerlink" title="# Day 42 : Clang Attributes 黑魔法小记"></a># Day 42 : <a href="http://blog.sunnyxx.com/2016/05/14/clang-attributes/" target="_blank" rel="external">Clang Attributes 黑魔法小记</a></h1><p>由 <a href="http://blog.sunnyxx.com/" target="_blank" rel="external">sunnyxx的技术博客</a> 发布</p>
<p>Clang Attributes 是 Clang 提供的一种源码注解，方便开发者向编译器表达某种要求，参与控制如 Static Analyzer、Name Mangling、Code Generation 等过程，一般以 <code>__attribute__(xxx)</code> 的形式出现在代码中；为方便使用，一些常用属性也被 Cocoa 定义成宏，比如在系统头文件中经常出现的 NS_CLASS_AVAILABLE_IOS(9_0) 就是 <code>__attribute__(availability(...))</code> 这个属性的简单写法。</p>
<p>– <code>objc_subclassing_restricted</code>：定义一个不可被继承的类。<br>– <code>objc_requires_super</code>：标志子类继承这个方法时需要调用 super，否则给出编译警告。<br>– <code>objc_boxable</code>：box 一个 struct 类型或是 union 类型成 NSValue 对象。<br>– <code>constructor / destructor</code>：构造器和析构器，加上这两个属性的函数会在分别在可执行文件（或 shared library）load和 unload 时被调用，可以理解为在 main() 函数调用前和 return 后执行（若有多个 constructor 且想控制优先级的话，可以写成 <strong>attribute</strong>((constructor(101)))，里面的数字越小优先级越高，1 ~ 100 为系统保留。）<br>– <code>enable_if</code>：只能用在 C 函数上，可以用来实现参数的静态检查。<br>– <code>cleanup</code>：声明到一个变量上，当这个变量作用域结束时，调用指定的一个函数，Reactive Cocoa 用这个特性实现了神奇的 @onExit。<br>– <code>overloadable</code>：用于 C 函数，可以定义若干个函数名相同，但参数不同的方法，调用时编译器会自动根据参数选择函数原型。<br>– <code>objc_runtime_name</code>：用于 @interface 或 @protocol，将类或协议的名字在编译时指定成另一个。</p>
<h1 id="Day-41-巧用-Class-Extension-分离接口依赖"><a href="#Day-41-巧用-Class-Extension-分离接口依赖" class="headerlink" title="# Day 41 : 巧用 Class Extension 分离接口依赖"></a># Day 41 : <a href="http://blog.sunnyxx.com/2016/04/22/objc-class-extension-tips/" target="_blank" rel="external">巧用 Class Extension 分离接口依赖</a></h1><p>由 <a href="http://blog.sunnyxx.com/" target="_blank" rel="external">sunnyxx的技术博客</a> 发布</p>
<p>– Category 的实现可以依赖主类，但主类一定不依赖 Category，也就是说移除任何一个 Category 的代码不会对主类产生任何影响。<br>– Category 可以直接使用主类已有的私有成员变量，但不应该为实现 Category 而往主类中添加成员变量，考虑在 Category 的实现中使用 objc association 来达到相同效果。<br>– Class Extension 和 Category 在语言机制上有着很大差别：Class Extension 在编译期就会将定义的 Ivar、属性、方法等直接合入主类，而 Category 在程序启动 Runtime Loading 时才会将属性（没 Ivar）和方法合入主类。<br>– 将对公业务和对私业务用 Class Extension 的形式拆到两个 Header 中，这样私有类对私有属性的依赖就被成功隔离开</p>
<h1 id="Day-40-2015-Objective-C-新特性"><a href="#Day-40-2015-Objective-C-新特性" class="headerlink" title="# Day 40 : 2015 Objective-C 新特性"></a># Day 40 : <a href="http://blog.sunnyxx.com/2015/06/12/objc-new-features-in-2015/" target="_blank" rel="external">2015 Objective-C 新特性</a></h1><p>由 <a href="http://blog.sunnyxx.com/" target="_blank" rel="external">sunnyxx的技术博客</a> 发布</p>
<p>– Nullability：Nullability 在编译器层面提供了空值的类型检查，在类型不符时给出 warning，方便开发者第一时间发现潜在问题。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>, <span class="keyword">readonly</span>, nullable) <span class="built_in">NSArray</span> *friends;</span><br><span class="line">+ (nullable <span class="built_in">NSString</span> *)friendWithName:(nonnull <span class="built_in">NSString</span> *)name;</span><br><span class="line"><span class="comment">// 假如用来修饰一个变量，前面还要加双下划线：</span></span><br><span class="line">- (<span class="keyword">void</span>)startWithCompletionBlock:(nullable <span class="keyword">void</span> (^)(<span class="built_in">NSError</span> * __nullable error))block;</span><br></pre></td></tr></table></figure></p>
<p>–     Lightweight Generics *<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *strings = @[<span class="string">@"sun"</span>, <span class="string">@"yuan"</span>];</span><br><span class="line"><span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="built_in">NSNumber</span> *&gt; *mapping = @&#123;<span class="string">@"a"</span>: @<span class="number">1</span>, <span class="string">@"b"</span>: @<span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">readonly</span>) <span class="built_in">NSArray</span>&lt;<span class="built_in">NSURL</span> *&gt; *imageURLs;</span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">Stack</span>&lt;<span class="title">ObjectType</span>&gt; : <span class="title">NSObject</span></span></span><br></pre></td></tr></table></figure></p>
<p>– __covariant - 协变性，子类型可以强转到父类型（里氏替换原则）：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">interface</span> Stack&lt;__covariant ObjectType&gt; : <span class="type">NSObject</span></span><br></pre></td></tr></table></figure></p>
<p>– __contravariant - 逆变性，父类型可以强转到子类型：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="keyword">interface</span> Stack&lt;__contravariant ObjectType&gt; : <span class="type">NSObject</span></span><br></pre></td></tr></table></figure></p>
<p>–  __kindof<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">copy</span>) <span class="built_in">NSArray</span>&lt;__kindof <span class="built_in">UIView</span> *&gt; *subviews;</span><br><span class="line">这样，写下面的代码时就没有任何警告了：</span><br><span class="line"><span class="built_in">UIButton</span> *button = view.subviews.lastObject;</span><br></pre></td></tr></table></figure></p>
<h1 id="Day-39-yesterday-黑魔法attribute-cleanup"><a href="#Day-39-yesterday-黑魔法attribute-cleanup" class="headerlink" title="# Day 39(yesterday) : 黑魔法attribute((cleanup))"></a># Day 39(yesterday) : <a href="http://blog.sunnyxx.com/2014/09/15/objc-attribute-cleanup/" target="_blank" rel="external">黑魔法<strong>attribute</strong>((cleanup))</a></h1><p>由 <a href="http://blog.sunnyxx.com/" target="_blank" rel="external">sunnyxx的技术博客</a> 发布</p>
<p>– <strong>attribute</strong>((cleanup(…)))，用于修饰一个变量，在它的作用域结束时可以自动执行一个指定的方法。<br>– 所谓作用域结束，包括大括号结束、return、goto、break、exception等各种情况。<br>– 假如一个作用域内有若干个cleanup的变量，他们的调用顺序是先入后出的栈式顺序；而且，cleanup是先于这个对象的dealloc调用的。<br>– 可以修饰的变量有：NSString、自定义Class、基本类型、block：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.NSString ---------------------------------------------</span></span><br><span class="line"><span class="comment">// 指定一个cleanup方法，注意入参是所修饰变量的地址，类型要一样</span></span><br><span class="line"><span class="comment">// 对于指向objc对象的指针(id *)，如果不强制声明__strong默认是__autoreleasing，造成类型不匹配</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> stringCleanUp(__<span class="keyword">strong</span> <span class="built_in">NSString</span> **string) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, *string);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在某个方法中：</span></span><br><span class="line">&#123;</span><br><span class="line">    __<span class="keyword">strong</span> <span class="built_in">NSString</span> *string __attribute__((cleanup(stringCleanUp))) = <span class="string">@"sunnyxx"</span>;</span><br><span class="line">&#125; <span class="comment">// 当运行到这个作用域结束时，自动调用stringCleanUp</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.自定义的Class ---------------------------------------------</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> sarkCleanUp(__<span class="keyword">strong</span> Sark **sark) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%@"</span>, *sark);</span><br><span class="line">&#125;</span><br><span class="line">__<span class="keyword">strong</span> Sark *sark __attribute__((cleanup(sarkCleanUp))) = [Sark new];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.基本类型 ---------------------------------------------</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> intCleanUp(<span class="built_in">NSInteger</span> *integer) &#123;</span><br><span class="line">    <span class="built_in">NSLog</span>(<span class="string">@"%d"</span>, *integer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">NSInteger</span> integer __attribute__((cleanup(intCleanUp))) = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.block ---------------------------------------------</span></span><br><span class="line"><span class="comment">// void(^block)(void)的指针是void(^*block)(void)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> blockCleanUp(__<span class="keyword">strong</span> <span class="keyword">void</span>(^*block)(<span class="keyword">void</span>)) &#123;</span><br><span class="line">    (*block)();</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">// 加了个`unused`的attribute用来消除`unused variable`的warning</span></span><br><span class="line">    __<span class="keyword">strong</span> <span class="keyword">void</span>(^block)(<span class="keyword">void</span>) __attribute__((cleanup(blockCleanUp), unused)) = ^&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@"I'm dying..."</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Reactive Cocoa中神奇的@onExit方法，其实正是上面的写法，简单定义个宏：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> onExit\</span></span><br><span class="line">    __<span class="function">strong <span class="title">void</span>(<span class="params">^block</span>)(<span class="params"><span class="keyword">void</span></span>) __<span class="title">attribute__</span>(<span class="params">(cleanup(blockCleanUp</span>), unused)) </span>= ^</span><br></pre></td></tr></table></figure></p>
<p>用这个宏就能将一段写在前面的代码最后执行：<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    onExit &#123;</span><br><span class="line">        NSLog(@<span class="string">"yo"</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; // Log <span class="string">"yo"</span></span><br></pre></td></tr></table></figure></p>
<h1 id="Day-38-iOS-程序员-6-级考试（答案和解释）"><a href="#Day-38-iOS-程序员-6-级考试（答案和解释）" class="headerlink" title="# Day 38 : iOS 程序员 6 级考试（答案和解释）"></a># Day 38 : <a href="http://blog.sunnyxx.com/2014/03/06/ios_exam_0_key/" target="_blank" rel="external">iOS 程序员 6 级考试（答案和解释）</a></h1><p>由 <a href="http://blog.sunnyxx.com/" target="_blank" rel="external">sunnyxx的技术博客</a> 发布</p>
<p>五道iOS题目，查看原文。</p>
<h1 id="Day-37-iOS-程序-main-函数之前发生了什么"><a href="#Day-37-iOS-程序-main-函数之前发生了什么" class="headerlink" title="# Day 37 : iOS 程序 main 函数之前发生了什么"></a># Day 37 : <a href="http://blog.sunnyxx.com/2014/08/30/objc-pre-main/" target="_blank" rel="external">iOS 程序 main 函数之前发生了什么</a></h1><p>由 <a href="http://blog.sunnyxx.com/" target="_blank" rel="external">sunnyxx的技术博客</a> 发布</p>
<ol>
<li>从dyld开始<br>1.1. 动态链接库<br>1.2. dyld：（the dynamic link editor），Apple 的动态链接器，系统 kernel 做好启动程序的初始准备后，交给 dyld 负责。<br>1.3. ImageLoader：当然这个 image 不是图片的意思，它大概表示一个二进制文件（可执行文件或 so 文件），里面是被编译过的符号、代码等，所以 ImageLoader 作用是将这些文件加载进内存，且每一个文件对应一个ImageLoader实例来负责加载。</li>
<li>runtime 与 +load：dyld 担当了 runtime 和 ImageLoader 中间的协调者，当新 image 加载进来后交由 runtime 大厨去解析这个二进制文件的符号表和代码。<br>2.1. 关于 +load 方法的几个 QA</li>
<li>简单总结：整个事件由 dyld 主导，完成运行环境的初始化后，配合 ImageLoader 将二进制文件按格式加载到内存，动态链接依赖库，并由 runtime 负责加载成 objc 定义的结构，所有初始化工作结束后，dyld 调用真正的 main 函数。</li>
</ol>
<h1 id="Day-36-黑幕背后的Autorelease"><a href="#Day-36-黑幕背后的Autorelease" class="headerlink" title="# Day 36 : 黑幕背后的Autorelease"></a># Day 36 : <a href="http://blog.sunnyxx.com/2014/10/15/behind-autorelease/" target="_blank" rel="external">黑幕背后的Autorelease</a></h1><p>由 <a href="http://blog.sunnyxx.com/" target="_blank" rel="external">sunnyxx的技术博客</a> 发布</p>
<ol>
<li>Autorelease对象什么时候释放？<br>1.1. 在没有手加Autorelease Pool的情况下，Autorelease对象是在当前的runloop迭代结束时释放的，而它能够释放的原因是系统在每个runloop迭代中都加入了自动释放池Push和Pop</li>
<li>Autorelease原理<br>2.1. AutoreleasePoolPage<br>2.1.1. AutoreleasePool并没有单独的结构，而是由若干个AutoreleasePoolPage以双向链表的形式组合而成（分别对应结构中的parent指针和child指针）<br>2.1.2. AutoreleasePool是按线程一一对应的（结构中的thread指针指向当前线程）<br>2.1.3. AutoreleasePoolPage每个对象会开辟4096字节内存（也就是虚拟内存一页的大小），除了上面的实例变量所占空间，剩下的空间全部用来储存autorelease对象的地址<br>2.1.4. 上面的id *next指针作为游标指向栈顶最新add进来的autorelease对象的下一个位置<br>2.1.5. 一个AutoreleasePoolPage的空间被占满时，会新建一个AutoreleasePoolPage对象，连接链表，后来的autorelease对象在新的page加入<br>2.2. 释放时刻<br>2.2.1. 每当进行一次objc_autoreleasePoolPush调用时，runtime向当前的AutoreleasePoolPage中add进一个哨兵对象，值为0（也就是个nil）<br>2.2.2. 根据传入的哨兵对象地址找到哨兵对象所处的page<br>2.2.3. 在当前page中，将晚于哨兵对象插入的所有autorelease对象都发送一次- release消息，并向回移动next指针到正确位置<br>2.2.4. 从最新加入的对象一直向前清理，可以向前跨越若干个page，直到哨兵所在的page<br>2.3. 嵌套的AutoreleasePool<br>2.3.1. 知道了上面的原理，嵌套的AutoreleasePool就非常简单了，pop的时候总会释放到上次push的位置为止，多层的pool就是多个哨兵对象而已，就像剥洋葱一样，每次一层，互不影响。</li>
<li>Autorelease返回值的快速释放机制<br>3.1. 黑魔法之Thread Local Storage<br>3.2. 黑魔法之__builtin_return_address<br>3.3. 黑魔法之反查汇编指令</li>
<li>其他Autorelease相关知识点<br>4.1. 使用容器的block版本的枚举器时，内部会自动添加一个AutoreleasePool。当然，在普通for循环和for in循环中没有，所以，还是新版的block版本枚举器更加方便。for循环中遍历产生大量autorelease变量时，就需要手加局部AutoreleasePool咯。</li>
</ol>
<h1 id="Day-35-Objective-C-Method-Swizzling"><a href="#Day-35-Objective-C-Method-Swizzling" class="headerlink" title="# Day 35 : Objective-C Method Swizzling"></a># Day 35 : <a href="http://yulingtianxia.com/blog/2017/04/17/Objective-C-Method-Swizzling/" target="_blank" rel="external">Objective-C Method Swizzling</a></h1><p>由 <a href="http://yulingtianxia.com/" target="_blank" rel="external">玉令天下的博客</a> 发布</p>
<p>Method Swizzling 常用实现方案<br>方案A：<br>如果类中没有实现 Original selector 对应的方法，那就先添加 Method，并将其 IMP 映射为 Swizzle 的实现。然后替换 Swizzle selector 的 IMP 为 Original 的实现；否则交换二者 IMP。<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">+ (void)load &#123;</span><br><span class="line">    static <span class="keyword">dispatch_once_t </span>onceToken<span class="comment">;</span></span><br><span class="line">    <span class="keyword">dispatch_once(&amp;onceToken, </span>^&#123;</span><br><span class="line">        Class aClass = [self class]<span class="comment">;</span></span><br><span class="line">        </span><br><span class="line">        SEL <span class="keyword">originalSelector </span>= @selector(method_original:)<span class="comment">;</span></span><br><span class="line">        SEL <span class="keyword">swizzledSelector </span>= @selector(method_swizzle:)<span class="comment">;</span></span><br><span class="line">        </span><br><span class="line">        Method <span class="keyword">originalMethod </span>= class_getInstanceMethod(aClass, <span class="keyword">originalSelector);</span><br><span class="line"></span>        Method <span class="keyword">swizzledMethod </span>= class_getInstanceMethod(aClass, <span class="keyword">swizzledSelector);</span><br><span class="line"></span>        <span class="keyword">BOOL </span><span class="keyword">didAddMethod </span>=</span><br><span class="line">        class_addMethod(aClass,</span><br><span class="line">                        <span class="keyword">originalSelector,</span><br><span class="line"></span>                        method_getImplementation(<span class="keyword">swizzledMethod),</span><br><span class="line"></span>                        method_getTypeEncoding(<span class="keyword">swizzledMethod));</span><br><span class="line"></span>        </span><br><span class="line">        if (<span class="keyword">didAddMethod) </span>&#123;</span><br><span class="line">            class_replaceMethod(aClass,</span><br><span class="line">                                <span class="keyword">swizzledSelector,</span><br><span class="line"></span>                                method_getImplementation(<span class="keyword">originalMethod),</span><br><span class="line"></span>                                method_getTypeEncoding(<span class="keyword">originalMethod));</span><br><span class="line"></span>        &#125; else &#123;</span><br><span class="line">            method_exchangeImplementations(<span class="keyword">originalMethod, </span><span class="keyword">swizzledMethod);</span><br><span class="line"></span>        &#125;</span><br><span class="line">    &#125;)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有时为了避免方法命名冲突和参数 _cmd 被篡改，也会使用下面这种『静态方法版本』的 Method Swizzle。CaptainHook 中的宏定义也是采用这种方式，比较推荐：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> IMP *IMPPointer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> MethodSwizzle(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="keyword">id</span> arg1);</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> (*MethodOriginal)(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="keyword">id</span> arg1);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> MethodSwizzle(<span class="keyword">id</span> <span class="keyword">self</span>, SEL _cmd, <span class="keyword">id</span> arg1) &#123;</span><br><span class="line">    <span class="comment">// do custom work</span></span><br><span class="line">    MethodOriginal(<span class="keyword">self</span>, _cmd, arg1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">BOOL</span> class_swizzleMethodAndStore(Class class, SEL original, IMP replacement, IMPPointer store) &#123;</span><br><span class="line">    IMP imp = <span class="literal">NULL</span>;</span><br><span class="line">    Method method = class_getInstanceMethod(class, original);</span><br><span class="line">    <span class="keyword">if</span> (method) &#123;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span> *type = method_getTypeEncoding(method);</span><br><span class="line">        imp = class_replaceMethod(class, original, replacement, type);</span><br><span class="line">        <span class="keyword">if</span> (!imp) &#123;</span><br><span class="line">            imp = method_getImplementation(method);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (imp &amp;&amp; store) &#123; *store = imp; &#125;</span><br><span class="line">    <span class="keyword">return</span> (imp != <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="built_in">BOOL</span>)swizzle:(SEL)original with:(IMP)replacement store:(IMPPointer)store &#123;</span><br><span class="line">    <span class="keyword">return</span> class_swizzleMethodAndStore(<span class="keyword">self</span>, original, replacement, store);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">void</span>)load &#123;</span><br><span class="line">    [<span class="keyword">self</span> swizzle:<span class="keyword">@selector</span>(originalMethod:) with:(IMP)MethodSwizzle store:(IMP *)&amp;MethodOriginal];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>方案 B(方案 A 的阉割版)：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+ (void)load &#123;</span><br><span class="line">    static <span class="keyword">dispatch_once_t </span>onceToken<span class="comment">;</span></span><br><span class="line">    <span class="keyword">dispatch_once(&amp;onceToken, </span>^&#123;</span><br><span class="line">        Class aClass = [self class]<span class="comment">;</span></span><br><span class="line">        </span><br><span class="line">        SEL <span class="keyword">originalSelector </span>= @selector(method_original:)<span class="comment">;</span></span><br><span class="line">        SEL <span class="keyword">swizzledSelector </span>= @selector(method_swizzle:)<span class="comment">;</span></span><br><span class="line">        </span><br><span class="line">        Method <span class="keyword">originalMethod </span>= class_getInstanceMethod(aClass, <span class="keyword">originalSelector);</span><br><span class="line"></span>        Method <span class="keyword">swizzledMethod </span>= class_getInstanceMethod(aClass, <span class="keyword">swizzledSelector);</span><br><span class="line"></span>       method_exchangeImplementations(<span class="keyword">originalMethod, </span><span class="keyword">swizzledMethod);</span><br><span class="line"></span>    &#125;)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>直接交换 IMP 是很危险的。因为如果这个类中没有实现这个方法，class_getInstanceMethod() 返回的是某个父类的 Method 对象，这样 method_exchangeImplementations() 就把父类的原始实现（IMP）跟这个类的 Swizzle 实现交换了。这样其他父类及其其他子类的方法调用就会出问题，最严重的就是 Crash。<br>但如果这个类中实现了此方法，那么方案 A 等价于方案 B。</p>
<p>结论：</p>
<ul>
<li>Hook 顺序：先 Child 类后 Super 类<br>为了保证 Hook 后方法调用顺序是对的，需要同时满足以下两个条件：<br>– 1.Child 类实现被 Hook 的方法<br>– 2.Super 类实现被 Hook 的方法或使用 A 方案 Hook</li>
<li>Hook 顺序：先 Super 类后 Child 类<br>因为 Hook 的顺序是正确的，所以只需满足以下任意一个条件即可：<br>– 1.实现被 Hook 的方法<br>– 2.使用方案 A 进行 Hook</li>
</ul>
<h1 id="Day-34-Objective-C-引用计数原理"><a href="#Day-34-Objective-C-引用计数原理" class="headerlink" title="# Day 34 : Objective-C 引用计数原理"></a># Day 34 : <a href="http://yulingtianxia.com/blog/2015/12/06/The-Principle-of-Refenrence-Counting/" target="_blank" rel="external">Objective-C 引用计数原理</a></h1><p>由 <a href="http://yulingtianxia.com/" target="_blank" rel="external">玉令天下的博客</a> 发布</p>
<p>有些对象如果支持使用 TaggedPointer，苹果会直接将其指针值作为引用计数返回；如果当前设备是 64 位环境并且使用 Objective-C 2.0，那么“一些”对象会使用其 isa 指针的一部分空间来存储它的引用计数；否则 Runtime 会使用一张散列表来管理引用计数。</p>
<ol>
<li>引用计数如何存储<br>1.1. TaggedPointer<br>1.2. isa 指针（NONPOINTER_ISA）<br>1.3. 散列表</li>
<li>获取引用计数</li>
<li>修改引用计数<br>3.1. retain 和 release<br>3.2. alloc, new, copy, mutableCopy<br>3.3. autorelease</li>
<li>Reference</li>
</ol>
<h1 id="Day-33-yesterday-Objective-C-消息发送与转发机制原理"><a href="#Day-33-yesterday-Objective-C-消息发送与转发机制原理" class="headerlink" title="# Day 33(yesterday) : Objective-C 消息发送与转发机制原理"></a># Day 33(yesterday) : <a href="http://yulingtianxia.com/blog/2016/06/15/Objective-C-Message-Sending-and-Forwarding/" target="_blank" rel="external">Objective-C 消息发送与转发机制原理</a></h1><p>由 <a href="http://yulingtianxia.com/" target="_blank" rel="external">玉令天下的博客</a> 发布</p>
<p>消息发送和转发流程可以概括为：<br>消息发送（Messaging）是 Runtime 通过 selector 快速查找 IMP 的过程，有了函数指针就可以执行对应的方法实现；<br>消息转发（Message Forwarding）是在查找 IMP 失败后执行一系列转发流程的慢速通道，如果不作转发处理，则会打日志和抛出异常。</p>
<ol>
<li>八面玲珑的 objc_msgSend<br>1.1. 源码解析<br>1.2. 为什么使用汇编语言</li>
<li>使用 lookUpImpOrForward 快速查找 IMP<br>2.1. 优化缓存查找&amp;类的初始化<br>2.2. 继续在类的继承体系中查找<br>2.3. 回顾 objc_msgSend 伪代码</li>
<li>forwarding 中路漫漫的消息转发<br>3.1. objc_msgForward_impcache 的转换<br>3.2. objc_msgForward 也只是个入口<br>3.3. objc_setForwardHandler 设置了消息转发的回调<br>3.4. 逆向工程助力刨根问底</li>
<li>总结</li>
<li>参考文献</li>
</ol>
<h1 id="Day-32-HTTPS-是如何保证安全的？"><a href="#Day-32-HTTPS-是如何保证安全的？" class="headerlink" title="# Day 32 : HTTPS 是如何保证安全的？"></a># Day 32 : <a href="http://www.jianshu.com/p/b894a7e1c779" target="_blank" rel="external">HTTPS 是如何保证安全的？</a></h1><p>由 <a href="http://www.jianshu.com/u/87b62ec36074" target="_blank" rel="external">程序员Delton</a> 发布</p>
<ol>
<li>HTTP 面临的一个问题叫做 “窃听” 或者 “嗅探” ，指的是和你在同一个网络下或者是途径的路由上的攻击者可以偷窥到你传输的内容。</li>
<li>HTTPS 通常是通过“加密”来解决这个问题。<br>2.1. 对称加密：需要一个密钥 key 来加密整个信息，加密和解密所需要使用的 key 是一样的。比如 AES 算法，在数学上保证了，只要你使用的 key 足够足够足够足够的长，破解是几乎不可能的。<br>2.2. 非对称加密：可以生成一对密钥 (k1, k2)，凡是 k1 加密的数据，k1 自身不能解密，而需要 k2 才能解密；凡是 k2 加密的数据，k2 不能解密，需要 k1 才能解密。这种算法事实上有很多，常用的是 RSA，其基于的数学原理是两个大素数的乘积很容易算，而拿到这个乘积去算出是哪两个素数相乘就很复杂了。<br>2.2.1. 用 RSA 技术生成了一对 k1、k2，你把 k1 用明文发送了出去，路经有人或许会截取，但是没有用，k1 加密的数据需要用 k2 才能解密。而此时，k2 在你自己的手里。k1 送达目的地后，目的地的人会去准备一个接下来用于对称加密传输的密钥 key，然后用收到的 k1 把 key 加密了，把加密好的数据传回来。路上的人就算截取到了，也解密不出 key。等到了你自己手上，你用手上的 k2 把用 k1 加密的 key 解出来，现在就只有你和你的目的地拥有 key，你们就可以用 AES 算法进行对称加密的传输啦。<br>2.2.2. 第一个问题：因为 非对称加密 的密码对生成和加密的消耗时间比较长，为了节省双方的计算时间，通常只用它来交换密钥，而非直接用来传输数据。<br>2.2.3. 第二个问题：中间人攻击。<br>2.2.4. 为解决第二个问题引入一个第三方叫做 CA。CA 是一些非常权威的专门用于认证一个网站合法性的组织。服务商可以向他们申请一个证书，使得他们建立安全连接时可以带上 CA 的签名。如果和你建立安全连接的人带着这些人的签名，那么认为这个安全连接是安全的，没有遭到中间人攻击。</li>
</ol>
<h1 id="Day-31-Objective-C-Runtime"><a href="#Day-31-Objective-C-Runtime" class="headerlink" title="# Day 31 : Objective-C Runtime"></a># Day 31 : <a href="http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/?url_type=39&amp;object_type=webpage&amp;pos=1" target="_blank" rel="external">Objective-C Runtime</a></h1><p>由 <a href="http://yulingtianxia.com/" target="_blank" rel="external">玉令天下的博客</a> 发布</p>
<ol>
<li>引言</li>
<li>简介</li>
<li>与 Runtime 交互<br>3.1. Objective-C 源代码<br>3.2. NSObject 的方法<br>3.3. Runtime 的函数</li>
<li>Runtime 基础数据结构<br>4.1. SEL<br>4.2. id<br>4.3. Class<br>4.3.1. cache_t<br>4.3.2. class_data_bits_t<br>4.3.3. class_ro_t<br>4.3.4. class_rw_t<br>4.3.5. realizeClass<br>4.4. Category<br>4.5. Method<br>4.6. Ivar<br>4.7. objc_property_t<br>4.8. protocol_t<br>4.9. IMP</li>
<li>消息<br>5.1. objc_msgSend 函数<br>5.2. 方法中的隐藏参数<br>5.3. 获取方法地址</li>
<li>动态方法解析</li>
<li>消息转发<br>7.1. 重定向<br>7.2. 转发<br>7.3. 转发和多继承<br>7.4. 替代者对象(Surrogate Objects)<br>7.5. 转发与继承</li>
<li>健壮的实例变量 (Non Fragile ivars)</li>
<li>Objective-C Associated Objects</li>
<li>Method Swizzling</li>
<li>总结</li>
</ol>
<p>文章相当长且有质量，把目录贴出来，有不清楚或需要学习的再去原文查阅吧！</p>
<h1 id="Day-30-神经病院Objective-C-Runtime出院第三天——如何正确使用Runtime"><a href="#Day-30-神经病院Objective-C-Runtime出院第三天——如何正确使用Runtime" class="headerlink" title="# Day 30 : 神经病院Objective-C Runtime出院第三天——如何正确使用Runtime"></a># Day 30 : <a href="http://www.jianshu.com/p/db6dc23834e3" target="_blank" rel="external">神经病院Objective-C Runtime出院第三天——如何正确使用Runtime</a></h1><p>由 <a href="http://www.jianshu.com/u/12201cdd5d7a" target="_blank" rel="external">一缕殇流化隐半边冰霜（halfrost）</a> 发布</p>
<ul>
<li>Runtime的优点<ul>
<li>实现多继承Multiple Inheritance：<br>  – <code>forwardingTargetForSelector:</code>这一步将消息转发给正确的类对象就可以模拟多继承的效果<br>  – 即使我们利用转发消息来实现了“假”继承，但是NSObject类还是会将两者区分开，像respondsToSelector:和 isKindOfClass:这类方法只会考虑继承体系，不会考虑转发链，可以重写 respondsToSelector:和 isKindOfClass:等方法来加入自己的转发算法。</li>
<li>Method Swizzling：<ul>
<li>Method Swizzling原理：本质上就是对IMP和SEL进行交换。</li>
<li>Method Swizzling使用：通常应用于在category中添加一个方法。</li>
<li>Method Swizzling注意点<br>  – Swizzling应该总在+load中执行<br>  – Swizzling应该总是在dispatch_once中执行<br>  – Swizzling在+load中执行时，不要调用[super load]</li>
<li>Method Swizzling使用场景<br>  – 实现AOP<br>  – 实现埋点统计<br>  – 实现异常保护</li>
</ul>
</li>
<li>Aspect Oriented Programming</li>
<li>Isa Swizzling<br>  – KVO是为了监听一个对象的某个属性值是否发生变化。在属性值发生变化的时候，肯定会调用其setter方法。所以KVO的本质就是监听对象有没有调用被监听属性对应的setter方法。</li>
<li>Associated Object关联对象</li>
<li>动态的增加方法</li>
<li>NSCoding的自动归档和自动解档<br>  – 用runtime实现的思路就比较简单，我们循环依次找到每个成员变量的名称，然后利用KVC读取和赋值就可以完成encodeWithCoder和initWithCoder了。</li>
<li>字典和模型互相转换<ul>
<li>字典转模型<br>  – 调用 class_getProperty 方法获取当前 Model 的所有属性。<br>  – 调用 property_copyAttributeList 获取属性列表。<br>  – 根据属性名称生成 setter 方法。<br>  – 使用 objc_msgSend 调用 setter 方法为 Model 的属性赋值（或者 KVC）</li>
<li>模型转字典<br>  – 调用 class_copyPropertyList 方法获取当前 Model 的所有属性。<br>  – 调用 property_getName 获取属性名称。<br>  – 根据属性名称生成 getter 方法。<br>  – 使用 objc_msgSend 调用 getter 方法获取属性值（或者 KVC）</li>
</ul>
</li>
</ul>
</li>
<li>Runtime的缺点<br>  –     Method swizzling is not atomic<br>  –     Changes behavior of un-owned code<br>  –     Possible naming conflicts<br>  –     Swizzling changes the method’s arguments<br>  –     The order of swizzles matters<br>  –     Difficult to understand (looks recursive)<br>  –     Difficult to debug</li>
</ul>
<p>日常可能用的比较多的Runtime函数：<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用指定方法的实现 </span></span><br><span class="line">id method_invoke ( id receiver, <span class="function"><span class="keyword">Method</span> <span class="title">m</span>, ... );</span> </span><br><span class="line"><span class="comment">// 调用返回一个数据结构的方法的实现 </span></span><br><span class="line">void method_invoke_stret ( id receiver, <span class="function"><span class="keyword">Method</span> <span class="title">m</span>, ... );</span> </span><br><span class="line"><span class="comment">// 返回指定方法的方法描述结构体 </span></span><br><span class="line">struct objc_method_description * method_getDescription ( <span class="function"><span class="keyword">Method</span> <span class="title">m</span> );</span> </span><br><span class="line"></span><br><span class="line"><span class="comment">//获取cls类对象所有成员ivar结构体 </span></span><br><span class="line">Ivar *class_copyIvarList(<span class="keyword">Class</span> cls, unsigned int *outCount) </span><br><span class="line"><span class="comment">//获取cls类对象name对应的实例方法结构体 </span></span><br><span class="line"><span class="function"><span class="keyword">Method</span> <span class="title">class_getInstanceMethod</span><span class="params">(<span class="keyword">Class</span> cls, SEL name)</span> </span><br><span class="line">//获取<span class="title">cls</span>类对象<span class="title">name</span>对应类方法结构体 </span><br><span class="line"><span class="title">Method</span> <span class="title">class_getClassMethod</span><span class="params">(<span class="keyword">Class</span> cls, SEL name)</span> </span><br><span class="line">//获取<span class="title">cls</span>类对象<span class="title">name</span>对应方法<span class="title">imp</span>实现 </span><br><span class="line"><span class="title">IMP</span> <span class="title">class_getMethodImplementation</span><span class="params">(<span class="keyword">Class</span> cls, SEL name)</span> </span><br><span class="line">//测试<span class="title">cls</span>对应的实例是否响应<span class="title">sel</span>对应的方法 </span><br><span class="line"><span class="title">BOOL</span> <span class="title">class_respondsToSelector</span><span class="params">(<span class="keyword">Class</span> cls, SEL sel)</span> </span><br><span class="line">//获取<span class="title">cls</span>对应方法列表 </span><br><span class="line"><span class="title">Method</span> *<span class="title">class_copyMethodList</span><span class="params">(<span class="keyword">Class</span> cls, unsigned int *outCount)</span> </span><br><span class="line">//测试<span class="title">cls</span>是否遵守<span class="title">protocol</span>协议 </span><br><span class="line"><span class="title">BOOL</span> <span class="title">class_conformsToProtocol</span><span class="params">(<span class="keyword">Class</span> cls, Protocol *protocol)</span> </span><br><span class="line">//为<span class="title">cls</span>类对象添加新方法 </span><br><span class="line"><span class="title">BOOL</span> <span class="title">class_addMethod</span><span class="params">(<span class="keyword">Class</span> cls, SEL name, IMP imp, <span class="keyword">const</span> char *types)</span> </span><br><span class="line">//替换<span class="title">cls</span>类对象中<span class="title">name</span>对应方法的实现 </span><br><span class="line"><span class="title">IMP</span> <span class="title">class_replaceMethod</span><span class="params">(<span class="keyword">Class</span> cls, SEL name, IMP imp, <span class="keyword">const</span> char *types)</span> </span><br><span class="line">//为<span class="title">cls</span>添加新成员 </span><br><span class="line"><span class="title">BOOL</span> <span class="title">class_addIvar</span><span class="params">(<span class="keyword">Class</span> cls, <span class="keyword">const</span> char *name, size_t size, uint8_t alignment, <span class="keyword">const</span> char *types)</span> </span><br><span class="line">//为<span class="title">cls</span>添加新属性 </span><br><span class="line"><span class="title">BOOL</span> <span class="title">class_addProperty</span><span class="params">(<span class="keyword">Class</span> cls, <span class="keyword">const</span> char *name, <span class="keyword">const</span> objc_property_attribute_t *attributes, unsigned int attributeCount)</span> </span><br><span class="line">//获取<span class="title">m</span>对应的选择器 </span><br><span class="line"><span class="title">SEL</span> <span class="title">method_getName</span><span class="params">(<span class="keyword">Method</span> m)</span> </span><br><span class="line">//获取<span class="title">m</span>对应的方法实现的<span class="title">imp</span>指针 </span><br><span class="line"><span class="title">IMP</span> <span class="title">method_getImplementation</span><span class="params">(<span class="keyword">Method</span> m)</span> </span><br><span class="line">//获取<span class="title">m</span>方法的对应编码 </span><br><span class="line"><span class="title">const</span> <span class="title">char</span> *<span class="title">method_getTypeEncoding</span><span class="params">(<span class="keyword">Method</span> m)</span> </span><br><span class="line">//获取<span class="title">m</span>方法参数的个数 </span><br><span class="line"><span class="title">unsigned</span> <span class="title">int</span> <span class="title">method_getNumberOfArguments</span><span class="params">(<span class="keyword">Method</span> m)</span> </span><br><span class="line">//<span class="title">copy</span>方法返回值类型 </span><br><span class="line"><span class="title">char</span> *<span class="title">method_copyReturnType</span><span class="params">(<span class="keyword">Method</span> m)</span> </span><br><span class="line">//获取<span class="title">m</span>方法<span class="title">index</span>索引参数的类型 </span><br><span class="line"><span class="title">char</span> *<span class="title">method_copyArgumentType</span><span class="params">(<span class="keyword">Method</span> m, unsigned int <span class="keyword">index</span>)</span> </span><br><span class="line">//获取<span class="title">m</span>方法返回值类型 </span><br><span class="line"><span class="title">void</span> <span class="title">method_getReturnType</span><span class="params">(<span class="keyword">Method</span> m, char *dst, size_t dst_len)</span> </span><br><span class="line">//获取方法的参数类型 </span><br><span class="line"><span class="title">void</span> <span class="title">method_getArgumentType</span><span class="params">(<span class="keyword">Method</span> m, unsigned int <span class="keyword">index</span>, char *dst, size_t dst_len)</span> </span><br><span class="line">//设置<span class="title">m</span>方法的具体实现指针 </span><br><span class="line"><span class="title">IMP</span> <span class="title">method_setImplementation</span><span class="params">(<span class="keyword">Method</span> m, IMP imp)</span> </span><br><span class="line">//交换<span class="title">m1</span>，<span class="title">m2</span>方法对应具体实现的函数指针 </span><br><span class="line"><span class="title">void</span> <span class="title">method_exchangeImplementations</span><span class="params">(<span class="keyword">Method</span> m1, <span class="keyword">Method</span> m2)</span> </span><br><span class="line">//获取<span class="title">v</span>的名称 </span><br><span class="line"><span class="title">const</span> <span class="title">char</span> *<span class="title">ivar_getName</span><span class="params">(Ivar v)</span> </span><br><span class="line">//获取<span class="title">v</span>的类型编码 </span><br><span class="line"><span class="title">const</span> <span class="title">char</span> *<span class="title">ivar_getTypeEncoding</span><span class="params">(Ivar v)</span> </span><br><span class="line">//设置<span class="title">object</span>对象关联的对象 </span><br><span class="line"><span class="title">void</span> <span class="title">objc_setAssociatedObject</span><span class="params">(id object, <span class="keyword">const</span> void *key, id value, objc_AssociationPolicy policy)</span> </span><br><span class="line">//获取<span class="title">object</span>关联的对象 </span><br><span class="line"><span class="title">id</span> <span class="title">objc_getAssociatedObject</span><span class="params">(id object, <span class="keyword">const</span> void *key)</span> </span><br><span class="line">//移除<span class="title">object</span>关联的对象 </span><br><span class="line"><span class="title">void</span> <span class="title">objc_removeAssociatedObjects</span><span class="params">(id object)</span></span></span><br></pre></td></tr></table></figure></p>
<p>⚠️注：runtime 系列文章，有原理讲解有用法示例，深度好文！</p>
<h1 id="Day-29-神经病院Objective-C-Runtime住院第二天——消息发送与转发"><a href="#Day-29-神经病院Objective-C-Runtime住院第二天——消息发送与转发" class="headerlink" title="# Day 29 : 神经病院Objective-C Runtime住院第二天——消息发送与转发"></a># Day 29 : <a href="http://www.jianshu.com/p/4d619b097e20" target="_blank" rel="external">神经病院Objective-C Runtime住院第二天——消息发送与转发</a></h1><p>由 <a href="http://www.jianshu.com/u/12201cdd5d7a" target="_blank" rel="external">一缕殇流化隐半边冰霜（halfrost）</a> 发布</p>
<ul>
<li>objc_msgSend函数简介。objc_msgSend会做一下几件事情：<br>  – 检测这个 selector 是不是要忽略的。<br>  – 检查target是不是为nil。如果这里有相应的nil的处理函数，就跳转到相应的函数中。如果没有处理nil的函数，就自动清理现场并返回。这一点就是为何在OC中给nil发送消息不会崩溃的原因。<br>  – 确定不是给nil发消息之后，在该class的缓存中查找方法对应的IMP实现。如果找到，就跳转进去执行。如果没有找到，就在方法分发表里面继续查找，一直找到NSObject为止<br>  – 如果还没有找到，那就需要开始消息转发阶段了。至此，发送消息Messaging阶段完成。这一阶段主要完成的是通过select()快速查找IMP的过程</li>
<li>消息发送Messaging阶段—objc_msgSend源码解析</li>
<li>消息转发Message Forwarding阶段</li>
<li>forwardInvocation的例子</li>
<li>入院考试</li>
<li>Runtime中的优化<br>  –    方法列表的缓存<br>  – 虚函数表vTable<br>  – dyld共享缓存</li>
</ul>
<p>runtime 系列文章，同样很有深度。因为有很多源码分析和原理讲解且内容较多所以不好简洁总结，之后再温故知新吧！</p>
<h1 id="Day-28-神经病院Objective-C-Runtime入院第一天——isa和Class"><a href="#Day-28-神经病院Objective-C-Runtime入院第一天——isa和Class" class="headerlink" title="# Day 28 : 神经病院Objective-C Runtime入院第一天——isa和Class"></a># Day 28 : <a href="http://www.jianshu.com/p/9d649ce6d0b8" target="_blank" rel="external">神经病院Objective-C Runtime入院第一天——isa和Class</a></h1><p>由 <a href="http://www.jianshu.com/u/12201cdd5d7a" target="_blank" rel="external">一缕殇流化隐半边冰霜（halfrost）</a> 发布</p>
<ul>
<li><p>NSObject起源<br>  – 在NSObject协议中，有以下5个方法：</p>
  <figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby"> (Class)<span class="class"><span class="keyword">class</span> <span class="title">OBJC_SWIFT_UNAVAILABLE</span>("<span class="title">use</span> '<span class="title">anObject</span>.<span class="title">dynamicType</span>' <span class="title">instead</span>");</span> /<span class="regexp">/ 返回对象的类</span><br><span class="line"></span></span>-<span class="ruby"><span class="regexp"> (BOOL)isKindOfClass:(Class)aClass; /</span><span class="regexp">/ 检查对象是否存在于指定的类的继承体系中(是否是其子类或者父类或者当前类的成员变量)</span><br><span class="line"></span></span>-<span class="ruby"><span class="regexp"> (BOOL)isMemberOfClass:(Class)aClass; /</span><span class="regexp">/ 检查对象是否存在于指定的类的继承体系中(是否是其子类或者父类或者当前类的成员变量)</span><br><span class="line"></span></span>-<span class="ruby"><span class="regexp"> (BOOL)conformsToProtocol:(Protocol *)aProtocol; /</span><span class="regexp">/ 检查对象能否响应指定的消息</span><br><span class="line"></span></span>-<span class="ruby"><span class="regexp"> (BOOL)respondsToSelector:(SEL)aSelector; /</span><span class="regexp">/ 检查对象是否实现了指定协议类的方法</span></span></span><br></pre></td></tr></table></figure>
<p>  在NSObject的类中还定义了一个方法：<code>- (IMP)methodForSelector:(SEL)aSelector;</code>这个方法会返回指定方法实现的地址IMP<br>  – 当我们导入了objc/Runtime.h和objc/message.h两个头文件之后，我们查找到了Runtime的函数之后，代码打完，发现没有代码提示了，可以在 <code>Build settings</code> 中搜索 <code>objc_msg</code> 将 <code>Enable Strict Checking objc_msgSend Calls</code> 设为 <code>NO</code><br>  – 在引入元类之后，类对象和对象查找方法的机制就完全统一了：对象的实例方法调用时，通过对象的 isa 在类中获取方法的实现。类对象的类方法调用时，通过类的 isa 在元类中获取方法的实现。</p>
<p>  – isa_t结构体的具体实现<br>  – cache_t的具体实现：Cache的作用主要是为了优化方法调用的性能。当对象receiver调用方法message时，首先根据对象receiver的isa指针查找到它对应的类，然后在类的methodLists中搜索方法，如果没有找到，就使用super_class指针到父类中的methodLists查找，一旦找到就调用方法。如果没有找到，有可能消息转发，也可能忽略它。但这样查找方式效率太低，因为往往一个类大概只有20%的方法经常被调用，占总调用次数的80%。所以使用Cache来缓存经常调用的方法，当调用方法时，优先在Cache查找，如果没有找到，再到methodLists查找<br>  – class_data_bits_t的具体实现</p>
</li>
</ul>
<ul>
<li>入院考试<br>  – [self class] 与 [super class]<br>  – isKindOfClass 与 isMemberOfClass<br>  – Class与内存地址</li>
</ul>
<p>⚠️注：很有深度，应该是那种温故而知新的文章，后续还会再读！</p>
<h1 id="Day-27-处理手势冲突和错乱的一点经验"><a href="#Day-27-处理手势冲突和错乱的一点经验" class="headerlink" title="# Day 27 : 处理手势冲突和错乱的一点经验"></a># Day 27 : <a href="http://yulingtianxia.com/blog/2016/08/29/Some-Experience-of-Gesture/" target="_blank" rel="external">处理手势冲突和错乱的一点经验</a></h1><p>由 <a href="http://yulingtianxia.com/" target="_blank" rel="external">玉令天下的博客</a> 发布</p>
<p>对于复杂页面掺合多种手势的场景，采用“状态机”的方案来区分手势进行页面操作</p>
<p>– 对手势统一处理和分发：把各种手势全都添加到底层的全屏视图上，然后统一处理和分发结果。因为每种手势只有一个且都加在了底层视图，所以不会发生不同视图间的手势错乱。而不同种手势之间的冲突就需要在 UIGestureRecognizerDelegate 中根据业务逻辑来解决了。<br>– 计算响应手势的视图：可以通过 locationInView: 获取手势的坐标，但这里决不能简单地计算手势坐标到视图 center 的距离并选取最近的视图，这里需要检测手势坐标处于哪个视图的范围内。<br>– 处理 Pinch 手势：1、分辨率：当对含有矢量内容的视图进行缩放时会有模糊和锯齿出现，这时递归需要改变 UIView 的 contentScaleFactor 和 CALayer 的 contentsScale 属性。2、坐标：视图的 transform 属性是不会修改视图的 bounds 的，但 frame 作为计算属性还是会变化的。也就是说无论视图放大了多少倍，视图内部的子视图的 frame 不会变。<br>– 处理 Rotation 手势：一直用『视图区域』而不直接用 frame 来描述手势判断依据，是因为当视图旋转（90°倍数除外）之后 frame 并不等于『视图区域』（文中有提供方法用于判断某个点是否在『视图区域』内）<br>– 如果所有手势都交给一个底层视图统一处理的话，上层那一坨视图是不需要响应触摸事件的，有些甚至可以用 Layer 来做。</p>
<p>其中两条参考链接值得参考：<br><a href="http://www.informit.com/articles/article.aspx?p=1951182" target="_blank" rel="external">Taking Charge of UIView Transforms in iOS Programming</a><br><a href="https://stackoverflow.com/questions/5927223/scaling-uitextview-using-contentscalefactor-property" target="_blank" rel="external">Scaling UITextView using contentScaleFactor property</a></p>
<h1 id="Day-26-详解CALayer-和-UIView的区别和联系"><a href="#Day-26-详解CALayer-和-UIView的区别和联系" class="headerlink" title="# Day 26 : 详解CALayer 和 UIView的区别和联系"></a># Day 26 : <a href="http://www.jianshu.com/p/079e5cf0f014?utm_campaign=maleskine&amp;utm_content=note&amp;utm_medium=writer_share&amp;utm_source=weibo" target="_blank" rel="external">详解CALayer 和 UIView的区别和联系</a></h1><p>由 <a href="http://www.jianshu.com/u/8d704c0faf00" target="_blank" rel="external">kissGod</a> 发布</p>
<p>– 每个 UIView 内部都有一个 CALayer 在背后提供内容的绘制和显示，并且 UIView 的尺寸样式都由内部的 Layer 所提供。两者都有树状层级结构，layer 内部有 SubLayers，View 内部有 SubViews.但是 Layer 比 View 多了个AnchorPoint<br>– 在 View显示的时候，UIView 做为 Layer 的 CALayerDelegate,View 的显示内容由内部的 CALayer 的 display<br>– CALayer 是默认修改属性支持隐式动画的，在给 UIView 的 Layer 做动画的时候，View 作为 Layer 的代理，Layer 通过 actionForLayer:forKey:向 View请求相应的 action(动画行为)<br>– layer 内部维护着三分 layer tree,分别是 presentLayer Tree(动画树),modeLayer Tree(模型树), Render Tree (渲染树),在做 iOS动画的时候，我们修改动画的属性，在动画的其实是 Layer 的 presentLayer的属性值,而最终展示在界面上的其实是提供 View的modelLayer<br>– 两者最明显的区别是 View可以接受并处理事件，而 Layer 不可以</p>
<h1 id="Day-25-iOS-常见知识点（三）：Lock"><a href="#Day-25-iOS-常见知识点（三）：Lock" class="headerlink" title="# Day 25 : iOS 常见知识点（三）：Lock"></a># Day 25 : <a href="http://www.jianshu.com/p/ddbe44064ca4" target="_blank" rel="external">iOS 常见知识点（三）：Lock</a></h1><p>由 <a href="http://www.jianshu.com/u/263107bb1199" target="_blank" rel="external">AidenRao</a> 发布</p>
<p>iOS 中的八大锁<br>– NSLock：遵循 NSLocking 协议lock 方法是加锁，unlock 是解锁，tryLock 是尝试加锁，如果失败的话返回 NO，lockBeforeDate: 是在指定Date之前尝试加锁，如果在指定时间之前都不能加锁，则返回NO<br>互斥锁会使得线程阻塞，阻塞的过程又分两个阶段，第一阶段是会先空转，可以理解成跑一个 while 循环，不断地去申请加锁，在空转一定时间之后，线程会进入 waiting 状态，此时线程就不占用CPU资源了，等锁可用的时候，这个线程会立即被唤醒。<br>– NSConditionLock：遵循 NSLocking 协议，方法都类似，只是多了一个 condition 属性，以及每个操作都多了一个关于 condition 属性的方法。NSConditionLock 还可以实现任务之间的依赖<br>– NSRecursiveLock：递归锁，他和 NSLock 的区别在于，NSRecursiveLock 可以在一个线程中重复加锁（反正单线程内任务是按顺序执行的，不会出现资源竞争问题），NSRecursiveLock 会记录上锁和解锁的次数，当二者平衡的时候，才会释放锁，其它线程才可以上锁成功<br>– NSCondition：NSCondition 并不会像上文的那些锁一样，先轮询，而是直接进入 waiting 状态，当其它线程中的该锁执行 signal 或者 broadcast 方法时，线程被唤醒，继续运行之后的方法<br>– @synchronized：<br>– dispatch_semaphore：GCD 用来同步的一种方式<br>– OSSpinLock：OSSpinLock 会一直轮询，等待时会消耗大量 CPU 资源，不适用于较长时间的任务<br>– pthread_mutex：C 语言下多线程加互斥锁的方式</p>
<p>这里介绍了iOS中的几种锁，简单介绍了其中的用法，但仅凭阅读一篇博客并不能熟知iOS中锁的应用，具体的原理及使用还是要代码中实践才是。</p>
<h1 id="Day-24-iOS书写高质量代码之耦合的处理"><a href="#Day-24-iOS书写高质量代码之耦合的处理" class="headerlink" title="# Day 24 : iOS书写高质量代码之耦合的处理"></a># Day 24 : <a href="https://mp.weixin.qq.com/s?__biz=MzI5MjEzNzA1MA==&amp;mid=2650264313&amp;idx=1&amp;sn=9dbb05dec78c0265efee16299ea95d22" target="_blank" rel="external">iOS书写高质量代码之耦合的处理</a></h1><p>由 <a href="">MrPeak杂货铺</a> 发布</p>
<p>写高质量代码之耦合的处理的几种方式：<br>– .m引用：直接在 .m 文件创建对象调用方法<br>– .h Property：.h 文件中声明引用，依赖关系清晰<br>– .h ReadOnly Property：重写 setter 方法，对代码有更大的掌控能力，且避免轻易修改引用属性<br>– init 注入：对外就只提供一次机会（初始化init）来设置<br>– parameter 注入：将依赖类作为参数传入函数，耦合只发生在函数内部，一旦函数调用结束，就结束了依赖关系<br>– 单例引用：函数调用中使用单例，缺点也十分明显，应当慎用单例<br>– 继承：通过继承调用父类的方法，但确认父子关系也是麻烦的存在<br>– runtime依赖：耦合度非常之低，甚至可以说感觉不到，但是当依赖类的方法名发生改变时编译并不会提醒<br>– protocol依赖：好处在于他只规定了方法的声明，并不限定具体是那个类来实现它，给后期的维护留下更大的空间和可能性</p>
<p>以上方法的优点和缺点都很明显，怎么使用还要靠业务和coder自己决定。</p>
<h1 id="Day-23-iOS关于时间的处理"><a href="#Day-23-iOS关于时间的处理" class="headerlink" title="# Day 23 : iOS关于时间的处理"></a># Day 23 : <a href="http://mp.weixin.qq.com/s?__biz=MzI5MjEzNzA1MA==&amp;mid=2650264295&amp;idx=1&amp;sn=cdbe94a73be261aebf2afaba24320ef7&amp;scene=19#wechat_redirect" target="_blank" rel="external">iOS关于时间的处理</a></h1><p>由 <a href="">MrPeak杂货铺</a> 发布</p>
<p>– GMT：以格林尼治的时间作为公共时间，也就是我们所说的GMT时间（Greenwich Mean Time）。<br>– UTC：原子钟所反映的时间，也就是我们现在所使用的UTC（Coordinated Universal Time ）标准时间。<br>– NSDate：描述的是时间线上的一个绝对的值，和时区和文化无关，它参考的值是：以UTC为标准的，2001年一月一日00：00：00这一刻的时间绝对值。受手机系统时间控制的。也就是说，当你修改了手机上的时间显示，NSDate获取当前时间的输出也会随之改变。<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NSDate* <span class="keyword">date</span> = [NSDate <span class="keyword">date</span>];</span><br><span class="line">NSLog(@<span class="string">"current date: %@"</span>, <span class="keyword">date</span>); <span class="comment">// 绝对的UTC时间</span></span><br><span class="line">NSLog(@<span class="string">"current date interval: %f"</span>, [<span class="keyword">date</span> timeIntervalSinceReferenceDate]); <span class="comment">// 返回的是距离参考时间的偏移量</span></span><br><span class="line">NSLog(@<span class="string">"timeIntervalSince1970: %f"</span>, [<span class="keyword">date</span> timeIntervalSince1970]); <span class="comment">// 返回Unix time</span></span><br></pre></td></tr></table></figure></p>
<p>– CFAbsoluteTimeGetCurrent()：参考点是：以GMT为标准的，2001年一月一日00：00：00这一刻的时间绝对值。会跟着当前设备的系统时间一起变化，也可能会被用户修改。<br>– gettimeofday：获得的值是Unix time。Unix time是以UTC 1970年1月1号 00：00：00为基准时间，当前时间距离基准点偏移的秒数。受当前设备的系统时间影响。只不过是参考的时间基准点不一样而已。我们和服务器通讯的时候一般使用Unix time。<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span></span> now;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timezone</span></span> tz;</span><br><span class="line">gettimeofday(&amp;now, &amp;tz);</span><br><span class="line">NSLog(@<span class="string">"gettimeofday: %ld"</span>, now.tv_sec); <span class="comment">// Unix time</span></span><br></pre></td></tr></table></figure></p>
<p>在Mac的终端可以通过 <code>date -r 1481266031</code> 命令转换成可阅读的时间。<br>– mach_absolute_time()：返回的是CPU已经运行的tick（CPU的时钟周期数）的数量。将这个tick数经过一定的转换就可以变成秒数，或者纳秒数，这样就和时间直接关联了。不会受系统时间影响，只受设备重启和休眠行为影响。<br>– CACurrentMediaTime()：就是将上面mach_absolute_time()的CPU tick数转化成秒数的结果。不会受系统时间影响，只受设备重启和休眠行为影响。<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> mediaTime = <span class="built_in">CACurrentMediaTime</span>();</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"CACurrentMediaTime: %f"</span>, mediaTime); <span class="comment">// 开机后设备一共运行了(设备休眠不统计在内)多少秒</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">NSTimeInterval</span> systemUptime = [[<span class="built_in">NSProcessInfo</span> processInfo] systemUptime];</span><br><span class="line"><span class="built_in">NSLog</span>(<span class="string">@"systemUptime: %f"</span>, systemUptime); <span class="comment">// 相同效果：开机后设备一共运行了(设备休眠不统计在内)多少秒</span></span><br></pre></td></tr></table></figure></p>
<p>– sysctl：返回的值是上次设备重启的Unix time。会受系统时间影响，用户如果修改时间，值也会随着变化。<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sysctl.h&gt;</span></span></span><br><span class="line">- (<span class="keyword">long</span>)bootTime</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIB_SIZE 2</span></span><br><span class="line">    <span class="keyword">int</span> mib[MIB_SIZE];</span><br><span class="line">    size_t <span class="built_in">size</span>;    </span><br><span class="line">    <span class="keyword">struct</span> timeval  boottime;</span><br><span class="line"></span><br><span class="line">    mib[<span class="number">0</span>] = CTL_KERN;</span><br><span class="line">    mib[<span class="number">1</span>] = KERN_BOOTTIME;</span><br><span class="line">    <span class="built_in">size</span> = <span class="keyword">sizeof</span>(boottime);    </span><br><span class="line">    <span class="built_in">if</span> (sysctl(mib, MIB_SIZE, &amp;boottime, &amp;<span class="built_in">size</span>, NULL, <span class="number">0</span>) != <span class="number">-1</span>)</span><br><span class="line">    &#123;        </span><br><span class="line">        <span class="built_in">return</span> boottime.tv_sec;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="built_in">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>– 场景一，时间测量：CACurrentMediaTime与NSDate代码本身的损耗差异在几微秒，而我们做UI性能优化的维度在毫秒级别，几个微秒的差异完全不会影响我们最后的判断结果。所以使用NSDate做benchmark完全是可行的，以下是我常用的两个宏：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TICK   NSDate *startTime = [NSDate date]</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TOCK   NSLog(@<span class="string">"Time Cost: %f"</span>, -[startTime timeIntervalSinceNow])</span></span><br></pre></td></tr></table></figure></p>
<p>– 场景二：客户端和服务器之间的时间同步：（给出了一点技巧，参考原文）</p>
<h1 id="Day-22-正确使用-synchronized"><a href="#Day-22-正确使用-synchronized" class="headerlink" title="# Day 22 : 正确使用@synchronized()"></a># Day 22 : <a href="http://mp.weixin.qq.com/s?__biz=MzI5MjEzNzA1MA==&amp;mid=2650264278&amp;idx=1&amp;sn=9353080a2fa5bb6f599faf00882e8176&amp;scene=19#wechat_redirect" target="_blank" rel="external">正确使用@synchronized()</a></h1><p>由 <a href="">MrPeak杂货铺</a> 发布</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@synchronized(obj)</span> &#123;</span><br><span class="line">  <span class="comment">//code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>@synchronized原理<br>  – synchronized是使用的递归mutex来做同步。<br>  – @synchronized(nil)不起任何作用<br>  – synchronized中传入的object的内存地址，被用作key，通过hash map对应的一个系统维护的递归锁。</li>
<li>@synchronized使用<br>  – 慎用@synchronized(self)，正确的做法是传入一个类内部维护的NSObject对象，而且这个对象是对外不可见的。<br>  – 精准的粒度控制，不同的 @synchronized (token) 使用不同的 token<br>  – 注意内部的函数调用，避免 {} 内部有其他隐蔽的函数调用拖慢锁的性能</li>
</ul>
<h1 id="Day-21-iOS多线程到底不安全在哪里？"><a href="#Day-21-iOS多线程到底不安全在哪里？" class="headerlink" title="# Day 21 : iOS多线程到底不安全在哪里？"></a># Day 21 : <a href="http://mp.weixin.qq.com/s?__biz=MzI5MjEzNzA1MA==&amp;mid=2650264274&amp;idx=1&amp;sn=2592a071424c4b217f33385115613988&amp;scene=19#wechat_redirect" target="_blank" rel="external">iOS多线程到底不安全在哪里？</a></h1><p>由 <a href="">MrPeak杂货铺</a> 发布</p>
<p>– <code>self.userName = @&quot;peak&quot;;</code> 是在对指针本身进行赋值，而 <code>[self.userName rangeOfString:@&quot;peak&quot;];</code> 是在访问指针指向的字符串所在的内存区域，这二者并不一样。<br>– 由于BOOL大小只有1个字节，64位系统的地址总线对于读写指令可以支持8个字节的长度，所以对于BOOL的读和写操作我们可以认为是原子的，所以当我们声明BOOL类型的property的时候，从原子性的角度看，使用atomic和nonatomic并没有实际上的区别（当然如果重载了getter方法就另当别论了）。<br>– atomic的作用只是给getter和setter加了个锁，atomic只能保证代码进入getter或者setter函数内部时是安全的，一旦出了getter和setter，多线程安全只能靠程序员自己保障了。<br>– iOS给代码加锁的方式有很多种，常用的有：<code>@synchronized(token)</code>，<code>NSLock</code>，<code>dispatch_semaphore_t</code>，<code>OSSpinLock</code>，这几种锁都可以带来原子性，性能的损耗依次更小。<br>– <code>_intA ++;</code>（非原子性），<code>OSAtomicIncrement32(&amp;(_intA));</code>（原子性），Atomic Operation只能应用于32位或者64位的数据类型，在多线程使用NSString或者NSArray这类对象的场景，还是得使用锁。</p>
<h1 id="Day-20-与调试器共舞-LLDB-的华尔兹"><a href="#Day-20-与调试器共舞-LLDB-的华尔兹" class="headerlink" title="# Day 20 : 与调试器共舞 - LLDB 的华尔兹"></a># Day 20 : <a href="https://objccn.io/issue-19-2/" target="_blank" rel="external">与调试器共舞 - LLDB 的华尔兹</a></h1><p>由 <a href="https://objccn.io/" target="_blank" rel="external">ObjC 中国</a> 发布</p>
<p>这是一篇有料有趣的文章，介绍了很多 LLDB 的命令和用法<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">help	<span class="comment">// 列举出所有的命令</span></span><br><span class="line">print	<span class="comment">// prin，pri，p，但不能使用 pr，因为 LLDB 不能消除和 process 的歧义</span></span><br><span class="line">expression <span class="comment">// 改变一个值</span></span><br><span class="line">po	<span class="comment">// e -0 --，打印对象</span></span><br><span class="line">p/x	<span class="comment">// 打印十六进制变量</span></span><br><span class="line">p/t	<span class="comment">// 打印二进制变量（two）</span></span><br><span class="line">p/c 	<span class="comment">// 打印字符</span></span><br><span class="line">p/s 	<span class="comment">// 打印以空终止的字符串 (译者注：以 '\0' 结尾的字符串)</span></span><br><span class="line">c	<span class="comment">// continue</span></span><br><span class="line">n	<span class="comment">// next，thread step-over 如果这行代码是一个函数调用，那么就不会跳进这个函数，而是会执行这个函数，然后继续。</span></span><br><span class="line">s 	<span class="comment">// step，thread step in跳进一个函数调用来调试或者检查程序的执行情况。注意，当前行不是函数调用时，next 和 step 效果是一样的。</span></span><br><span class="line">breakpoint list	 <span class="comment">// br li，看到所有的断点</span></span><br><span class="line">breakpoint <span class="keyword">set</span> -f <span class="comment">main.m -l 16</span>	//<span class="comment"> b main.m:16</span>，创建断点</span><br><span class="line">b <span class="comment">isEven</span> //<span class="comment"> br s -F isEven</span>，在一个符号<span class="comment"> (C</span> 语言函数<span class="comment">)</span> 上创建断点，而完全不用指定哪一行</span><br><span class="line"><span class="comment">// 创建断点</span></span><br><span class="line">breakpoint <span class="comment">set -F</span> <span class="comment">"-[NSArray objectAtIndex:]"</span></span><br><span class="line">b <span class="comment">-[NSArray objectAtIndex:]</span></span><br><span class="line">breakpoint <span class="comment">set -F</span> <span class="comment">"+[NSSet setWithObject:]"</span></span><br><span class="line">b <span class="comment">+[NSSet setWithObject:]</span></span><br><span class="line">po <span class="comment">[[[UIApplication sharedApplication] keyWindow] recursiveDescription]</span> // 可以看到整个层次</span><br></pre></td></tr></table></figure></p>
<p>在 Xcode 的UI上创建符号断点：<br>你可以点击断点栏左侧的 + 按钮，选择 “Add Symbolic Breakpoint”，这时会出现一个弹出框，你可以在里面添加例如 -[NSArray objectAtIndex:] 这样的符号断点。这样每次调用这个函数的时候，程序都会停止，不管是你调用还是苹果调用。</p>
<p>断点行为 (Action)：<br>右击任意断点选择“Edit Breakpoint”<br>– 添加 action，可以添加 Debugger Command，Shell Command，Log Message，Sound 等行为<br>– 选项： “Automatically continue after evaluation actions.” 选中它，调试器会运行你所有的命令，然后继续运行</p>
<p>调试器可用命令总览参考：<a href="http://lldb.llvm.org/lldb-gdb.html" target="_blank" rel="external">GDB to LLDB</a></p>
<h1 id="Day-19-IP，TCP-和-HTTP"><a href="#Day-19-IP，TCP-和-HTTP" class="headerlink" title="# Day 19 : IP，TCP 和 HTTP"></a># Day 19 : <a href="https://objccn.io/issue-10-6/" target="_blank" rel="external">IP，TCP 和 HTTP</a></h1><p>由 <a href="https://objccn.io/" target="_blank" rel="external">ObjC 中国</a> 发布</p>
<p>又温习一遍网络连接的知识。。。</p>
<h1 id="Day-18-基础集合类"><a href="#Day-18-基础集合类" class="headerlink" title="# Day 18 : 基础集合类"></a># Day 18 : <a href="https://objccn.io/issue-7-1/" target="_blank" rel="external">基础集合类</a></h1><p>由 <a href="https://objccn.io/" target="_blank" rel="external">ObjC 中国</a> 发布</p>
<p>这篇文章可真的是基础了，可能是今天时间太紧张没找到一篇比较有深度的文章，不过这篇文章从基础集合类（NSArray, NSSet, NSOrderedSet 和 NSDictionary）讲起，分别介绍了它们的方法，分析了性能，当是基础知识的一次复习吧。<br>文中总结列出了枚举 NSArray 和 NSDictionary 的几种方法，并分析了各自的性能，值得一看。因为都是一些基础集合类，就不做什么笔记了，各个类的方法到 Xcode 里都能轻易找着。</p>
<h1 id="Day-17-Build-过程"><a href="#Day-17-Build-过程" class="headerlink" title="# Day 17 : Build 过程"></a># Day 17 : <a href="https://objccn.io/issue-6-1/" target="_blank" rel="external">Build 过程</a></h1><p>由 <a href="https://objccn.io/" target="_blank" rel="external">ObjC 中国</a> 发布</p>
<ul>
<li>解密 Build 日志</li>
<li><p>Build过程的控制<br>  – Build Phases：代表将代码转变为可执行文件的最高级别规则。<br>  – 定制Build Phases：可以在 build phases 中添加运行自定义脚本，就像CocoaPods使用的一样，来做额外的工作。<br>  – Build Rules：指定了不同的文件类型该如何编译。<br>  – Build Settings：可以配置每个任务（之前在 build log 输出中看到的任务）的详细内容。例如可以添加一个 “Run Script”：如果一个源文件超过指定行数，就发出警告。如下代码所示，设置的行数为 200：</p>
  <figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find <span class="string">"<span class="variable">$&#123;SRCROOT&#125;</span>"</span> \( -name <span class="string">"*.h"</span> -or -name <span class="string">"*.m"</span> \) -print0 | xargs -<span class="number">0</span> wc -l | awk '<span class="variable">$1</span> &gt; <span class="number">200</span> &amp;&amp; <span class="variable">$2</span> != <span class="string">"total"</span> &#123; <span class="literal">print</span> <span class="variable">$2</span> <span class="string">":1: warning: file more than 200 lines"</span> &#125;'</span><br></pre></td></tr></table></figure>
</li>
<li><p>工程文件（.pbxproj）</p>
</li>
</ul>
<h1 id="Day-16-自定义控件"><a href="#Day-16-自定义控件" class="headerlink" title="# Day 16 : 自定义控件"></a># Day 16 : <a href="https://objccn.io/issue-3-4/" target="_blank" rel="external">自定义控件</a></h1><p>由 <a href="https://objccn.io/" target="_blank" rel="external">ObjC 中国</a> 发布</p>
<p>该篇文章比较基础，介绍了自定义控件用到的 UIView 基类、渲染、交互、本地化及测试：</p>
<ul>
<li>视图层次概览<br>  – reponders (响应者)：UIView 的父类，能够处理触摸、手势、远程控制等事件。<br>  – views (视图)：视图的区域是由它的 frame 定义的。实际上 frame 是一个派生属性，是由 center 和 bounds 合成而来。<br>  – controls (控件)：建立在视图上，增加了更多的交互支持。最重要的是，它增加了 target / action 模式。</li>
<li>渲染<br>  – 尽量避免 drawRect:，使用现有的视图构建自定义视图。如果重写 drawRect:，确保检查内容模式。默认的模式是将内容缩放以填充视图的范围，这在当视图的 frame 改变时并不会重新绘制。<br>  – 处理图片时，你也可以让 GPU 为你工作来代替使用 Core Graphics。使用 Core Image，你不必用 CPU 做任何的工作就可以在图片上建立复杂的效果。</li>
<li>自定义交互<br>  – 使用 Target-Action<br>  – 使用代理<br>  – 使用 Block<br>  – 使用 KVO<br>  – 使用通知</li>
<li>辅助功能 (Accessibility)<br>  – 本地化：使用 NSLocalizedString 本地化字符串。<br>  – 测试：可以使用 UIAutomation 或者其它基于它的工具。</li>
</ul>
<h1 id="Day-15-底层并发-API"><a href="#Day-15-底层并发-API" class="headerlink" title="# Day 15 : 底层并发 API"></a># Day 15 : <a href="https://objccn.io/issue-2-3/" target="_blank" rel="external">底层并发 API</a></h1><p>由 <a href="https://objccn.io/" target="_blank" rel="external">ObjC 中国</a> 发布</p>
<p>该篇文章并非是专门介绍 GCD(Grand Central Dispatch) 使用的，但从分析及解决并发问题的角度出发介绍了很多 GCD 的用法</p>
<ul>
<li>从前…：<code>dispatch_once</code></li>
<li>延后执行：<code>dispatch_after</code><br>  – 队列<br>  – 目标队列：为一个类创建它自己的队列而不是使用全局的队列，这种方式可以设置队列的名字，在 Xcode 的 Debug Navigator 中可以看到所有的队列名字，(lldb) thread list 命令会在控制台打印出所有队列的名字。<br>  – 优先级</li>
<li>隔离<br>  – 资源保护<br>  – 单一资源的多读单写：<code>dispatch_barrier_async</code><br>  – 锁竞争<br>  – 全都使用异步分发：<code>dispatch_async()</code><br>  – 如何写出好的异步 API</li>
<li>迭代执行：<code>dispatch_apply</code><br>  – 组：<code>dispatch_group_t</code><br>  – 对现有API使用 dispatch_group_t</li>
<li>事件源：<code>dispatch_source_t</code><br>  – 监视进程<br>  – 监视文件<br>  – 定时器<br>  – 取消</li>
<li>输入输出<br>  – GCD 和缓冲区：<code>dispatch_data_t</code><br>  – 读和写：<code>dispatch_io_create_with_path</code>、<code>dispatch_io_read</code>、<code>dispatch_io_write</code> 和 <code>dispatch_io_close</code></li>
<li>基准测试：<code>uint64_t dispatch_benchmark(size_t count, void (^block)(void));</code>能够测量给定的代码执行的平均的纳秒数</li>
<li>原子操作<br>  – 计数器<br>  – 比较和交换<br>  – 原子队列<br>  – 自旋锁</li>
</ul>
<h1 id="Day-14-常见的后台实践"><a href="#Day-14-常见的后台实践" class="headerlink" title="# Day 14 : 常见的后台实践"></a># Day 14 : <a href="https://objccn.io/issue-2-2/" target="_blank" rel="external">常见的后台实践</a></h1><p>由 <a href="https://objccn.io/" target="_blank" rel="external">ObjC 中国</a> 发布</p>
<p>作者从以下方面介绍了将耗时操作放进后台执行的策略：<br>– 后台的 Core Data<br>– 更新 Main Context<br>– 后台 UI 代码<br>– 后台绘制：如果确定 drawRect: 是应用的性能瓶颈，把 drawRect:中的代码放到后台操作中去。然后将原本打算绘制的视图用一个 image view 来替换，等到操作执行完后再去更新。在绘制的方法中，使用 UIGraphicsBeginImageContextWithOptions 来取代 UIGraphicsGetCurrentContext ：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(size, <span class="literal">NO</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// drawing code here</span></span><br><span class="line"><span class="built_in">UIImage</span> *i = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line"><span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line"><span class="keyword">return</span> i;</span><br></pre></td></tr></table></figure></p>
<p>通过在第三个参数中传入 0 ，设备的主屏幕的 scale 将被自动传入，这将使图片在普通设备和 retina 屏幕上都有良好的表现。</p>
<p>– 异步网络请求处理：像 AFNetworking 这样的框架：建立一个独立的线程，为建立的线程设置自己的 run loop，然后在其中调度 URL 连接。<br>– 进阶：后台文件 I/O：对于不方便一次性读入内存的大文件可以使用异步处理文件的 NSInputStream<br>。。。。。。</p>
<h1 id="Day-13-并发编程：API-及挑战"><a href="#Day-13-并发编程：API-及挑战" class="headerlink" title="# Day 13 : 并发编程：API 及挑战"></a># Day 13 : <a href="https://objccn.io/issue-2-1/" target="_blank" rel="external">并发编程：API 及挑战</a></h1><p>由 <a href="https://objccn.io/" target="_blank" rel="external">ObjC 中国</a> 发布</p>
<p>##1、OS X 和 iOS 中的并发编程<br>– 线程<br>可以使用 Instruments 中的 CPU strategy view 来得知代码是如何在多核 CPU 中调度执行的。<br>– Grand Central Dispatch<br>GCD 公开有 5 个不同的队列：运行在主线程中的 main queue，3 个不同优先级的后台队列，以及一个优先级更低的后台队列（用于 I/O）。 另外，开发者可以创建自定义队列：串行或者并行队列。自定义队列非常强大，在自定义队列中被调度的所有 block 最终都将被放入到系统的全局队列中和线程池中。<br>强烈建议在绝大多数情况下使用默认的优先级队列，避免在不同优先级的队列中调度访问共享资源的任务而产生不可预期的行为，比如低优先级的任务阻塞了高优先级任务而造成程序的完全挂起。<br>– Operation Queues<br>NSOperationQueue 有两种不同类型的队列：主队列和自定义队列。主队列运行在主线程之上，而自定义队列在后台执行。你可以通过重写 main 或者 start 方法来定义自己的 operations。<br>你可以通过 maxConcurrentOperationCount 属性来控制一个特定队列中可以有多少个操作参与并发执行，还可以在 operation 之间指定依赖关系。<br>– Run Loops<br>主线程一般来说都已经配置好了 main run loop。然而其他线程默认情况下都没有设置 run loop。你也可以自行为其他线程设置 run loop ，但是一般来说我们很少需要这么做。大多数时间使用 main run loop 会容易得多。</p>
<p>##2、并发编程中面临的挑战<br>– 资源共享<br>– 互斥锁<br>– 死锁<br>– 资源饥饿（Starvation）<br>– 优先级反转</p>
<p>##3、总结<br>我们建议采纳的安全模式是这样的：从主线程中提取出要使用到的数据，并利用一个操作队列在后台处理相关的数据，最后回到主队列中来发送你在后台队列中得到的结果。使用这种方式，你不需要自己做任何锁操作，这也就大大减少了犯错误的几率。</p>
<h1 id="Day-12-理解-Scroll-Views"><a href="#Day-12-理解-Scroll-Views" class="headerlink" title="# Day 12 : 理解 Scroll Views"></a># Day 12 : <a href="https://objccn.io/issue-3-2/" target="_blank" rel="external">理解 Scroll Views</a></h1><p>由 <a href="https://objccn.io/" target="_blank" rel="external">ObjC 中国</a> 发布</p>
<p>该篇文章比较简洁，从 UIView 的光栅化和组合说起，简单明了的介绍了 Scroll View 的实现思路。<br>并介绍了 Scroll View 的：<br>– Content Offset：相当于更改 Superview.bounds.origin<br>– Content Size：可滚动区域<br>– Content Insets：可以改变 content offset 的最大和最小值，这样便可以滚动出可滚动区域</p>
<p>或许可以应用在有键盘弹出的页面，比如登录页面，弹出键盘输入用户名密码时会遮挡屏幕下半部的视图，可以采用 Scroll View 的滚动特性来解决这一尴尬，恰巧今天碰见 Medium 的登录页面貌似就是这么设计的。</p>
<h1 id="Day-11-绘制像素到屏幕上"><a href="#Day-11-绘制像素到屏幕上" class="headerlink" title="# Day 11 : 绘制像素到屏幕上"></a># Day 11 : <a href="https://objccn.io/issue-3-1/" target="_blank" rel="external">绘制像素到屏幕上</a></h1><p>由 <a href="https://objccn.io/" target="_blank" rel="external">ObjC 中国</a> 发布</p>
<p>文章知识比较碎却又是全集中在屏幕绘制这一块，许多知识点都基于原理特别受用。以下是文章中提及的知识点（目录）：<br>– 图形堆栈<br>– 软件组成：Display &lt;-&gt; GPU &lt;-&gt; GPU Driver &lt;-&gt; OpenGL(Open Graphics Library) &lt;-&gt; Core Animation/Core Graphics/Core Image &lt;-&gt; app<br>– 硬件参与者<br>– 合成：对于屏幕上的每一个像素，GPU 需要算出怎么混合这些纹理来得到像素 RGB 的值，并最终显示在屏幕上。所以减少视图层级可以有效提高性能，因为 GPU 需要将重叠的视图计算合成在一起（将纹理中的一个像素合成到另一个纹理的像素上）。<br>– 不透明 VS 透明：当源纹理是完全不透明的时候，目标像素就等于源纹理。这可以省下 GPU 很大的工作量，这样只需简单的拷贝源纹理而不需要合成所有的像素值。CALayer 有一个叫做 opaque 的属性，如果这个属性为 YES，GPU 将不会做任何合成，而是简单从这个层拷贝，不需要考虑它下方的任何东西(因为都被它遮挡住了)，这节省了 GPU 相当大的工作量。Instruments 中 color blended layers 选项中所涉及的，允许你看到哪一个 layers(纹理) 被标注为透明的。<br>– 像素对齐 VS 不重合在一起：「缩放」和「纹理的起点不在一个像素的边界上」会导致一个 layer 上所有的像素和屏幕上的像素不对齐，GPU 需要再做额外的计算。它需要将源纹理上多个像素混合起来，生成一个用来合成的值。<br>– Masks(蒙板)：mask 是一个拥有 alpha 值的位图，当像素要和它下面包含的像素合并之前都会把 mask 应用到图层的像素上去。当你要设置一个图层的圆角半径时，你可以有效的在图层上面设置一个 mask。<br>– 离屏渲染(Offscreen Rendering)：为 layer 使用蒙板、设置圆角半径、产生阴影会造成屏幕外渲染。Instrument 的 Core Animation 工具有一个叫做 Color Offscreen-Rendered Yellow 的选项，它会将已经被渲染到屏幕外缓冲区的区域标注为黄色。同时记得检查 Color Hits Green and Misses Red 选项。绿色代表无论何时一个屏幕外缓冲区被复用，而红色代表当缓冲区被重新创建。<br>– 更多的关于合成<br>– OS X<br>– Core Animation OpenGL ES<br>– CPU 限制 VS GPU 限制：你可以使用 OpenGL ES Driver instrument，点击上面那个小的 i 按钮，配置一下，同时注意勾选 Device Utilization %。现在，当你运行你的 app 时，你可以看到你 GPU 的负荷。<br>– Core Graphics / Quartz 2D<br>– CGLayer<br>– 像素<br>– 默认的像素布局<br>– 深奥的布局<br>– 二维数据<br>– YCbCr<br>– 图片格式<br>– JPEG<br>– PNG<br>– 挑选一个格式<br>– UIKit 和 Pixels<br>– With –drawRect:<br>– 不使用 -drawRect:<br>– 实现-drawRect: 还是不实现 -drawRect:<br>– 单一颜色<br>– 可变尺寸的图像<br>– 并发绘图<br>– CALayer<br>– 自定义绘制的图层<br>– 形状和文本图层<br>– 异步绘图</p>
<h1 id="Day-10-谈谈-iOS-中图片的解压缩"><a href="#Day-10-谈谈-iOS-中图片的解压缩" class="headerlink" title="# Day 10 : 谈谈 iOS 中图片的解压缩"></a># Day 10 : <a href="http://blog.leichunfeng.com/blog/2017/02/20/talking-about-the-decompression-of-the-image-in-ios/" target="_blank" rel="external">谈谈 iOS 中图片的解压缩</a></h1><p>由 <a href="http://blog.leichunfeng.com/" target="_blank" rel="external">雷纯锋的技术博客</a> 发布</p>
<p>##1、图片加载<br>图片加载的工作流参考 <a href="https://github.com/path/FastImageCache#the-problem" target="_blank" rel="external">FastImageCache 在 GitHub</a> 上的 README.md。<br>图片在渲染到 UIImageView 的图层之前需要将其解压缩，而对图片解压缩默认是在主线程完成的，并且是一个非常耗时的操作，在对性能要求比较高时可以在图片渲染到屏幕之前在子线程提前对图片进行强制解压缩，强制解压缩的原理就是对图片进行重新绘制，得到一张新的解压缩后的位图。其中，用到的最核心的函数是 CGBitmapContextCreate ：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CG_EXTERN CGContextRef __<span class="function">nullable <span class="title">CGBitmapContextCreate</span><span class="params">(<span class="keyword">void</span> * __nullable data,</span><br><span class="line">    <span class="keyword">size_t</span> width, <span class="keyword">size_t</span> height, <span class="keyword">size_t</span> bitsPerComponent, <span class="keyword">size_t</span> bytesPerRow,</span><br><span class="line">    CGColorSpaceRef cg_nullable space, <span class="keyword">uint32_t</span> bitmapInfo)</span></span><br><span class="line">    <span class="title">CG_AVAILABLE_STARTING</span><span class="params">(__MAC_10_0, __IPHONE_2_0)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>其中：<br>– data：如果不为 NULL ，那么它应该指向一块大小至少为 bytesPerRow <em> height 字节的内存；如果 为 NULL ，那么系统就会为我们自动分配和释放所需的内存，所以一般指定 NULL 即可；<br>– width 和 height：位图的宽度和高度，分别赋值为图片的像素宽度和像素高度即可；<br>– bitsPerComponent：像素的每个颜色分量使用的 bit 数，在 RGB 颜色空间下指定 8 即可；<br>– bytesPerRow：位图的每一行使用的字节数，大小至少为 width </em> bytes per pixel 字节。有意思的是，当我们指定 0 时，系统不仅会为我们自动计算，而且还会进行 cache line alignment 的优化；<br>– space：就是我们前面提到的颜色空间，一般使用 RGB 即可；<br>– bitmapInfo：就是我们前面提到的位图的布局信息。<br>涉及到的概念：<br>Pixel Format（像素格式）、Color and Color Spaces（颜色空间）、Color Spaces and Bitmap Layout（位图布局）</p>
<p>##2、开源库<br>贴出了 YYKit 中存在于 YYImageCoder 类中用于解压缩图片的核心代码的函数 YYCGImageCreateDecodedCopy。讲解代码步骤并对 YYKit，SDWebImage，FLAnimatedImage 做了性能比对。</p>
<h1 id="Day-9-Objective-C-Fast-Enumeration-的实现原理"><a href="#Day-9-Objective-C-Fast-Enumeration-的实现原理" class="headerlink" title="# Day 9 : Objective-C Fast Enumeration 的实现原理"></a># Day 9 : <a href="http://blog.leichunfeng.com/blog/2016/06/20/objective-c-fast-enumeration-implementation-principle/" target="_blank" rel="external">Objective-C Fast Enumeration 的实现原理</a></h1><p>由 <a href="http://blog.leichunfeng.com/" target="_blank" rel="external">雷纯锋的技术博客</a> 发布</p>
<p>##1、解析 NSFastEnumeration 协议<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> Returns <span class="keyword">by</span> <span class="keyword">reference</span> a C array <span class="keyword">of</span> objects <span class="keyword">over</span> which <span class="keyword">the</span> sender should iterate, <span class="keyword">and</span> <span class="keyword">as</span> <span class="keyword">the</span> <span class="literal">return</span> value <span class="keyword">the</span> <span class="built_in">number</span> <span class="keyword">of</span> objects <span class="keyword">in</span> <span class="keyword">the</span> array.</span><br><span class="line"></span><br><span class="line"> @param state  Context information <span class="keyword">that</span> <span class="keyword">is</span> used <span class="keyword">in</span> <span class="keyword">the</span> enumeration <span class="keyword">to</span>, <span class="keyword">in</span> addition <span class="keyword">to</span> other possibilities, ensure <span class="keyword">that</span> <span class="keyword">the</span> collection has <span class="keyword">not</span> been mutated.</span><br><span class="line"> @param buffer A C array <span class="keyword">of</span> objects <span class="keyword">over</span> which <span class="keyword">the</span> sender <span class="keyword">is</span> <span class="keyword">to</span> iterate.</span><br><span class="line"> @param len    The maximum <span class="built_in">number</span> <span class="keyword">of</span> objects <span class="keyword">to</span> <span class="literal">return</span> <span class="keyword">in</span> stackbuf.</span><br><span class="line"> </span><br><span class="line"> @discussion The state structure <span class="keyword">is</span> assumed <span class="keyword">to</span> be <span class="keyword">of</span> stack <span class="keyword">local</span> memory, so you can recast <span class="keyword">the</span> passed <span class="keyword">in</span> state structure <span class="keyword">to</span> one more suitable <span class="keyword">for</span> your iteration.</span><br><span class="line"></span><br><span class="line"> @<span class="literal">return</span> The <span class="built_in">number</span> <span class="keyword">of</span> objects returned <span class="keyword">in</span> stackbuf. Returns <span class="number">0</span> when <span class="keyword">the</span> iteration <span class="keyword">is</span> finished.</span><br><span class="line"> */</span><br><span class="line">- (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state</span><br><span class="line">                                  objects:(<span class="built_in">id</span> __unsafe_unretained [])stackbuf</span><br><span class="line">                                    <span class="built_in">count</span>:(NSUInteger)len</span><br></pre></td></tr></table></figure></p>
<p>结构体 NSFastEnumerationState 的定义:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> state;</span><br><span class="line">    <span class="keyword">id</span> __unsafe_unretained _Nullable * _Nullable itemsPtr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> * _Nullable mutationsPtr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> extra[<span class="number">5</span>];</span><br><span class="line">&#125; <span class="built_in">NSFastEnumerationState</span>;</span><br></pre></td></tr></table></figure></p>
<p>##2、快速枚举的内部实现<br>通过 <code>clang -rewrite-objc main.m</code> 命令重写了一段 OC 的快速枚举代码，详尽的注释介绍了快速枚举的内部实现，及在 <code>for/in</code> 语句中利用 goto 实现 <code>continue</code> 和 <code>break</code> 命令的 c++ 代码。</p>
<p>##3、实现 NSFastEnumeration 协议<br>作者给出了一个实现 <code>- (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state objects:(id __unsafe_unretained [])stackbuf count:(NSUInteger)len;</code> 的例子</p>
<p>##3、参考链接<br>在文末的参考链接中有文 <a href="https://www.mikeash.com/pyblog/friday-qa-2010-04-16-implementing-fast-enumeration.html" target="_blank" rel="external">Friday Q&amp;A 2010-04-16: Implementing Fast Enumeration</a> 同样介绍了快速枚举的实现。</p>
<h1 id="Day-8-iOS-并发编程之-Operation-Queues"><a href="#Day-8-iOS-并发编程之-Operation-Queues" class="headerlink" title="# Day 8 : iOS 并发编程之 Operation Queues"></a># Day 8 : <a href="http://blog.leichunfeng.com/blog/2015/07/29/ios-concurrency-programming-operation-queues/" target="_blank" rel="external">iOS 并发编程之 Operation Queues</a></h1><p>由 <a href="http://blog.leichunfeng.com/" target="_blank" rel="external">雷纯锋的技术博客</a> 发布</p>
<p>这篇文章比较长，且相当详细，很多也是 Operation Queues 的基础用法，所以这里就只将文章目录记下来好了，下次复习（的话）先来过一遍目录，记不起的再去查阅文章吧。<br>该篇文章详细介绍了 Operation Queues 的一系列使用，并且 SDWebImage 也用到了 Operation Queues，对于不久后去阅读 SDWebImage 源码想必会很有帮助。</p>
<p>##1、基本概念<br>– 进程（process）、线程（thread）、任务（task）<br>– 串行 vs. 并发<br>– 同步 vs. 异步<br>– 队列 vs. 线程的概念。</p>
<p>##2、iOS 的并发编程模型    </p>
<p>##3、Operation Queues vs. Grand Central Dispatch (GCD)</p>
<p>##4、关于 Operation 对象<br>– 并发 vs. 非并发 Operation<br>– 创建 NSInvocationOperation 对象<br>– 创建 NSBlockOperation 对象</p>
<p>##5、自定义 Operation 对象<br>– 执行主任务<br>– 响应取消事件<br>– 配置并发执行的 Operation<br>– 维护 KVO 通知</p>
<p>##6、定制 Operation 对象的执行行为<br>– 配置依赖关系<br>– 修改 Operation 在队列中的优先级<br>– 修改 Operation 执行任务线程的优先级<br>– 设置 Completion Block</p>
<p>##7、执行 Operation 对象<br>– 添加 Operation 到 Operation Queue 中<br>– 手动执行 Operation<br>– 取消 Operation<br>– 等待 Operation 执行完成<br>– 暂停和恢复 Operation Queue</p>
<p>##8、总结</p>
<h1 id="Day-7-Objective-C-Method-Swizzling-的最佳实践"><a href="#Day-7-Objective-C-Method-Swizzling-的最佳实践" class="headerlink" title="# Day 7 : Objective-C Method Swizzling 的最佳实践"></a># Day 7 : <a href="http://blog.leichunfeng.com/blog/2015/06/14/objective-c-method-swizzling-best-practice/" target="_blank" rel="external">Objective-C Method Swizzling 的最佳实践</a></h1><p>由 <a href="http://blog.leichunfeng.com/" target="_blank" rel="external">雷纯锋的技术博客</a> 发布</p>
<p>##1、Method 的数据结构：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="keyword">method_t</span> &#123;</span><br><span class="line">    SEL name; <span class="comment">// 方法的名称，用于唯一标识某个方法，比如 @selector(viewWillAppear:)</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *types; <span class="comment">// 方法的返回值和参数类型</span></span><br><span class="line">    IMP imp; <span class="comment">// 函数指针，指向方法的实现</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> SortBySELAddress :</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">std</span>::binary_function&lt;<span class="keyword">const</span> <span class="keyword">method_t</span>&amp;,</span><br><span class="line">                                    <span class="keyword">const</span> <span class="keyword">method_t</span>&amp;, <span class="keyword">bool</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">method_t</span>&amp; lhs,</span><br><span class="line">                         <span class="keyword">const</span> <span class="keyword">method_t</span>&amp; rhs)</span></span><br><span class="line">        </span>&#123; <span class="keyword">return</span> lhs.name &lt; rhs.name; &#125;</span><br><span class="line">    &#125;; <span class="comment">// 一个根据 name 的地址对方法进行排序的函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>– 实例方法保存在类对象中，类方法保存在元类对象中。（参见<a href="http://blog.leichunfeng.com/blog/2015/04/25/objective-c-object-model/" target="_blank" rel="external">Objective-C 对象模型</a>）<br>– 原则上，方法的名称 name 和方法的实现 imp 是一一对应的，而 Method Swizzling 的原理就是动态地改变它们的对应关系，以达到替换方法实现的目的。</p>
<p>##2、Method Swizzling 的最佳实践<br>+load 和 +initialize 是 Objective-C runtime 会自动调用的两个类方法。<br>– +initialize 方法以懒加载的方式被调用的，有可能不会被调用，而 +load 方法是在类被加载的时候调用。<br>– Objective-C runtime 自动调用 +load 方法时，分类中的 +load 方法并不会对主类中的 +load 方法造成覆盖<br>综上，分类中的 +load 方法是实现 Method Swizzling 逻辑的最佳“场所”<br>– 应当使用 dispatch_once 保证 Method Swizzling 只被调用一次</p>
<p>文章示例代码：<br>– 主类本身有实现需要替换的方法，即返回 NO 时，直接交换两个方法的实现；<br>– 主类本身没有实现需要替换的方法，而是继承了父类的实现，即返回 YES 时，将父类的实现替换到我们自定义的 mrc_viewWillAppear 方法中。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@implementation</span> UIViewController (MRCUMAnalytics)</span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    <span class="selector-tag">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        Class class = <span class="selector-attr">[self class]</span>;</span><br><span class="line"></span><br><span class="line">        SEL originalSelector = <span class="variable">@selector</span>(<span class="attribute">viewWillAppear</span>:);</span><br><span class="line">        SEL swizzledSelector = <span class="variable">@selector</span>(<span class="attribute">mrc_viewWillAppear</span>:);</span><br><span class="line"></span><br><span class="line">        Method originalMethod = class_getInstanceMethod(class, originalSelector);</span><br><span class="line">        Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);</span><br><span class="line"></span><br><span class="line">        BOOL success = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));</span><br><span class="line">        <span class="selector-tag">if</span> (success) &#123;</span><br><span class="line">            class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#pragma</span> <span class="selector-tag">mark</span> <span class="selector-tag">-</span> <span class="selector-tag">Method</span> <span class="selector-tag">Swizzling</span></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">mrc_viewWillAppear</span><span class="selector-pseudo">:(BOOL)animated</span> &#123;</span><br><span class="line">    <span class="selector-attr">[self mrc_viewWillAppear:animated]</span>;</span><br><span class="line">    <span class="selector-attr">[MobClick beginLogPageView:NSStringFromClass([self class]</span>)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure></p>
<h1 id="Day-6-Objective-C-Autorelease-Pool-的实现原理"><a href="#Day-6-Objective-C-Autorelease-Pool-的实现原理" class="headerlink" title="# Day 6 : Objective-C Autorelease Pool 的实现原理"></a># Day 6 : <a href="http://blog.leichunfeng.com/blog/2015/05/31/objective-c-autorelease-pool-implementation-principle/" target="_blank" rel="external">Objective-C Autorelease Pool 的实现原理</a></h1><p>由 <a href="http://blog.leichunfeng.com/" target="_blank" rel="external">雷纯锋的技术博客</a> 发布</p>
<p>##1、autoreleased 对象的释放时机<br>对象 A 被创建时引用计数为 1，当有变量 B 指向这个对象时，引用计数 +1，变量 B 离开作用域后为 nil，对象 A 的引用计数 -1，当对象 A 所在的 autoreleasepool 被 drain ，其中的 autoreleased 对象被 release ，对象 A 的引用计数 -1。当对象 A 的引用计数为 0 时随即被释放。</p>
<p>其中提到了 <code>__weak</code> 的两个特性：<br>– <code>__weak</code> 变量不会影响所指向对象的生命周期<br>– <code>__weak</code> 变量所指向的对象被释放时，<code>__weak</code> 变量的值会被置为 <code>nil</code></p>
<p>##2、AutoreleasePoolPage<br>– 介绍了 AutoreleasePoolPage 的内存结构<br>– Autorelease Pool Blocks 通过 <code>clang -rewrite-objc</code> 改写成 c++ 代码的实现，和其中的 push 操作、autorelease 操作、pop 操作</p>
<p>##3、NSThread、NSRunLoop 和 NSAutoreleasePool</p>
<blockquote>
<p>Each NSThread object, including the application’s main thread, has an NSRunLoop object automatically created for it as needed.</p>
<p>The Application Kit creates an autorelease pool on the main thread at the beginning of every cycle of the event loop, and drains it at the end, thereby releasing any autoreleased objects generated while processing an event.</p>
<p>Each thread (including the main thread) maintains its own stack of NSAutoreleasePool objects.</p>
</blockquote>
<h1 id="Day-5-Objective-C-Associated-Objects-的实现原理"><a href="#Day-5-Objective-C-Associated-Objects-的实现原理" class="headerlink" title="# Day 5 : Objective-C Associated Objects 的实现原理"></a># Day 5 : <a href="http://blog.leichunfeng.com/blog/2015/06/26/objective-c-associated-objects-implementation-principle/" target="_blank" rel="external">Objective-C Associated Objects 的实现原理</a></h1><p>由 <a href="http://blog.leichunfeng.com/" target="_blank" rel="external">雷纯锋的技术博客</a> 发布</p>
<p>##1、相关函数<br>在 Objective-C 中可以通过 Category 给一个现有的类添加属性，但是却不能添加实例变量，我们可以通过 Associated Objects 来弥补这一不足<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_setAssociatedObject</span>(<span class="params">id <span class="keyword">object</span>, <span class="keyword">const</span> <span class="keyword">void</span> *key, id <span class="keyword">value</span>, objc_AssociationPolicy policy</span>)</span>; <span class="comment">// 用于给对象添加关联对象，传入 nil 则可以移除已有的关联对象</span></span><br><span class="line"><span class="function">id <span class="title">objc_getAssociatedObject</span>(<span class="params">id <span class="keyword">object</span>, <span class="keyword">const</span> <span class="keyword">void</span> *key</span>)</span>; <span class="comment">// 用于获取关联对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_removeAssociatedObjects</span>(<span class="params">id <span class="keyword">object</span></span>)</span>; <span class="comment">// 用于移除一个对象的所有关联对象</span></span><br></pre></td></tr></table></figure></p>
<p>##2、key 值<br>上边前两个函数需要传入一个 <code>key</code> 作为唯一变量，作者推荐 <code>selector</code> ，使用 <code>getter</code> 方法的名称作为 key 值。这样就省掉了一个变量名，解决了给这个 key 命名的烦恼。</p>
<p>##3、关联策略  </p>
<table>
<thead>
<tr>
<th>关联策略</th>
<th>等价属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>OBJC_ASSOCIATION_ASSIGN</td>
<td>@property (assign) or @property (unsafe_unretained)</td>
<td>弱引用关联对象</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_RETAIN_NONATOMIC</td>
<td>@property (strong, nonatomic)</td>
<td>强引用关联对象，且为非原子操作</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_COPY_NONATOMIC</td>
<td>@property (copy, nonatomic)</td>
<td>复制关联对象，且为非原子操作</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_RETAIN</td>
<td>@property (strong, atomic)</td>
<td>强引用关联对象，且为原子操作</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_COPY</td>
<td>@property (copy, atomic)</td>
<td>复制关联对象，且为原子操作</td>
</tr>
</tbody>
</table>
<p>##4、实现 getter setter 方法<br>ViewController+AssociatedObjects.h：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> ViewController (AssociatedObjects)</span><br><span class="line"><span class="variable">@property</span> (nonatomic, copy) NSString *associatedObject_copy;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure></p>
<p>ViewController+AssociatedObjects.m：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@implementation</span> ViewController (AssociatedObjects)</span><br><span class="line">- (NSString *)associatedObject_copy &#123;</span><br><span class="line">    return objc_getAssociatedObject(self, _cmd);</span><br><span class="line">&#125;</span><br><span class="line">- (void)<span class="attribute">setAssociatedObject_copy</span>:(NSString *)associatedObject_copy &#123;</span><br><span class="line">    objc_setAssociatedObject(self, <span class="variable">@selector</span>(associatedObject_copy), associatedObject_copy, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure></p>
<p>##5、总结<br>– 关联对象与被关联对象本身的存储并没有直接的关系，它是存储在单独的哈希表中的；<br>– 关联对象的五种关联策略与属性的限定符非常类似，在绝大多数情况下，我们都会使用 OBJC_ASSOCIATION_RETAIN_NONATOMIC 的关联策略，这可以保证我们持有关联对象；<br>– 关联对象的释放时机与移除时机并不总是一致，比如实验中用关联策略 OBJC_ASSOCIATION_ASSIGN 进行关联的对象，很早就已经被释放了，但是并没有被移除，而再使用这个关联对象时就会造成 Crash 。</p>
<h1 id="Day-4-Objective-C-load-vs-initialize"><a href="#Day-4-Objective-C-load-vs-initialize" class="headerlink" title="# Day 4 : Objective-C +load vs +initialize"></a># Day 4 : <a href="http://blog.leichunfeng.com/blog/2015/05/02/objective-c-plus-load-vs-plus-initialize/" target="_blank" rel="external">Objective-C +load vs +initialize</a></h1><p>由 <a href="http://blog.leichunfeng.com/" target="_blank" rel="external">雷纯锋的技术博客</a> 发布</p>
<p>##1、+load<br>– 调用所有类的 +load 方法（包括分类的 +load 方法）是直接使用函数内存地址的方式 <code>(*load_method)(cls, SEL_load);</code> 进行调用的，而不是使用发送消息 <code>objc_msgSend</code> 的方式。也就是说如果子类没有实现 +load 方法，那么当它被加载时 runtime 是不会去调用父类的 +load 方法的。同理，当一个类和它的分类都实现了 +load 方法时，两个方法都会被调用。<br>– 子类的 +load 方法会在它的所有父类的 +load 方法之后执行，而分类的 +load 方法会在它的主类的 +load 方法之后执行。但是不同的类之间的 +load 方法的调用顺序是不确定的。</p>
<p>##2、+initialize<br>– runtime 使用了发送消息 <code>objc_msgSend</code> 的方式对 +initialize 方法进行调用。如果子类没有实现 +initialize 方法，那么继承自父类的实现会被调用；如果一个类的分类实现了 +initialize 方法，那么就会对这个类中的实现造成覆盖。<br>– 如果一个子类没有实现 +initialize 方法，那么父类的实现是会被执行多次的。可以使用下面的代码确保自己的 +initialize 方法只执行一次：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)initialize &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">self</span> == [ClassName <span class="keyword">self</span>]) &#123;</span><br><span class="line">    <span class="comment">// ... do the initialization ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>##3、总结</p>
<table>
<thead>
<tr>
<th></th>
<th>+load</th>
<th>+initialize</th>
</tr>
</thead>
<tbody>
<tr>
<td>调用时机</td>
<td>被添加到 runtime 时</td>
<td>收到第一条消息前，可能永远不调用</td>
</tr>
<tr>
<td>调用顺序</td>
<td>父类-&gt;子类-&gt;分类</td>
<td>父类-&gt;子类</td>
</tr>
<tr>
<td>调用次数</td>
<td>1次</td>
<td>多次</td>
</tr>
<tr>
<td>是否需要显式调用父类实现</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>是否沿用父类的实现</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>分类中的实现</td>
<td>类和分类都执行</td>
<td>覆盖类中的方法，只执行分类的实现</td>
</tr>
</tbody>
</table>
<h1 id="Day-3-Objective-C对象模型及应用"><a href="#Day-3-Objective-C对象模型及应用" class="headerlink" title="# Day 3 : Objective-C对象模型及应用"></a># Day 3 : <a href="http://blog.devtang.com/2013/10/15/objective-c-object-model/" target="_blank" rel="external">Objective-C对象模型及应用</a></h1><p>由 <a href="http://blog.devtang.com/" target="_blank" rel="external">唐巧的博客</a> 发布</p>
<p>##1、ISA 指针<br>– 每一个对象都有一个名为 isa 的指针，指向该对象的类。<br>– 在 Objective-C 语言中，每一个类实际上也是一个对象，每一个类也有一个名为 isa 的指针，指向该类的元类。<br>– 元类的 isa 指针指向根元类。<br>– 根元类的 isa 指针指向自己。    </p>
<p>（文章中有一张图直白的说明了 isa 指针的指向）</p>
<p>##2、Method Swizzling API 说明<br>– <code>class_replaceMethod</code>, 当需要替换的方法可能有不存在的情况时，可以考虑使用该方法。<br>– <code>method_exchangeImplementations</code>，当需要交换 2 个方法的实现时使用。<br>– <code>method_setImplementation</code> 最简单的用法，当仅仅需要为一个方法设置其实现方式时使用。</p>
<h1 id="Day-2-谈Objective-C-block的实现"><a href="#Day-2-谈Objective-C-block的实现" class="headerlink" title="# Day 2 : 谈Objective-C block的实现"></a># Day 2 : <a href="http://blog.devtang.com/2013/07/28/a-look-inside-blocks/" target="_blank" rel="external">谈Objective-C block的实现</a></h1><p>由 <a href="http://blog.devtang.com/" target="_blank" rel="external">唐巧的博客</a> 发布</p>
<p>##1、block 的 struct 结构：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Block_descriptor &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> reserved;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line">    <span class="keyword">void</span> (*copy)(<span class="keyword">void</span> *dst, <span class="keyword">void</span> *src);</span><br><span class="line">    <span class="keyword">void</span> (*dispose)(<span class="keyword">void</span> *);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Block_layout &#123;</span><br><span class="line">    <span class="keyword">void</span> *isa; <span class="comment">// 所有对象都有该指针，用于实现对象相关的功能。</span></span><br><span class="line">    <span class="keyword">int</span> flags; <span class="comment">// 用于按 bit 位表示一些 block 的附加信息，本文后面介绍 block copy 的实现代码可以看到对该变量的使用。</span></span><br><span class="line">    <span class="keyword">int</span> reserved; <span class="comment">// 保留变量。</span></span><br><span class="line">    <span class="keyword">void</span> (*invoke)(<span class="keyword">void</span> *, ...); <span class="comment">// 函数指针，指向具体的 block 实现的函数调用地址。</span></span><br><span class="line">    <span class="keyword">struct</span> Block_descriptor *descriptor; <span class="comment">// 表示该 block 的附加描述信息，主要是 size 大小，以及 copy 和 dispose 函数的指针。</span></span><br><span class="line">    <span class="comment">/* Imported variables. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>##2、clang 命令改写 OC 语言下的 block<br>使用 clang 的 <code>clang -rewrite-objc block.c</code> 命令，可以将 Objetive-C 的源码改写成 c 语言的，生成的 .cpp 文件中有许多关键代码展示了 block 的实现原理。    </p>
<p>其中，block 中操作未经 <code>__block</code> 修饰的外部变量时，.cpp 文件中相关代码为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  <span class="keyword">int</span> a = __cself-&gt;a; <span class="comment">// bound by copy</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>block 中操作经 <code>__block</code> 修饰的外部变量时，.cpp 文件中相关代码为：<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  __B<span class="function"><span class="title">lock_byref_a_0</span> *a = __cself-&gt;</span>a; <span class="comment">// bound by ref</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">printf</span>("%d\n", (a-&gt;</span>__<span class="function"><span class="title">forwarding</span>-&gt;</span>a));</span><br><span class="line">        (<span class="function"><span class="title">a</span>-&gt;</span>__<span class="function"><span class="title">forwarding</span>-&gt;</span>a) = <span class="number">1023</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>结论：<br>1、在 block 内部修改变量 a 的内容，不会影响外部的实际变量 a，是因为在 block 内部 copy 了一份变量 a。<br>2、当变量使用 __block 修饰时，block 内部是引用的外部变量的指针，所以可以修改外部的实际变量 a。</p>
<h1 id="Day-1-深入理解Objective-C：Category"><a href="#Day-1-深入理解Objective-C：Category" class="headerlink" title="# Day 1 : 深入理解Objective-C：Category"></a># Day 1 : <a href="https://tech.meituan.com/DiveIntoCategory.html" target="_blank" rel="external">深入理解Objective-C：Category</a></h1><p>由 <a href="https://tech.meituan.com/" target="_blank" rel="external">美团点评技术团队</a> 发布</p>
<p>##1、category 在 runtime 层用结构体 category_t 定义：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="keyword">category_t</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">// 类的名字</span></span><br><span class="line">    <span class="keyword">classref_t</span> cls; <span class="comment">// 类</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="keyword">method_list_t</span> *instanceMethods; <span class="comment">// category中所有给类添加的实例方法的列表</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="keyword">method_list_t</span> *classMethods; <span class="comment">// category中所有添加的类方法的列表</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="keyword">protocol_list_t</span> *protocols; <span class="comment">// category实现的所有协议的列表</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="keyword">property_list_t</span> *instanceProperties; <span class="comment">// category中添加的所有属性</span></span><br><span class="line">&#125; <span class="keyword">category_t</span>;</span><br></pre></td></tr></table></figure></p>
<p>由该结构体可以看出 category 可以动态的添加实例方法，类方法，甚至可以实现协议，添加属性，但无法添加实例变量<br>因为无法添加实例变量，所以当采用 category 为类添加属性时，并不会自动生成带有 <code>_</code> 的实例变量，所以 <code>setter</code> 和 <code>getter</code> 方法也需要自己去实现，在文章末尾有介绍采用关联对象来实现，使用 <code>objc_setAssociatedObject</code> 和 <code>objc_getAssociatedObject</code> 方法。</p>
<p>##2、category 替换原来类已有的方法<br>category 的方法被放到了新方法列表的前面，而原来类的方法被放到了新方法列表的后面，运行时在查找方法的时候是顺着方法列表的顺序查找的，它只要一找到对应名字的方法，就会罢休。<br>所以，category 的方法没有“完全替换掉”原来类已经有的方法。在文章第六节也有介绍可以使用 <code>class_copyMethodList</code> 方法获取方法列表，顺着方法列表找到最后一个对应名字的方法，就可以调用原来类的方法</p>
<p>##3、-category 和 +load 方法<br>在类的 +load 方法调用的时候，我们可以调用 category 中声明的方法，因为附加 category 到类的工作会先于 +load 方法的执行<br>+load 的执行顺序是先类，后 category，而 category 的 +load 执行顺序是根据编译顺序决定的（Compile Sources（4 items）里的顺序）</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><ul>
<li><p>小白出手，请多指教。如言有误，还望斧正！</p>
</li>
<li><p>转载请保留原文地址：<a href="http://gonghonglou.com/2017/08/09/100days-100blogs">http://gonghonglou.com/2017/08/09/100days-100blogs</a></p>
</li>
</ul>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/07/29/qinghaihu-cycling/" rel="next" title="记环青海湖骑行">
                <i class="fa fa-chevron-left"></i> 记环青海湖骑行
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/09/07/analyse-safekit/" rel="prev" title="从 SafeKit 看异常保护及 Method Swizzling 使用分析">
                从 SafeKit 看异常保护及 Method Swizzling 使用分析 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div id="sidebar-dimmer"></div>
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="与佳期" />
          <p class="site-author-name" itemprop="name">与佳期</p>
           
              <p class="site-description motion-element" itemprop="description">登白薠兮骋望，与佳期兮夕张。</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/gonghonglou" target="_blank" title="weibo">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://github.com/gonghonglou" target="_blank" title="github">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  github
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/gonghonglou" target="_blank" title="twitter">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  twitter
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#持续更新中……"><span class="nav-number">1.</span> <span class="nav-text"># 持续更新中……</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-90-《招聘一个靠谱的-iOS》—参考答案（二）"><span class="nav-number">2.</span> <span class="nav-text"># Day 90 : 《招聘一个靠谱的 iOS》—参考答案（二）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-89-《招聘一个靠谱的-iOS》—参考答案（一）"><span class="nav-number">3.</span> <span class="nav-text"># Day 89 : 《招聘一个靠谱的 iOS》—参考答案（一）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-88-iOS-面试大全从简单到复杂-简单篇"><span class="nav-number">4.</span> <span class="nav-text"># Day 88 : iOS 面试大全从简单到复杂(简单篇)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-87-WWDC2016-Session笔记-iOS-10-UICollectionView新特性"><span class="nav-number">5.</span> <span class="nav-text"># Day 87 : WWDC2016 Session笔记 - iOS 10 UICollectionView新特性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-86-深入剖析-iOS-性能优化"><span class="nav-number">6.</span> <span class="nav-text"># Day 86 : 深入剖析 iOS 性能优化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-85-检测iOS的APP性能的一些方法"><span class="nav-number">7.</span> <span class="nav-text"># Day 85 : 检测iOS的APP性能的一些方法</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-84-深入理解Objective-C：方法缓存"><span class="nav-number">8.</span> <span class="nav-text"># Day 84 : 深入理解Objective-C：方法缓存</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-83-ReactiveCocoa核心元素与信号流"><span class="nav-number">9.</span> <span class="nav-text"># Day 83 : ReactiveCocoa核心元素与信号流</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-82-ReactiveCocoa中潜在的内存泄漏及解决方案"><span class="nav-number">10.</span> <span class="nav-text"># Day 82 : ReactiveCocoa中潜在的内存泄漏及解决方案</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-81-细说ReactiveCocoa的冷信号与热信号（三）：怎么处理冷信号与热信号"><span class="nav-number">11.</span> <span class="nav-text"># Day 81 : 细说ReactiveCocoa的冷信号与热信号（三）：怎么处理冷信号与热信号</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-80-细说ReactiveCocoa的冷信号与热信号（二）：为什么要区分冷热信号"><span class="nav-number">12.</span> <span class="nav-text"># Day 80 : 细说ReactiveCocoa的冷信号与热信号（二）：为什么要区分冷热信号</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-79-细说ReactiveCocoa的冷信号与热信号（一）"><span class="nav-number">13.</span> <span class="nav-text"># Day 79 : 细说ReactiveCocoa的冷信号与热信号（一）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-78-RACSignal的Subscription深入分析"><span class="nav-number">14.</span> <span class="nav-text"># Day 78 : RACSignal的Subscription深入分析</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-77-ReactiveCocoa-Tutorial-–-The-Definitive-Introduction-Part-2-2"><span class="nav-number">15.</span> <span class="nav-text"># Day 77 : [ReactiveCocoa Tutorial – The Definitive Introduction: Part 2/2</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-76-ReactiveCocoa-Tutorial-–-The-Definitive-Introduction-Part-1-2"><span class="nav-number">16.</span> <span class="nav-text"># Day 76 : ReactiveCocoa Tutorial – The Definitive Introduction: Part 1/2</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-75-MVVM-With-ReactiveCocoa"><span class="nav-number">17.</span> <span class="nav-text"># Day 75 : MVVM With ReactiveCocoa</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-74-ReactiveCocoa-v2-5-源码解析之架构总览"><span class="nav-number">18.</span> <span class="nav-text"># Day 74 : ReactiveCocoa v2.5 源码解析之架构总览</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-73-美团App-iOS开发与FRP"><span class="nav-number">19.</span> <span class="nav-text"># Day 73 : 美团App iOS开发与FRP</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-72-iOS-开发中，怎样用好-Notifications？"><span class="nav-number">20.</span> <span class="nav-text"># Day 72 : iOS 开发中，怎样用好 Notifications？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-71-NSNotificationCenter实现原理？"><span class="nav-number">21.</span> <span class="nav-text"># Day 71 : NSNotificationCenter实现原理？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-70-iOS-性能优化：Instruments-工具的救命三招"><span class="nav-number">22.</span> <span class="nav-text"># Day 70 : iOS 性能优化：Instruments 工具的救命三招</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-69-放肆的使用UIBezierPath和CAShapeLayer画各种图形"><span class="nav-number">23.</span> <span class="nav-text"># Day 69 : 放肆的使用UIBezierPath和CAShapeLayer画各种图形</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-68-APP-缓存数据线程安全问题探讨"><span class="nav-number">24.</span> <span class="nav-text"># Day 68 : APP 缓存数据线程安全问题探讨</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-67（yesterday）-优化-App-的启动时间"><span class="nav-number">25.</span> <span class="nav-text"># Day 67（yesterday） : 优化 App 的启动时间</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-66-今日头条iOS客户端启动速度优化"><span class="nav-number">26.</span> <span class="nav-text"># Day 66 : 今日头条iOS客户端启动速度优化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-65-IOS-App-启动优化"><span class="nav-number">27.</span> <span class="nav-text"># Day 65 : IOS App 启动优化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-64-深入理解-weak-strong-dance"><span class="nav-number">28.</span> <span class="nav-text"># Day 64 : 深入理解 weak-strong dance</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-63-小笨狼漫谈多线程：GCD-一"><span class="nav-number">29.</span> <span class="nav-text"># Day 63 : 小笨狼漫谈多线程：GCD(一)</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-62-iOS-OS-X内存管理-二-：借助工具解决内存问题"><span class="nav-number">30.</span> <span class="nav-text"># Day 62 : iOS/OS X内存管理(二)：借助工具解决内存问题</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-61-Xcode中断点的威力"><span class="nav-number">31.</span> <span class="nav-text"># Day 61 : Xcode中断点的威力</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-60-小笨狼与LLDB的故事"><span class="nav-number">32.</span> <span class="nav-text"># Day 60 : 小笨狼与LLDB的故事</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-59-线程安全类的设计"><span class="nav-number">33.</span> <span class="nav-text"># Day 59 : 线程安全类的设计</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-58-CFRunLoop"><span class="nav-number">34.</span> <span class="nav-text"># Day 58 : CFRunLoop</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-57-离屏渲染优化"><span class="nav-number">35.</span> <span class="nav-text"># Day 57 : 离屏渲染优化</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-56-iOS-事件处理机制与图像渲染过程"><span class="nav-number">36.</span> <span class="nav-text"># Day 56 : iOS 事件处理机制与图像渲染过程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-55-iOS-组件化方案探索"><span class="nav-number">37.</span> <span class="nav-text"># Day 55 : iOS 组件化方案探索</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-54-iOS应用架构谈-组件化方案"><span class="nav-number">38.</span> <span class="nav-text"># Day 54 : iOS应用架构谈 组件化方案</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-53-iOS应用架构谈-本地持久化方案及动态部署"><span class="nav-number">39.</span> <span class="nav-text"># Day 53 : iOS应用架构谈 本地持久化方案及动态部署</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-52-iOS应用架构谈-网络层设计方案"><span class="nav-number">40.</span> <span class="nav-text"># Day 52 : iOS应用架构谈 网络层设计方案</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-51-yesterday-iOS应用架构谈-view层的组织和调用方案"><span class="nav-number">41.</span> <span class="nav-text"># Day 51(yesterday) : iOS应用架构谈 view层的组织和调用方案</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-50-iOS应用架构谈-开篇"><span class="nav-number">42.</span> <span class="nav-text"># Day 50 : iOS应用架构谈 开篇</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-49-组件化架构漫谈"><span class="nav-number">43.</span> <span class="nav-text"># Day 49 : 组件化架构漫谈</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-48-细说GCD（Grand-Central-Dispatch）如何用"><span class="nav-number">44.</span> <span class="nav-text"># Day 48 : 细说GCD（Grand Central Dispatch）如何用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-47-不再安全的-OSSpinLock"><span class="nav-number">45.</span> <span class="nav-text"># Day 47 : 不再安全的 OSSpinLock</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-46-yesterday-iOS-保持界面流畅的技巧"><span class="nav-number">46.</span> <span class="nav-text"># Day 46(yesterday) : iOS 保持界面流畅的技巧</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-45-iOS-处理图片的一些小-Tip"><span class="nav-number">47.</span> <span class="nav-text"># Day 45 : iOS 处理图片的一些小 Tip</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-44-移动端图片格式调研"><span class="nav-number">48.</span> <span class="nav-text"># Day 44 : 移动端图片格式调研</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-43-深入理解RunLoop"><span class="nav-number">49.</span> <span class="nav-text"># Day 43 : 深入理解RunLoop</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-42-Clang-Attributes-黑魔法小记"><span class="nav-number">50.</span> <span class="nav-text"># Day 42 : Clang Attributes 黑魔法小记</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-41-巧用-Class-Extension-分离接口依赖"><span class="nav-number">51.</span> <span class="nav-text"># Day 41 : 巧用 Class Extension 分离接口依赖</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-40-2015-Objective-C-新特性"><span class="nav-number">52.</span> <span class="nav-text"># Day 40 : 2015 Objective-C 新特性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-39-yesterday-黑魔法attribute-cleanup"><span class="nav-number">53.</span> <span class="nav-text"># Day 39(yesterday) : 黑魔法attribute((cleanup))</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-38-iOS-程序员-6-级考试（答案和解释）"><span class="nav-number">54.</span> <span class="nav-text"># Day 38 : iOS 程序员 6 级考试（答案和解释）</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-37-iOS-程序-main-函数之前发生了什么"><span class="nav-number">55.</span> <span class="nav-text"># Day 37 : iOS 程序 main 函数之前发生了什么</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-36-黑幕背后的Autorelease"><span class="nav-number">56.</span> <span class="nav-text"># Day 36 : 黑幕背后的Autorelease</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-35-Objective-C-Method-Swizzling"><span class="nav-number">57.</span> <span class="nav-text"># Day 35 : Objective-C Method Swizzling</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-34-Objective-C-引用计数原理"><span class="nav-number">58.</span> <span class="nav-text"># Day 34 : Objective-C 引用计数原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-33-yesterday-Objective-C-消息发送与转发机制原理"><span class="nav-number">59.</span> <span class="nav-text"># Day 33(yesterday) : Objective-C 消息发送与转发机制原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-32-HTTPS-是如何保证安全的？"><span class="nav-number">60.</span> <span class="nav-text"># Day 32 : HTTPS 是如何保证安全的？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-31-Objective-C-Runtime"><span class="nav-number">61.</span> <span class="nav-text"># Day 31 : Objective-C Runtime</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-30-神经病院Objective-C-Runtime出院第三天——如何正确使用Runtime"><span class="nav-number">62.</span> <span class="nav-text"># Day 30 : 神经病院Objective-C Runtime出院第三天——如何正确使用Runtime</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-29-神经病院Objective-C-Runtime住院第二天——消息发送与转发"><span class="nav-number">63.</span> <span class="nav-text"># Day 29 : 神经病院Objective-C Runtime住院第二天——消息发送与转发</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-28-神经病院Objective-C-Runtime入院第一天——isa和Class"><span class="nav-number">64.</span> <span class="nav-text"># Day 28 : 神经病院Objective-C Runtime入院第一天——isa和Class</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-27-处理手势冲突和错乱的一点经验"><span class="nav-number">65.</span> <span class="nav-text"># Day 27 : 处理手势冲突和错乱的一点经验</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-26-详解CALayer-和-UIView的区别和联系"><span class="nav-number">66.</span> <span class="nav-text"># Day 26 : 详解CALayer 和 UIView的区别和联系</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-25-iOS-常见知识点（三）：Lock"><span class="nav-number">67.</span> <span class="nav-text"># Day 25 : iOS 常见知识点（三）：Lock</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-24-iOS书写高质量代码之耦合的处理"><span class="nav-number">68.</span> <span class="nav-text"># Day 24 : iOS书写高质量代码之耦合的处理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-23-iOS关于时间的处理"><span class="nav-number">69.</span> <span class="nav-text"># Day 23 : iOS关于时间的处理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-22-正确使用-synchronized"><span class="nav-number">70.</span> <span class="nav-text"># Day 22 : 正确使用@synchronized()</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-21-iOS多线程到底不安全在哪里？"><span class="nav-number">71.</span> <span class="nav-text"># Day 21 : iOS多线程到底不安全在哪里？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-20-与调试器共舞-LLDB-的华尔兹"><span class="nav-number">72.</span> <span class="nav-text"># Day 20 : 与调试器共舞 - LLDB 的华尔兹</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-19-IP，TCP-和-HTTP"><span class="nav-number">73.</span> <span class="nav-text"># Day 19 : IP，TCP 和 HTTP</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-18-基础集合类"><span class="nav-number">74.</span> <span class="nav-text"># Day 18 : 基础集合类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-17-Build-过程"><span class="nav-number">75.</span> <span class="nav-text"># Day 17 : Build 过程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-16-自定义控件"><span class="nav-number">76.</span> <span class="nav-text"># Day 16 : 自定义控件</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-15-底层并发-API"><span class="nav-number">77.</span> <span class="nav-text"># Day 15 : 底层并发 API</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-14-常见的后台实践"><span class="nav-number">78.</span> <span class="nav-text"># Day 14 : 常见的后台实践</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-13-并发编程：API-及挑战"><span class="nav-number">79.</span> <span class="nav-text"># Day 13 : 并发编程：API 及挑战</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-12-理解-Scroll-Views"><span class="nav-number">80.</span> <span class="nav-text"># Day 12 : 理解 Scroll Views</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-11-绘制像素到屏幕上"><span class="nav-number">81.</span> <span class="nav-text"># Day 11 : 绘制像素到屏幕上</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-10-谈谈-iOS-中图片的解压缩"><span class="nav-number">82.</span> <span class="nav-text"># Day 10 : 谈谈 iOS 中图片的解压缩</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-9-Objective-C-Fast-Enumeration-的实现原理"><span class="nav-number">83.</span> <span class="nav-text"># Day 9 : Objective-C Fast Enumeration 的实现原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-8-iOS-并发编程之-Operation-Queues"><span class="nav-number">84.</span> <span class="nav-text"># Day 8 : iOS 并发编程之 Operation Queues</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-7-Objective-C-Method-Swizzling-的最佳实践"><span class="nav-number">85.</span> <span class="nav-text"># Day 7 : Objective-C Method Swizzling 的最佳实践</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-6-Objective-C-Autorelease-Pool-的实现原理"><span class="nav-number">86.</span> <span class="nav-text"># Day 6 : Objective-C Autorelease Pool 的实现原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-5-Objective-C-Associated-Objects-的实现原理"><span class="nav-number">87.</span> <span class="nav-text"># Day 5 : Objective-C Associated Objects 的实现原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-4-Objective-C-load-vs-initialize"><span class="nav-number">88.</span> <span class="nav-text"># Day 4 : Objective-C +load vs +initialize</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-3-Objective-C对象模型及应用"><span class="nav-number">89.</span> <span class="nav-text"># Day 3 : Objective-C对象模型及应用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-2-谈Objective-C-block的实现"><span class="nav-number">90.</span> <span class="nav-text"># Day 2 : 谈Objective-C block的实现</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-1-深入理解Objective-C：Category"><span class="nav-number">91.</span> <span class="nav-text"># Day 1 : 深入理解Objective-C：Category</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#后记"><span class="nav-number">92.</span> <span class="nav-text">后记</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">与佳期</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  

    
      <script id="dsq-count-scr" src="https://gonghonglou.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://gonghonglou.com/2017/08/09/100days-100blogs/';
          this.page.identifier = '2017/08/09/100days-100blogs/';
          this.page.title = '100 Days, 100 Blogs';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://gonghonglou.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  








  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

</body>
</html>
