<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="与佳期的个人博客" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="一直以来都活跃在微博、简书等各大网站搜罗技术博客，每当看到大牛发布或者转发技术博客都会点进去搂一眼，内容比较好或者比较感兴趣的话就会转发收藏。但这些都是零零碎碎的，大多时候都是路上、睡觉前或者什么间隙看到一篇好文章，简单看一下就收藏了，当时来不及 想着以后细读，但往往是在这之后基本上不会再次翻阅了。所以计划从今天起每天仔细阅读一篇技术博客，在这里做一做笔记。
微博每日打卡：#100days,100">
<meta property="og:type" content="article">
<meta property="og:title" content="100 Days, 100 Blogs">
<meta property="og:url" content="http://gonghonglou.com/2017/08/09/100days-100blogs/index.html">
<meta property="og:site_name" content="与佳期的个人博客">
<meta property="og:description" content="一直以来都活跃在微博、简书等各大网站搜罗技术博客，每当看到大牛发布或者转发技术博客都会点进去搂一眼，内容比较好或者比较感兴趣的话就会转发收藏。但这些都是零零碎碎的，大多时候都是路上、睡觉前或者什么间隙看到一篇好文章，简单看一下就收藏了，当时来不及 想着以后细读，但往往是在这之后基本上不会再次翻阅了。所以计划从今天起每天仔细阅读一篇技术博客，在这里做一做笔记。
微博每日打卡：#100days,100">
<meta property="og:updated_time" content="2017-08-27T09:05:22.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="100 Days, 100 Blogs">
<meta name="twitter:description" content="一直以来都活跃在微博、简书等各大网站搜罗技术博客，每当看到大牛发布或者转发技术博客都会点进去搂一眼，内容比较好或者比较感兴趣的话就会转发收藏。但这些都是零零碎碎的，大多时候都是路上、睡觉前或者什么间隙看到一篇好文章，简单看一下就收藏了，当时来不及 想着以后细读，但往往是在这之后基本上不会再次翻阅了。所以计划从今天起每天仔细阅读一篇技术博客，在这里做一做笔记。
微博每日打卡：#100days,100">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"hide","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://gonghonglou.com/2017/08/09/100days-100blogs/"/>





  <title>100 Days, 100 Blogs | 与佳期的个人博客</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">与佳期的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">登白薠兮骋望，与佳期兮夕张。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://gonghonglou.com/2017/08/09/100days-100blogs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="与佳期">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="与佳期的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">100 Days, 100 Blogs</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-09T11:57:11+08:00">
                2017-08-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/08/09/100days-100blogs/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/08/09/100days-100blogs/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>一直以来都活跃在微博、简书等各大网站搜罗技术博客，每当看到大牛发布或者转发技术博客都会点进去搂一眼，内容比较好或者比较感兴趣的话就会转发收藏。<br>但这些都是零零碎碎的，大多时候都是路上、睡觉前或者什么间隙看到一篇好文章，简单看一下就收藏了，当时来不及 想着以后细读，但往往是在这之后基本上不会再次翻阅了。所以计划从今天起每天仔细阅读一篇技术博客，在这里做一做笔记。</p>
<p>微博每日打卡：<a href="https://weibo.com/p/100808e7a8991364ef294db915427e9aeb2a7e" target="_blank" rel="external">#100days,100blogs#</a></p>
<h1 id="持续更新中……"><a href="#持续更新中……" class="headerlink" title="# 持续更新中……"></a># 持续更新中……</h1><h1 id="Day-19-IP，TCP-和-HTTP"><a href="#Day-19-IP，TCP-和-HTTP" class="headerlink" title="# Day 19 : IP，TCP 和 HTTP"></a># Day 19 : <a href="https://objccn.io/issue-10-6/" target="_blank" rel="external">IP，TCP 和 HTTP</a></h1><p>由 <a href="https://objccn.io/" target="_blank" rel="external">ObjC 中国</a> 发布</p>
<p>又温习一遍网络链接的知识。。。</p>
<h1 id="Day-18-基础集合类"><a href="#Day-18-基础集合类" class="headerlink" title="# Day 18 : 基础集合类"></a># Day 18 : <a href="https://objccn.io/issue-7-1/" target="_blank" rel="external">基础集合类</a></h1><p>由 <a href="https://objccn.io/" target="_blank" rel="external">ObjC 中国</a> 发布</p>
<p>这篇文章可真的是基础了，可能是今天时间太紧张没找到一篇比较有深度的文章，不过这篇文章从基础集合类（NSArray, NSSet, NSOrderedSet 和 NSDictionary）讲起，分别介绍了它们的方法，分析了性能，当是基础知识的一次复习吧。<br>文中总结列出了枚举 NSArray 和 NSDictionary 的几种方法，并分析了各自的性能，值得一看。因为都是一些基础集合类，就不做什么笔记了，各个类的方法到 Xcode 里都能轻易找着。</p>
<h1 id="Day-17-Build-过程"><a href="#Day-17-Build-过程" class="headerlink" title="# Day 17 : Build 过程"></a># Day 17 : <a href="https://objccn.io/issue-6-1/" target="_blank" rel="external">Build 过程</a></h1><p>由 <a href="https://objccn.io/" target="_blank" rel="external">ObjC 中国</a> 发布</p>
<ul>
<li>解密 Build 日志</li>
<li><p>Build过程的控制<br>  – Build Phases：代表将代码转变为可执行文件的最高级别规则。<br>  – 定制Build Phases：可以在 build phases 中添加运行自定义脚本，就像CocoaPods使用的一样，来做额外的工作。<br>  – Build Rules：指定了不同的文件类型该如何编译。<br>  – Build Settings：可以配置每个任务（之前在 build log 输出中看到的任务）的详细内容。例如可以添加一个 “Run Script”：如果一个源文件超过指定行数，就发出警告。如下代码所示，设置的行数为 200：</p>
  <figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find <span class="string">"<span class="variable">$&#123;SRCROOT&#125;</span>"</span> \( -name <span class="string">"*.h"</span> -or -name <span class="string">"*.m"</span> \) -print0 | xargs -<span class="number">0</span> wc -l | awk '<span class="variable">$1</span> &gt; <span class="number">200</span> &amp;&amp; <span class="variable">$2</span> != <span class="string">"total"</span> &#123; <span class="literal">print</span> <span class="variable">$2</span> <span class="string">":1: warning: file more than 200 lines"</span> &#125;'</span><br></pre></td></tr></table></figure>
</li>
<li><p>工程文件（.pbxproj）</p>
</li>
</ul>
<h1 id="Day-16-自定义控件"><a href="#Day-16-自定义控件" class="headerlink" title="# Day 16 : 自定义控件"></a># Day 16 : <a href="https://objccn.io/issue-3-4/" target="_blank" rel="external">自定义控件</a></h1><p>由 <a href="https://objccn.io/" target="_blank" rel="external">ObjC 中国</a> 发布</p>
<p>该篇文章比较基础，介绍了自定义控件用到的 UIView 基类、渲染、交互、本地化及测试：</p>
<ul>
<li>视图层次概览<br>  – reponders (响应者)：UIView 的父类，能够处理触摸、手势、远程控制等事件。<br>  – views (视图)：视图的区域是由它的 frame 定义的。实际上 frame 是一个派生属性，是由 center 和 bounds 合成而来。<br>  – controls (控件)：建立在视图上，增加了更多的交互支持。最重要的是，它增加了 target / action 模式。</li>
<li>渲染<br>  – 尽量避免 drawRect:，使用现有的视图构建自定义视图。如果重写 drawRect:，确保检查内容模式。默认的模式是将内容缩放以填充视图的范围，这在当视图的 frame 改变时并不会重新绘制。<br>  – 处理图片时，你也可以让 GPU 为你工作来代替使用 Core Graphics。使用 Core Image，你不必用 CPU 做任何的工作就可以在图片上建立复杂的效果。</li>
<li>自定义交互<br>  – 使用 Target-Action<br>  – 使用代理<br>  – 使用 Block<br>  – 使用 KVO<br>  – 使用通知</li>
<li>辅助功能 (Accessibility)<br>  – 本地化：使用 NSLocalizedString 本地化字符串。<br>  – 测试：可以使用 UIAutomation 或者其它基于它的工具。</li>
</ul>
<h1 id="Day-15-底层并发-API"><a href="#Day-15-底层并发-API" class="headerlink" title="# Day 15 : 底层并发 API"></a># Day 15 : <a href="https://objccn.io/issue-2-3/" target="_blank" rel="external">底层并发 API</a></h1><p>由 <a href="https://objccn.io/" target="_blank" rel="external">ObjC 中国</a> 发布</p>
<p>该篇文章并非是专门介绍 GCD(Grand Central Dispatch) 使用的，但从分析及解决并发问题的角度出发介绍了很多 GCD 的用法</p>
<ul>
<li>从前…：<code>dispatch_once</code></li>
<li>延后执行：<code>dispatch_after</code><br>  – 队列<br>  – 目标队列：为一个类创建它自己的队列而不是使用全局的队列，这种方式可以设置队列的名字，在 Xcode 的 Debug Navigator 中可以看到所有的队列名字，(lldb) thread list 命令会在控制台打印出所有队列的名字。<br>  – 优先级</li>
<li>隔离<br>  – 资源保护<br>  – 单一资源的多读单写：<code>dispatch_barrier_async</code><br>  – 锁竞争<br>  – 全都使用异步分发：<code>dispatch_async()</code><br>  – 如何写出好的异步 API</li>
<li>迭代执行：<code>dispatch_apply</code><br>  – 组：<code>dispatch_group_t</code><br>  – 对现有API使用 dispatch_group_t</li>
<li>事件源：<code>dispatch_source_t</code><br>  – 监视进程<br>  – 监视文件<br>  – 定时器<br>  – 取消</li>
<li>输入输出<br>  – GCD 和缓冲区：<code>dispatch_data_t</code><br>  – 读和写：<code>dispatch_io_create_with_path</code>、<code>dispatch_io_read</code>、<code>dispatch_io_write</code> 和 <code>dispatch_io_close</code></li>
<li>基准测试：<code>uint64_t dispatch_benchmark(size_t count, void (^block)(void));</code>能够测量给定的代码执行的平均的纳秒数</li>
<li>原子操作<br>  – 计数器<br>  – 比较和交换<br>  – 原子队列<br>  – 自旋锁</li>
</ul>
<h1 id="Day-14-常见的后台实践"><a href="#Day-14-常见的后台实践" class="headerlink" title="# Day 14 : 常见的后台实践"></a># Day 14 : <a href="https://objccn.io/issue-2-2/" target="_blank" rel="external">常见的后台实践</a></h1><p>由 <a href="https://objccn.io/" target="_blank" rel="external">ObjC 中国</a> 发布</p>
<p>作者从以下方面介绍了将耗时操作放进后台执行的策略：<br>– 后台的 Core Data<br>– 更新 Main Context<br>– 后台 UI 代码<br>– 后台绘制：如果确定 drawRect: 是应用的性能瓶颈，把 drawRect:中的代码放到后台操作中去。然后将原本打算绘制的视图用一个 image view 来替换，等到操作执行完后再去更新。在绘制的方法中，使用 UIGraphicsBeginImageContextWithOptions 来取代 UIGraphicsGetCurrentContext ：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">UIGraphicsBeginImageContextWithOptions</span>(size, <span class="literal">NO</span>, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// drawing code here</span></span><br><span class="line"><span class="built_in">UIImage</span> *i = <span class="built_in">UIGraphicsGetImageFromCurrentImageContext</span>();</span><br><span class="line"><span class="built_in">UIGraphicsEndImageContext</span>();</span><br><span class="line"><span class="keyword">return</span> i;</span><br></pre></td></tr></table></figure></p>
<p>通过在第三个参数中传入 0 ，设备的主屏幕的 scale 将被自动传入，这将使图片在普通设备和 retina 屏幕上都有良好的表现。</p>
<p>– 异步网络请求处理：像 AFNetworking 这样的框架：建立一个独立的线程，为建立的线程设置自己的 run loop，然后在其中调度 URL 连接。<br>– 进阶：后台文件 I/O：对于不方便一次性读入内存的大文件可以使用异步处理文件的 NSInputStream<br>。。。。。。</p>
<h1 id="Day-13-并发编程：API-及挑战"><a href="#Day-13-并发编程：API-及挑战" class="headerlink" title="# Day 13 : 并发编程：API 及挑战"></a># Day 13 : <a href="https://objccn.io/issue-2-1/" target="_blank" rel="external">并发编程：API 及挑战</a></h1><p>由 <a href="https://objccn.io/" target="_blank" rel="external">ObjC 中国</a> 发布</p>
<p>##1、OS X 和 iOS 中的并发编程<br>– 线程<br>可以使用 Instruments 中的 CPU strategy view 来得知代码是如何在多核 CPU 中调度执行的。<br>– Grand Central Dispatch<br>GCD 公开有 5 个不同的队列：运行在主线程中的 main queue，3 个不同优先级的后台队列，以及一个优先级更低的后台队列（用于 I/O）。 另外，开发者可以创建自定义队列：串行或者并行队列。自定义队列非常强大，在自定义队列中被调度的所有 block 最终都将被放入到系统的全局队列中和线程池中。<br>强烈建议在绝大多数情况下使用默认的优先级队列，避免在不同优先级的队列中调度访问共享资源的任务而产生不可预期的行为，比如低优先级的任务阻塞了高优先级任务而造成程序的完全挂起。<br>– Operation Queues<br>NSOperationQueue 有两种不同类型的队列：主队列和自定义队列。主队列运行在主线程之上，而自定义队列在后台执行。你可以通过重写 main 或者 start 方法来定义自己的 operations。<br>你可以通过 maxConcurrentOperationCount 属性来控制一个特定队列中可以有多少个操作参与并发执行，还可以在 operation 之间指定依赖关系。<br>– Run Loops<br>主线程一般来说都已经配置好了 main run loop。然而其他线程默认情况下都没有设置 run loop。你也可以自行为其他线程设置 run loop ，但是一般来说我们很少需要这么做。大多数时间使用 main run loop 会容易得多。</p>
<p>##2、并发编程中面临的挑战<br>– 资源共享<br>– 互斥锁<br>– 死锁<br>– 资源饥饿（Starvation）<br>– 优先级反转</p>
<p>##3、总结<br>我们建议采纳的安全模式是这样的：从主线程中提取出要使用到的数据，并利用一个操作队列在后台处理相关的数据，最后回到主队列中来发送你在后台队列中得到的结果。使用这种方式，你不需要自己做任何锁操作，这也就大大减少了犯错误的几率。</p>
<h1 id="Day-12-理解-Scroll-Views"><a href="#Day-12-理解-Scroll-Views" class="headerlink" title="# Day 12 : 理解 Scroll Views"></a># Day 12 : <a href="https://objccn.io/issue-3-2/" target="_blank" rel="external">理解 Scroll Views</a></h1><p>由 <a href="https://objccn.io/" target="_blank" rel="external">ObjC 中国</a> 发布</p>
<p>该篇文章比较简洁，从 UIView 的光栅化和组合说起，简单明了的介绍了 Scroll View 的实现思路。<br>并介绍了 Scroll View 的：<br>– Content Offset：相当于更改 Superview.bounds.origin<br>– Content Size：可滚动区域<br>– Content Insets：可以改变 content offset 的最大和最小值，这样便可以滚动出可滚动区域</p>
<p>或许可以应用在有键盘弹出的页面，比如登录页面，弹出键盘输入用户名密码时会遮挡屏幕下半部的视图，可以采用 Scroll View 的滚动特性来解决这一尴尬，恰巧今天碰见 Medium 的登录页面貌似就是这么设计的。</p>
<h1 id="Day-11-绘制像素到屏幕上"><a href="#Day-11-绘制像素到屏幕上" class="headerlink" title="# Day 11 : 绘制像素到屏幕上"></a># Day 11 : <a href="https://objccn.io/issue-3-1/" target="_blank" rel="external">绘制像素到屏幕上</a></h1><p>由 <a href="https://objccn.io/" target="_blank" rel="external">ObjC 中国</a> 发布</p>
<p>文章知识比较碎却又是全集中在屏幕绘制这一块，许多知识点都基于原理特别受用。以下是文章中提及的知识点（目录）：<br>– 图形堆栈<br>– 软件组成：Display &lt;-&gt; GPU &lt;-&gt; GPU Driver &lt;-&gt; OpenGL(Open Graphics Library) &lt;-&gt; Core Animation/Core Graphics/Core Image &lt;-&gt; app<br>– 硬件参与者<br>– 合成：对于屏幕上的每一个像素，GPU 需要算出怎么混合这些纹理来得到像素 RGB 的值，并最终显示在屏幕上。所以减少视图层级可以有效提高性能，因为 GPU 需要将重叠的视图计算合成在一起（将纹理中的一个像素合成到另一个纹理的像素上）。<br>– 不透明 VS 透明：当源纹理是完全不透明的时候，目标像素就等于源纹理。这可以省下 GPU 很大的工作量，这样只需简单的拷贝源纹理而不需要合成所有的像素值。CALayer 有一个叫做 opaque 的属性，如果这个属性为 YES，GPU 将不会做任何合成，而是简单从这个层拷贝，不需要考虑它下方的任何东西(因为都被它遮挡住了)，这节省了 GPU 相当大的工作量。Instruments 中 color blended layers 选项中所涉及的，允许你看到哪一个 layers(纹理) 被标注为透明的。<br>– 像素对齐 VS 不重合在一起：「缩放」和「纹理的起点不在一个像素的边界上」会导致一个 layer 上所有的像素和屏幕上的像素不对齐，GPU 需要再做额外的计算。它需要将源纹理上多个像素混合起来，生成一个用来合成的值。<br>– Masks(蒙板)：mask 是一个拥有 alpha 值的位图，当像素要和它下面包含的像素合并之前都会把 mask 应用到图层的像素上去。当你要设置一个图层的圆角半径时，你可以有效的在图层上面设置一个 mask。<br>– 离屏渲染(Offscreen Rendering)：为 layer 使用蒙板、设置圆角半径、产生阴影会造成屏幕外渲染。Instrument 的 Core Animation 工具有一个叫做 Color Offscreen-Rendered Yellow 的选项，它会将已经被渲染到屏幕外缓冲区的区域标注为黄色。同时记得检查 Color Hits Green and Misses Red 选项。绿色代表无论何时一个屏幕外缓冲区被复用，而红色代表当缓冲区被重新创建。<br>– 更多的关于合成<br>– OS X<br>– Core Animation OpenGL ES<br>– CPU 限制 VS GPU 限制：你可以使用 OpenGL ES Driver instrument，点击上面那个小的 i 按钮，配置一下，同时注意勾选 Device Utilization %。现在，当你运行你的 app 时，你可以看到你 GPU 的负荷。<br>– Core Graphics / Quartz 2D<br>– CGLayer<br>– 像素<br>– 默认的像素布局<br>– 深奥的布局<br>– 二维数据<br>– YCbCr<br>– 图片格式<br>– JPEG<br>– PNG<br>– 挑选一个格式<br>– UIKit 和 Pixels<br>– With –drawRect:<br>– 不使用 -drawRect:<br>– 实现-drawRect: 还是不实现 -drawRect:<br>– 单一颜色<br>– 可变尺寸的图像<br>– 并发绘图<br>– CALayer<br>– 自定义绘制的图层<br>– 形状和文本图层<br>– 异步绘图</p>
<h1 id="Day-10-谈谈-iOS-中图片的解压缩"><a href="#Day-10-谈谈-iOS-中图片的解压缩" class="headerlink" title="# Day 10 : 谈谈 iOS 中图片的解压缩"></a># Day 10 : <a href="http://blog.leichunfeng.com/blog/2017/02/20/talking-about-the-decompression-of-the-image-in-ios/" target="_blank" rel="external">谈谈 iOS 中图片的解压缩</a></h1><p>由 <a href="http://blog.leichunfeng.com/" target="_blank" rel="external">雷纯锋的技术博客</a> 发布</p>
<p>##1、图片加载<br>图片加载的工作流参考 <a href="https://github.com/path/FastImageCache#the-problem" target="_blank" rel="external">FastImageCache 在 GitHub</a> 上的 README.md。<br>图片在渲染到 UIImageView 的图层之前需要将其解压缩，而对图片解压缩默认是在主线程完成的，并且是一个非常耗时的操作，在对性能要求比较高时可以在图片渲染到屏幕之前在子线程提前对图片进行强制解压缩，强制解压缩的原理就是对图片进行重新绘制，得到一张新的解压缩后的位图。其中，用到的最核心的函数是 CGBitmapContextCreate ：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CG_EXTERN CGContextRef __<span class="function">nullable <span class="title">CGBitmapContextCreate</span><span class="params">(<span class="keyword">void</span> * __nullable data,</span><br><span class="line">    <span class="keyword">size_t</span> width, <span class="keyword">size_t</span> height, <span class="keyword">size_t</span> bitsPerComponent, <span class="keyword">size_t</span> bytesPerRow,</span><br><span class="line">    CGColorSpaceRef cg_nullable space, <span class="keyword">uint32_t</span> bitmapInfo)</span></span><br><span class="line">    <span class="title">CG_AVAILABLE_STARTING</span><span class="params">(__MAC_10_0, __IPHONE_2_0)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>其中：<br>– data：如果不为 NULL ，那么它应该指向一块大小至少为 bytesPerRow <em> height 字节的内存；如果 为 NULL ，那么系统就会为我们自动分配和释放所需的内存，所以一般指定 NULL 即可；<br>– width 和 height：位图的宽度和高度，分别赋值为图片的像素宽度和像素高度即可；<br>– bitsPerComponent：像素的每个颜色分量使用的 bit 数，在 RGB 颜色空间下指定 8 即可；<br>– bytesPerRow：位图的每一行使用的字节数，大小至少为 width </em> bytes per pixel 字节。有意思的是，当我们指定 0 时，系统不仅会为我们自动计算，而且还会进行 cache line alignment 的优化；<br>– space：就是我们前面提到的颜色空间，一般使用 RGB 即可；<br>– bitmapInfo：就是我们前面提到的位图的布局信息。<br>涉及到的概念：<br>Pixel Format（像素格式）、Color and Color Spaces（颜色空间）、Color Spaces and Bitmap Layout（位图布局）</p>
<p>##2、开源库<br>贴出了 YYKit 中存在于 YYImageCoder 类中用于解压缩图片的核心代码的函数 YYCGImageCreateDecodedCopy。讲解代码步骤并对 YYKit，SDWebImage，FLAnimatedImage 做了性能比对。</p>
<h1 id="Day-9-Objective-C-Fast-Enumeration-的实现原理"><a href="#Day-9-Objective-C-Fast-Enumeration-的实现原理" class="headerlink" title="# Day 9 : Objective-C Fast Enumeration 的实现原理"></a># Day 9 : <a href="http://blog.leichunfeng.com/blog/2016/06/20/objective-c-fast-enumeration-implementation-principle/" target="_blank" rel="external">Objective-C Fast Enumeration 的实现原理</a></h1><p>由 <a href="http://blog.leichunfeng.com/" target="_blank" rel="external">雷纯锋的技术博客</a> 发布</p>
<p>##1、解析 NSFastEnumeration 协议<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> Returns <span class="keyword">by</span> <span class="keyword">reference</span> a C array <span class="keyword">of</span> objects <span class="keyword">over</span> which <span class="keyword">the</span> sender should iterate, <span class="keyword">and</span> <span class="keyword">as</span> <span class="keyword">the</span> <span class="literal">return</span> value <span class="keyword">the</span> <span class="built_in">number</span> <span class="keyword">of</span> objects <span class="keyword">in</span> <span class="keyword">the</span> array.</span><br><span class="line"></span><br><span class="line"> @param state  Context information <span class="keyword">that</span> <span class="keyword">is</span> used <span class="keyword">in</span> <span class="keyword">the</span> enumeration <span class="keyword">to</span>, <span class="keyword">in</span> addition <span class="keyword">to</span> other possibilities, ensure <span class="keyword">that</span> <span class="keyword">the</span> collection has <span class="keyword">not</span> been mutated.</span><br><span class="line"> @param buffer A C array <span class="keyword">of</span> objects <span class="keyword">over</span> which <span class="keyword">the</span> sender <span class="keyword">is</span> <span class="keyword">to</span> iterate.</span><br><span class="line"> @param len    The maximum <span class="built_in">number</span> <span class="keyword">of</span> objects <span class="keyword">to</span> <span class="literal">return</span> <span class="keyword">in</span> stackbuf.</span><br><span class="line"> </span><br><span class="line"> @discussion The state structure <span class="keyword">is</span> assumed <span class="keyword">to</span> be <span class="keyword">of</span> stack <span class="keyword">local</span> memory, so you can recast <span class="keyword">the</span> passed <span class="keyword">in</span> state structure <span class="keyword">to</span> one more suitable <span class="keyword">for</span> your iteration.</span><br><span class="line"></span><br><span class="line"> @<span class="literal">return</span> The <span class="built_in">number</span> <span class="keyword">of</span> objects returned <span class="keyword">in</span> stackbuf. Returns <span class="number">0</span> when <span class="keyword">the</span> iteration <span class="keyword">is</span> finished.</span><br><span class="line"> */</span><br><span class="line">- (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state</span><br><span class="line">                                  objects:(<span class="built_in">id</span> __unsafe_unretained [])stackbuf</span><br><span class="line">                                    <span class="built_in">count</span>:(NSUInteger)len</span><br></pre></td></tr></table></figure></p>
<p>结构体 NSFastEnumerationState 的定义:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> state;</span><br><span class="line">    <span class="keyword">id</span> __unsafe_unretained _Nullable * _Nullable itemsPtr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> * _Nullable mutationsPtr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> extra[<span class="number">5</span>];</span><br><span class="line">&#125; <span class="built_in">NSFastEnumerationState</span>;</span><br></pre></td></tr></table></figure></p>
<p>##2、快速枚举的内部实现<br>通过 <code>clang -rewrite-objc main.m</code> 命令重写了一段 OC 的快速枚举代码，详尽的注释介绍了快速枚举的内部实现，及在 <code>for/in</code> 语句中利用 goto 实现 <code>continue</code> 和 <code>break</code> 命令的 c++ 代码。</p>
<p>##3、实现 NSFastEnumeration 协议<br>作者给出了一个实现 <code>- (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state objects:(id __unsafe_unretained [])stackbuf count:(NSUInteger)len;</code> 的例子</p>
<p>##3、参考链接<br>在文末的参考链接中有文 <a href="https://www.mikeash.com/pyblog/friday-qa-2010-04-16-implementing-fast-enumeration.html" target="_blank" rel="external">Friday Q&amp;A 2010-04-16: Implementing Fast Enumeration</a> 同样介绍了快速枚举的实现。</p>
<h1 id="Day-8-iOS-并发编程之-Operation-Queues"><a href="#Day-8-iOS-并发编程之-Operation-Queues" class="headerlink" title="# Day 8 : iOS 并发编程之 Operation Queues"></a># Day 8 : <a href="http://blog.leichunfeng.com/blog/2015/07/29/ios-concurrency-programming-operation-queues/" target="_blank" rel="external">iOS 并发编程之 Operation Queues</a></h1><p>由 <a href="http://blog.leichunfeng.com/" target="_blank" rel="external">雷纯锋的技术博客</a> 发布</p>
<p>这篇文章比较长，且相当详细，很多也是 Operation Queues 的基础用法，所以这里就只将文章目录记下来好了，下次复习（的话）先来过一遍目录，记不起的再去查阅文章吧。<br>该篇文章详细介绍了 Operation Queues 的一系列使用，并且 SDWebImage 也用到了 Operation Queues，对于不久后去阅读 SDWebImage 源码想必会很有帮助。</p>
<p>##1、基本概念<br>– 进程（process）、线程（thread）、任务（task）<br>– 串行 vs. 并发<br>– 同步 vs. 异步<br>– 队列 vs. 线程的概念。</p>
<p>##2、iOS 的并发编程模型    </p>
<p>##3、Operation Queues vs. Grand Central Dispatch (GCD)</p>
<p>##4、关于 Operation 对象<br>– 并发 vs. 非并发 Operation<br>– 创建 NSInvocationOperation 对象<br>– 创建 NSBlockOperation 对象</p>
<p>##5、自定义 Operation 对象<br>– 执行主任务<br>– 响应取消事件<br>– 配置并发执行的 Operation<br>– 维护 KVO 通知</p>
<p>##6、定制 Operation 对象的执行行为<br>– 配置依赖关系<br>– 修改 Operation 在队列中的优先级<br>– 修改 Operation 执行任务线程的优先级<br>– 设置 Completion Block</p>
<p>##7、执行 Operation 对象<br>– 添加 Operation 到 Operation Queue 中<br>– 手动执行 Operation<br>– 取消 Operation<br>– 等待 Operation 执行完成<br>– 暂停和恢复 Operation Queue</p>
<p>##8、总结</p>
<h1 id="Day-7-Objective-C-Method-Swizzling-的最佳实践"><a href="#Day-7-Objective-C-Method-Swizzling-的最佳实践" class="headerlink" title="# Day 7 : Objective-C Method Swizzling 的最佳实践"></a># Day 7 : <a href="http://blog.leichunfeng.com/blog/2015/06/14/objective-c-method-swizzling-best-practice/" target="_blank" rel="external">Objective-C Method Swizzling 的最佳实践</a></h1><p>由 <a href="http://blog.leichunfeng.com/" target="_blank" rel="external">雷纯锋的技术博客</a> 发布</p>
<p>##1、Method 的数据结构：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="keyword">method_t</span> &#123;</span><br><span class="line">    SEL name; <span class="comment">// 方法的名称，用于唯一标识某个方法，比如 @selector(viewWillAppear:)</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *types; <span class="comment">// 方法的返回值和参数类型</span></span><br><span class="line">    IMP imp; <span class="comment">// 函数指针，指向方法的实现</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> SortBySELAddress :</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">std</span>::binary_function&lt;<span class="keyword">const</span> <span class="keyword">method_t</span>&amp;,</span><br><span class="line">                                    <span class="keyword">const</span> <span class="keyword">method_t</span>&amp;, <span class="keyword">bool</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">method_t</span>&amp; lhs,</span><br><span class="line">                         <span class="keyword">const</span> <span class="keyword">method_t</span>&amp; rhs)</span></span><br><span class="line">        </span>&#123; <span class="keyword">return</span> lhs.name &lt; rhs.name; &#125;</span><br><span class="line">    &#125;; <span class="comment">// 一个根据 name 的地址对方法进行排序的函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>– 实例方法保存在类对象中，类方法保存在元类对象中。（参见<a href="http://blog.leichunfeng.com/blog/2015/04/25/objective-c-object-model/" target="_blank" rel="external">Objective-C 对象模型</a>）<br>– 原则上，方法的名称 name 和方法的实现 imp 是一一对应的，而 Method Swizzling 的原理就是动态地改变它们的对应关系，以达到替换方法实现的目的。</p>
<p>##2、Method Swizzling 的最佳实践<br>+load 和 +initialize 是 Objective-C runtime 会自动调用的两个类方法。<br>– +initialize 方法以懒加载的方式被调用的，有可能不会被调用，而 +load 方法是在类被加载的时候调用。<br>– Objective-C runtime 自动调用 +load 方法时，分类中的 +load 方法并不会对主类中的 +load 方法造成覆盖<br>综上，分类中的 +load 方法是实现 Method Swizzling 逻辑的最佳“场所”<br>– 应当使用 dispatch_once 保证 Method Swizzling 只被调用一次</p>
<p>文章示例代码：<br>– 主类本身有实现需要替换的方法，即返回 NO 时，直接交换两个方法的实现；<br>– 主类本身没有实现需要替换的方法，而是继承了父类的实现，即返回 YES 时，将父类的实现替换到我们自定义的 mrc_viewWillAppear 方法中。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@implementation</span> UIViewController (MRCUMAnalytics)</span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    <span class="selector-tag">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        Class class = <span class="selector-attr">[self class]</span>;</span><br><span class="line"></span><br><span class="line">        SEL originalSelector = <span class="variable">@selector</span>(<span class="attribute">viewWillAppear</span>:);</span><br><span class="line">        SEL swizzledSelector = <span class="variable">@selector</span>(<span class="attribute">mrc_viewWillAppear</span>:);</span><br><span class="line"></span><br><span class="line">        Method originalMethod = class_getInstanceMethod(class, originalSelector);</span><br><span class="line">        Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);</span><br><span class="line"></span><br><span class="line">        BOOL success = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));</span><br><span class="line">        <span class="selector-tag">if</span> (success) &#123;</span><br><span class="line">            class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#pragma</span> <span class="selector-tag">mark</span> <span class="selector-tag">-</span> <span class="selector-tag">Method</span> <span class="selector-tag">Swizzling</span></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">mrc_viewWillAppear</span><span class="selector-pseudo">:(BOOL)animated</span> &#123;</span><br><span class="line">    <span class="selector-attr">[self mrc_viewWillAppear:animated]</span>;</span><br><span class="line">    <span class="selector-attr">[MobClick beginLogPageView:NSStringFromClass([self class]</span>)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure></p>
<h1 id="Day-6-Objective-C-Autorelease-Pool-的实现原理"><a href="#Day-6-Objective-C-Autorelease-Pool-的实现原理" class="headerlink" title="# Day 6 : Objective-C Autorelease Pool 的实现原理"></a># Day 6 : <a href="http://blog.leichunfeng.com/blog/2015/05/31/objective-c-autorelease-pool-implementation-principle/" target="_blank" rel="external">Objective-C Autorelease Pool 的实现原理</a></h1><p>由 <a href="http://blog.leichunfeng.com/" target="_blank" rel="external">雷纯锋的技术博客</a> 发布</p>
<p>##1、autoreleased 对象的释放时机<br>对象 A 被创建时引用计数为 1，当有变量 B 指向这个对象时，引用计数 +1，变量 B 离开作用域后为 nil，对象 A 的引用计数 -1，当对象 A 所在的 autoreleasepool 被 drain ，其中的 autoreleased 对象被 release ，对象 A 的引用计数 -1。当对象 A 的引用计数为 0 时随即被释放。</p>
<p>其中提到了 <code>__weak</code> 的两个特性：<br>– <code>__weak</code> 变量不会影响所指向对象的生命周期<br>– <code>__weak</code> 变量所指向的对象被释放时，<code>__weak</code> 变量的值会被置为 <code>nil</code></p>
<p>##2、AutoreleasePoolPage<br>– 介绍了 AutoreleasePoolPage 的内存结构<br>– Autorelease Pool Blocks 通过 <code>clang -rewrite-objc</code> 改写成 c++ 代码的实现，和其中的 push 操作、autorelease 操作、pop 操作</p>
<p>##3、NSThread、NSRunLoop 和 NSAutoreleasePool</p>
<blockquote>
<p>Each NSThread object, including the application’s main thread, has an NSRunLoop object automatically created for it as needed.</p>
<p>The Application Kit creates an autorelease pool on the main thread at the beginning of every cycle of the event loop, and drains it at the end, thereby releasing any autoreleased objects generated while processing an event.</p>
<p>Each thread (including the main thread) maintains its own stack of NSAutoreleasePool objects.</p>
</blockquote>
<h1 id="Day-5-Objective-C-Associated-Objects-的实现原理"><a href="#Day-5-Objective-C-Associated-Objects-的实现原理" class="headerlink" title="# Day 5 : Objective-C Associated Objects 的实现原理"></a># Day 5 : <a href="http://blog.leichunfeng.com/blog/2015/06/26/objective-c-associated-objects-implementation-principle/" target="_blank" rel="external">Objective-C Associated Objects 的实现原理</a></h1><p>由 <a href="http://blog.leichunfeng.com/" target="_blank" rel="external">雷纯锋的技术博客</a> 发布</p>
<p>##1、相关函数<br>在 Objective-C 中可以通过 Category 给一个现有的类添加属性，但是却不能添加实例变量，我们可以通过 Associated Objects 来弥补这一不足<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_setAssociatedObject</span>(<span class="params">id <span class="keyword">object</span>, <span class="keyword">const</span> <span class="keyword">void</span> *key, id <span class="keyword">value</span>, objc_AssociationPolicy policy</span>)</span>; <span class="comment">// 用于给对象添加关联对象，传入 nil 则可以移除已有的关联对象</span></span><br><span class="line"><span class="function">id <span class="title">objc_getAssociatedObject</span>(<span class="params">id <span class="keyword">object</span>, <span class="keyword">const</span> <span class="keyword">void</span> *key</span>)</span>; <span class="comment">// 用于获取关联对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_removeAssociatedObjects</span>(<span class="params">id <span class="keyword">object</span></span>)</span>; <span class="comment">// 用于移除一个对象的所有关联对象</span></span><br></pre></td></tr></table></figure></p>
<p>##2、key 值<br>上边前两个函数需要传入一个 <code>key</code> 作为唯一变量，作者推荐 <code>selector</code> ，使用 <code>getter</code> 方法的名称作为 key 值。这样就省掉了一个变量名，解决了给这个 key 命名的烦恼。</p>
<p>##3、关联策略  </p>
<table>
<thead>
<tr>
<th>关联策略</th>
<th>等价属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>OBJC_ASSOCIATION_ASSIGN</td>
<td>@property (assign) or @property (unsafe_unretained)</td>
<td>弱引用关联对象</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_RETAIN_NONATOMIC</td>
<td>@property (strong, nonatomic)</td>
<td>强引用关联对象，且为非原子操作</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_COPY_NONATOMIC</td>
<td>@property (copy, nonatomic)</td>
<td>复制关联对象，且为非原子操作</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_RETAIN</td>
<td>@property (strong, atomic)</td>
<td>强引用关联对象，且为原子操作</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_COPY</td>
<td>@property (copy, atomic)</td>
<td>复制关联对象，且为原子操作</td>
</tr>
</tbody>
</table>
<p>##4、实现 getter setter 方法<br>ViewController+AssociatedObjects.h：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> ViewController (AssociatedObjects)</span><br><span class="line"><span class="variable">@property</span> (nonatomic, copy) NSString *associatedObject_copy;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure></p>
<p>ViewController+AssociatedObjects.m：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@implementation</span> ViewController (AssociatedObjects)</span><br><span class="line">- (NSString *)associatedObject_copy &#123;</span><br><span class="line">    return objc_getAssociatedObject(self, _cmd);</span><br><span class="line">&#125;</span><br><span class="line">- (void)<span class="attribute">setAssociatedObject_copy</span>:(NSString *)associatedObject_copy &#123;</span><br><span class="line">    objc_setAssociatedObject(self, <span class="variable">@selector</span>(associatedObject_copy), associatedObject_copy, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure></p>
<p>##5、总结<br>– 关联对象与被关联对象本身的存储并没有直接的关系，它是存储在单独的哈希表中的；<br>– 关联对象的五种关联策略与属性的限定符非常类似，在绝大多数情况下，我们都会使用 OBJC_ASSOCIATION_RETAIN_NONATOMIC 的关联策略，这可以保证我们持有关联对象；<br>– 关联对象的释放时机与移除时机并不总是一致，比如实验中用关联策略 OBJC_ASSOCIATION_ASSIGN 进行关联的对象，很早就已经被释放了，但是并没有被移除，而再使用这个关联对象时就会造成 Crash 。</p>
<h1 id="Day-4-Objective-C-load-vs-initialize"><a href="#Day-4-Objective-C-load-vs-initialize" class="headerlink" title="# Day 4 : Objective-C +load vs +initialize"></a># Day 4 : <a href="http://blog.leichunfeng.com/blog/2015/05/02/objective-c-plus-load-vs-plus-initialize/" target="_blank" rel="external">Objective-C +load vs +initialize</a></h1><p>由 <a href="http://blog.leichunfeng.com/" target="_blank" rel="external">雷纯锋的技术博客</a> 发布</p>
<p>##1、+load<br>– 调用所有类的 +load 方法（包括分类的 +load 方法）是直接使用函数内存地址的方式 <code>(*load_method)(cls, SEL_load);</code> 进行调用的，而不是使用发送消息 <code>objc_msgSend</code> 的方式。也就是说如果子类没有实现 +load 方法，那么当它被加载时 runtime 是不会去调用父类的 +load 方法的。同理，当一个类和它的分类都实现了 +load 方法时，两个方法都会被调用。<br>– 子类的 +load 方法会在它的所有父类的 +load 方法之后执行，而分类的 +load 方法会在它的主类的 +load 方法之后执行。但是不同的类之间的 +load 方法的调用顺序是不确定的。</p>
<p>##2、+initialize<br>– runtime 使用了发送消息 <code>objc_msgSend</code> 的方式对 +initialize 方法进行调用。如果子类没有实现 +initialize 方法，那么继承自父类的实现会被调用；如果一个类的分类实现了 +initialize 方法，那么就会对这个类中的实现造成覆盖。<br>– 如果一个子类没有实现 +initialize 方法，那么父类的实现是会被执行多次的。可以使用下面的代码确保自己的 +initialize 方法只执行一次：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)initialize &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">self</span> == [ClassName <span class="keyword">self</span>]) &#123;</span><br><span class="line">    <span class="comment">// ... do the initialization ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>##3、总结</p>
<table>
<thead>
<tr>
<th></th>
<th>+load</th>
<th>+initialize</th>
</tr>
</thead>
<tbody>
<tr>
<td>调用时机</td>
<td>被添加到 runtime 时</td>
<td>收到第一条消息前，可能永远不调用</td>
</tr>
<tr>
<td>调用顺序</td>
<td>父类-&gt;子类-&gt;分类</td>
<td>父类-&gt;子类</td>
</tr>
<tr>
<td>调用次数</td>
<td>1次</td>
<td>多次</td>
</tr>
<tr>
<td>是否需要显式调用父类实现</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>是否沿用父类的实现</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>分类中的实现</td>
<td>类和分类都执行</td>
<td>覆盖类中的方法，只执行分类的实现</td>
</tr>
</tbody>
</table>
<h1 id="Day-3-Objective-C对象模型及应用"><a href="#Day-3-Objective-C对象模型及应用" class="headerlink" title="# Day 3 : Objective-C对象模型及应用"></a># Day 3 : <a href="http://blog.devtang.com/2013/10/15/objective-c-object-model/" target="_blank" rel="external">Objective-C对象模型及应用</a></h1><p>由 <a href="http://blog.devtang.com/" target="_blank" rel="external">唐巧的博客</a> 发布</p>
<p>##1、ISA 指针<br>– 每一个对象都有一个名为 isa 的指针，指向该对象的类。<br>– 在 Objective-C 语言中，每一个类实际上也是一个对象，每一个类也有一个名为 isa 的指针，指向该类的元类。<br>– 元类的 isa 指针指向根元类。<br>– 根元类的 isa 指针指向自己。    </p>
<p>（文章中有一张图直白的说明了 isa 指针的指向）</p>
<p>##2、Method Swizzling API 说明<br>– <code>class_replaceMethod</code>, 当需要替换的方法可能有不存在的情况时，可以考虑使用该方法。<br>– <code>method_exchangeImplementations</code>，当需要交换 2 个方法的实现时使用。<br>– <code>method_setImplementation</code> 最简单的用法，当仅仅需要为一个方法设置其实现方式时使用。</p>
<h1 id="Day-2-谈Objective-C-block的实现"><a href="#Day-2-谈Objective-C-block的实现" class="headerlink" title="# Day 2 : 谈Objective-C block的实现"></a># Day 2 : <a href="http://blog.devtang.com/2013/07/28/a-look-inside-blocks/" target="_blank" rel="external">谈Objective-C block的实现</a></h1><p>由 <a href="http://blog.devtang.com/" target="_blank" rel="external">唐巧的博客</a> 发布</p>
<p>##1、block 的 struct 结构：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Block_descriptor &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> reserved;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line">    <span class="keyword">void</span> (*copy)(<span class="keyword">void</span> *dst, <span class="keyword">void</span> *src);</span><br><span class="line">    <span class="keyword">void</span> (*dispose)(<span class="keyword">void</span> *);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Block_layout &#123;</span><br><span class="line">    <span class="keyword">void</span> *isa; <span class="comment">// 所有对象都有该指针，用于实现对象相关的功能。</span></span><br><span class="line">    <span class="keyword">int</span> flags; <span class="comment">// 用于按 bit 位表示一些 block 的附加信息，本文后面介绍 block copy 的实现代码可以看到对该变量的使用。</span></span><br><span class="line">    <span class="keyword">int</span> reserved; <span class="comment">// 保留变量。</span></span><br><span class="line">    <span class="keyword">void</span> (*invoke)(<span class="keyword">void</span> *, ...); <span class="comment">// 函数指针，指向具体的 block 实现的函数调用地址。</span></span><br><span class="line">    <span class="keyword">struct</span> Block_descriptor *descriptor; <span class="comment">// 表示该 block 的附加描述信息，主要是 size 大小，以及 copy 和 dispose 函数的指针。</span></span><br><span class="line">    <span class="comment">/* Imported variables. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>##2、clang 命令改写 OC 语言下的 block<br>使用 clang 的 <code>clang -rewrite-objc block.c</code> 命令，可以将 Objetive-C 的源码改写成 c 语言的，生成的 .cpp 文件中有许多关键代码展示了 block 的实现原理。    </p>
<p>其中，block 中操作未经 <code>__block</code> 修饰的外部变量时，.cpp 文件中相关代码为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  <span class="keyword">int</span> a = __cself-&gt;a; <span class="comment">// bound by copy</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>block 中操作经 <code>__block</code> 修饰的外部变量时，.cpp 文件中相关代码为：<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  __B<span class="function"><span class="title">lock_byref_a_0</span> *a = __cself-&gt;</span>a; <span class="comment">// bound by ref</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">printf</span>("%d\n", (a-&gt;</span>__<span class="function"><span class="title">forwarding</span>-&gt;</span>a));</span><br><span class="line">        (<span class="function"><span class="title">a</span>-&gt;</span>__<span class="function"><span class="title">forwarding</span>-&gt;</span>a) = <span class="number">1023</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>结论：<br>1、在 block 内部修改变量 a 的内容，不会影响外部的实际变量 a，是因为在 block 内部 copy 了一份变量 a。<br>2、当变量使用 __block 修饰时，block 内部是引用的外部变量的指针，所以可以修改外部的实际变量 a。</p>
<h1 id="Day-1-深入理解Objective-C：Category"><a href="#Day-1-深入理解Objective-C：Category" class="headerlink" title="# Day 1 : 深入理解Objective-C：Category"></a># Day 1 : <a href="https://tech.meituan.com/DiveIntoCategory.html" target="_blank" rel="external">深入理解Objective-C：Category</a></h1><p>由 <a href="https://tech.meituan.com/" target="_blank" rel="external">美团点评技术团队</a> 发布</p>
<p>##1、category 在 runtime 层用结构体 category_t 定义：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="keyword">category_t</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">// 类的名字</span></span><br><span class="line">    <span class="keyword">classref_t</span> cls; <span class="comment">// 类</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="keyword">method_list_t</span> *instanceMethods; <span class="comment">// category中所有给类添加的实例方法的列表</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="keyword">method_list_t</span> *classMethods; <span class="comment">// category中所有添加的类方法的列表</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="keyword">protocol_list_t</span> *protocols; <span class="comment">// category实现的所有协议的列表</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="keyword">property_list_t</span> *instanceProperties; <span class="comment">// category中添加的所有属性</span></span><br><span class="line">&#125; <span class="keyword">category_t</span>;</span><br></pre></td></tr></table></figure></p>
<p>由该结构体可以看出 category 可以动态的添加实例方法，类方法，甚至可以实现协议，添加属性，但无法添加实例变量<br>因为无法添加实例变量，所以当采用 category 为类添加属性时，并不会自动生成带有 <code>_</code> 的实例变量，所以 <code>setter</code> 和 <code>getter</code> 方法也需要自己去实现，在文章末尾有介绍采用关联对象来实现，使用 <code>objc_setAssociatedObject</code> 和 <code>objc_getAssociatedObject</code> 方法。</p>
<p>##2、category 替换原来类已有的方法<br>category 的方法被放到了新方法列表的前面，而原来类的方法被放到了新方法列表的后面，运行时在查找方法的时候是顺着方法列表的顺序查找的，它只要一找到对应名字的方法，就会罢休。<br>所以，category 的方法没有“完全替换掉”原来类已经有的方法。在文章第六节也有介绍可以使用 <code>class_copyMethodList</code> 方法获取方法列表，顺着方法列表找到最后一个对应名字的方法，就可以调用原来类的方法</p>
<p>##3、-category 和 +load 方法<br>在类的 +load 方法调用的时候，我们可以调用 category 中声明的方法，因为附加 category 到类的工作会先于 +load 方法的执行<br>+load 的执行顺序是先类，后 category，而 category 的 +load 执行顺序是根据编译顺序决定的（Compile Sources（4 items）里的顺序）</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><ul>
<li><p>小白出手，请多指教。如言有误，还望斧正！</p>
</li>
<li><p>转载请保留原文地址：<a href="http://gonghonglou.com/2017/08/09/100days-100blogs">http://gonghonglou.com/2017/08/09/100days-100blogs</a></p>
</li>
</ul>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/07/29/qinghaihu-cycling/" rel="next" title="记环青海湖骑行">
                <i class="fa fa-chevron-left"></i> 记环青海湖骑行
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div id="sidebar-dimmer"></div>
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="与佳期" />
          <p class="site-author-name" itemprop="name">与佳期</p>
           
              <p class="site-description motion-element" itemprop="description">登白薠兮骋望，与佳期兮夕张。</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/gonghonglou" target="_blank" title="weibo">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://github.com/gonghonglou" target="_blank" title="github">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  github
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/gonghonglou" target="_blank" title="twitter">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  twitter
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#持续更新中……"><span class="nav-number">1.</span> <span class="nav-text"># 持续更新中……</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-19-IP，TCP-和-HTTP"><span class="nav-number">2.</span> <span class="nav-text"># Day 19 : IP，TCP 和 HTTP</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-18-基础集合类"><span class="nav-number">3.</span> <span class="nav-text"># Day 18 : 基础集合类</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-17-Build-过程"><span class="nav-number">4.</span> <span class="nav-text"># Day 17 : Build 过程</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-16-自定义控件"><span class="nav-number">5.</span> <span class="nav-text"># Day 16 : 自定义控件</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-15-底层并发-API"><span class="nav-number">6.</span> <span class="nav-text"># Day 15 : 底层并发 API</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-14-常见的后台实践"><span class="nav-number">7.</span> <span class="nav-text"># Day 14 : 常见的后台实践</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-13-并发编程：API-及挑战"><span class="nav-number">8.</span> <span class="nav-text"># Day 13 : 并发编程：API 及挑战</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-12-理解-Scroll-Views"><span class="nav-number">9.</span> <span class="nav-text"># Day 12 : 理解 Scroll Views</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-11-绘制像素到屏幕上"><span class="nav-number">10.</span> <span class="nav-text"># Day 11 : 绘制像素到屏幕上</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-10-谈谈-iOS-中图片的解压缩"><span class="nav-number">11.</span> <span class="nav-text"># Day 10 : 谈谈 iOS 中图片的解压缩</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-9-Objective-C-Fast-Enumeration-的实现原理"><span class="nav-number">12.</span> <span class="nav-text"># Day 9 : Objective-C Fast Enumeration 的实现原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-8-iOS-并发编程之-Operation-Queues"><span class="nav-number">13.</span> <span class="nav-text"># Day 8 : iOS 并发编程之 Operation Queues</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-7-Objective-C-Method-Swizzling-的最佳实践"><span class="nav-number">14.</span> <span class="nav-text"># Day 7 : Objective-C Method Swizzling 的最佳实践</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-6-Objective-C-Autorelease-Pool-的实现原理"><span class="nav-number">15.</span> <span class="nav-text"># Day 6 : Objective-C Autorelease Pool 的实现原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-5-Objective-C-Associated-Objects-的实现原理"><span class="nav-number">16.</span> <span class="nav-text"># Day 5 : Objective-C Associated Objects 的实现原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-4-Objective-C-load-vs-initialize"><span class="nav-number">17.</span> <span class="nav-text"># Day 4 : Objective-C +load vs +initialize</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-3-Objective-C对象模型及应用"><span class="nav-number">18.</span> <span class="nav-text"># Day 3 : Objective-C对象模型及应用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-2-谈Objective-C-block的实现"><span class="nav-number">19.</span> <span class="nav-text"># Day 2 : 谈Objective-C block的实现</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-1-深入理解Objective-C：Category"><span class="nav-number">20.</span> <span class="nav-text"># Day 1 : 深入理解Objective-C：Category</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#后记"><span class="nav-number">21.</span> <span class="nav-text">后记</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">与佳期</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  

    
      <script id="dsq-count-scr" src="https://gonghonglou.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://gonghonglou.com/2017/08/09/100days-100blogs/';
          this.page.identifier = '2017/08/09/100days-100blogs/';
          this.page.title = '100 Days, 100 Blogs';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://gonghonglou.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  








  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

</body>
</html>
