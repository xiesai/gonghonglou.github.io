<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="与佳期的个人博客" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="一直以来都活跃在微博、简书等各大网站搜罗技术博客，每当看到大牛发布或者转发技术博客都会点进去搂一眼，内容比较好或者比较感兴趣的话就会转发收藏。但这些都是零零碎碎的，大多时候都是路上、睡觉前或者什么间隙看到一篇好文章，简单看一下就收藏了，当时来不及 想着以后细读，但往往是在这之后基本上不会再次翻阅了。所以计划从今天起每天仔细阅读一篇技术博客，在这里做一做笔记。
微博每日打卡：#100days,100">
<meta property="og:type" content="article">
<meta property="og:title" content="100 Days, 100 Blogs">
<meta property="og:url" content="http://gonghonglou.com/2017/08/09/100days-100blogs/index.html">
<meta property="og:site_name" content="与佳期的个人博客">
<meta property="og:description" content="一直以来都活跃在微博、简书等各大网站搜罗技术博客，每当看到大牛发布或者转发技术博客都会点进去搂一眼，内容比较好或者比较感兴趣的话就会转发收藏。但这些都是零零碎碎的，大多时候都是路上、睡觉前或者什么间隙看到一篇好文章，简单看一下就收藏了，当时来不及 想着以后细读，但往往是在这之后基本上不会再次翻阅了。所以计划从今天起每天仔细阅读一篇技术博客，在这里做一做笔记。
微博每日打卡：#100days,100">
<meta property="og:updated_time" content="2017-08-17T08:46:51.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="100 Days, 100 Blogs">
<meta name="twitter:description" content="一直以来都活跃在微博、简书等各大网站搜罗技术博客，每当看到大牛发布或者转发技术博客都会点进去搂一眼，内容比较好或者比较感兴趣的话就会转发收藏。但这些都是零零碎碎的，大多时候都是路上、睡觉前或者什么间隙看到一篇好文章，简单看一下就收藏了，当时来不及 想着以后细读，但往往是在这之后基本上不会再次翻阅了。所以计划从今天起每天仔细阅读一篇技术博客，在这里做一做笔记。
微博每日打卡：#100days,100">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"hide","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://gonghonglou.com/2017/08/09/100days-100blogs/"/>





  <title>100 Days, 100 Blogs | 与佳期的个人博客</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">与佳期的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">登白薠兮骋望，与佳期兮夕张。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://gonghonglou.com/2017/08/09/100days-100blogs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="与佳期">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="与佳期的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">100 Days, 100 Blogs</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-09T11:57:11+08:00">
                2017-08-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/08/09/100days-100blogs/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/08/09/100days-100blogs/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>一直以来都活跃在微博、简书等各大网站搜罗技术博客，每当看到大牛发布或者转发技术博客都会点进去搂一眼，内容比较好或者比较感兴趣的话就会转发收藏。<br>但这些都是零零碎碎的，大多时候都是路上、睡觉前或者什么间隙看到一篇好文章，简单看一下就收藏了，当时来不及 想着以后细读，但往往是在这之后基本上不会再次翻阅了。所以计划从今天起每天仔细阅读一篇技术博客，在这里做一做笔记。</p>
<p>微博每日打卡：<a href="https://weibo.com/p/100808e7a8991364ef294db915427e9aeb2a7e" target="_blank" rel="external">#100days,100blogs#</a></p>
<h1 id="持续更新中……"><a href="#持续更新中……" class="headerlink" title="# 持续更新中……"></a># 持续更新中……</h1><h1 id="Day-9-Objective-C-Fast-Enumeration-的实现原理"><a href="#Day-9-Objective-C-Fast-Enumeration-的实现原理" class="headerlink" title="# Day 9 : Objective-C Fast Enumeration 的实现原理"></a># Day 9 : <a href="http://blog.leichunfeng.com/blog/2016/06/20/objective-c-fast-enumeration-implementation-principle/" target="_blank" rel="external">Objective-C Fast Enumeration 的实现原理</a></h1><p>由 <a href="http://blog.leichunfeng.com/" target="_blank" rel="external">雷纯锋的技术博客</a> 发布</p>
<p>##1、解析 NSFastEnumeration 协议<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> Returns <span class="keyword">by</span> <span class="keyword">reference</span> a C array <span class="keyword">of</span> objects <span class="keyword">over</span> which <span class="keyword">the</span> sender should iterate, <span class="keyword">and</span> <span class="keyword">as</span> <span class="keyword">the</span> <span class="literal">return</span> value <span class="keyword">the</span> <span class="built_in">number</span> <span class="keyword">of</span> objects <span class="keyword">in</span> <span class="keyword">the</span> array.</span><br><span class="line"></span><br><span class="line"> @param state  Context information <span class="keyword">that</span> <span class="keyword">is</span> used <span class="keyword">in</span> <span class="keyword">the</span> enumeration <span class="keyword">to</span>, <span class="keyword">in</span> addition <span class="keyword">to</span> other possibilities, ensure <span class="keyword">that</span> <span class="keyword">the</span> collection has <span class="keyword">not</span> been mutated.</span><br><span class="line"> @param buffer A C array <span class="keyword">of</span> objects <span class="keyword">over</span> which <span class="keyword">the</span> sender <span class="keyword">is</span> <span class="keyword">to</span> iterate.</span><br><span class="line"> @param len    The maximum <span class="built_in">number</span> <span class="keyword">of</span> objects <span class="keyword">to</span> <span class="literal">return</span> <span class="keyword">in</span> stackbuf.</span><br><span class="line"> </span><br><span class="line"> @discussion The state structure <span class="keyword">is</span> assumed <span class="keyword">to</span> be <span class="keyword">of</span> stack <span class="keyword">local</span> memory, so you can recast <span class="keyword">the</span> passed <span class="keyword">in</span> state structure <span class="keyword">to</span> one more suitable <span class="keyword">for</span> your iteration.</span><br><span class="line"></span><br><span class="line"> @<span class="literal">return</span> The <span class="built_in">number</span> <span class="keyword">of</span> objects returned <span class="keyword">in</span> stackbuf. Returns <span class="number">0</span> when <span class="keyword">the</span> iteration <span class="keyword">is</span> finished.</span><br><span class="line"> */</span><br><span class="line">- (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state</span><br><span class="line">                                  objects:(<span class="built_in">id</span> __unsafe_unretained [])stackbuf</span><br><span class="line">                                    <span class="built_in">count</span>:(NSUInteger)len</span><br></pre></td></tr></table></figure></p>
<p>结构体 NSFastEnumerationState 的定义:<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> state;</span><br><span class="line">    <span class="keyword">id</span> __unsafe_unretained _Nullable * _Nullable itemsPtr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> * _Nullable mutationsPtr;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> extra[<span class="number">5</span>];</span><br><span class="line">&#125; <span class="built_in">NSFastEnumerationState</span>;</span><br></pre></td></tr></table></figure></p>
<p>##2、快速枚举的内部实现<br>通过 <code>clang -rewrite-objc main.m</code> 命令重写了一段 OC 的快速枚举代码，详尽的注释介绍了快速枚举的内部实现，及在 <code>for/in</code> 语句中利用 goto 实现 <code>continue</code> 和 <code>break</code> 命令的 c++ 代码。</p>
<p>##3、实现 NSFastEnumeration 协议<br>作者给出了一个实现 <code>- (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state objects:(id __unsafe_unretained [])stackbuf count:(NSUInteger)len;</code> 的例子</p>
<p>##3、参考链接<br>在文末的参考链接中有文 <a href="https://www.mikeash.com/pyblog/friday-qa-2010-04-16-implementing-fast-enumeration.html" target="_blank" rel="external">Friday Q&amp;A 2010-04-16: Implementing Fast Enumeration</a> 同样介绍了快速枚举的实现。</p>
<h1 id="Day-8-iOS-并发编程之-Operation-Queues"><a href="#Day-8-iOS-并发编程之-Operation-Queues" class="headerlink" title="# Day 8 : iOS 并发编程之 Operation Queues"></a># Day 8 : <a href="http://blog.leichunfeng.com/blog/2015/07/29/ios-concurrency-programming-operation-queues/" target="_blank" rel="external">iOS 并发编程之 Operation Queues</a></h1><p>由 <a href="http://blog.leichunfeng.com/" target="_blank" rel="external">雷纯锋的技术博客</a> 发布</p>
<p>这篇文章比较长，且相当详细，很多也是 Operation Queues 的基础用法，所以这里就只将文章目录记下来好了，下次复习（的话）先来过一遍目录，记不起的再去查阅文章吧。<br>该篇文章详细介绍了 Operation Queues 的一系列使用，并且 SDWebImage 也用到了 Operation Queues，对于不久后去阅读 SDWebImage 源码想必会很有帮助。</p>
<p>##1、基本概念<br>– 进程（process）、线程（thread）、任务（task）<br>– 串行 vs. 并发<br>– 同步 vs. 异步<br>– 队列 vs. 线程的概念。</p>
<p>##2、iOS 的并发编程模型    </p>
<p>##3、Operation Queues vs. Grand Central Dispatch (GCD)</p>
<p>##4、关于 Operation 对象<br>– 并发 vs. 非并发 Operation<br>– 创建 NSInvocationOperation 对象<br>– 创建 NSBlockOperation 对象</p>
<p>##5、自定义 Operation 对象<br>– 执行主任务<br>– 响应取消事件<br>– 配置并发执行的 Operation<br>– 维护 KVO 通知</p>
<p>##6、定制 Operation 对象的执行行为<br>– 配置依赖关系<br>– 修改 Operation 在队列中的优先级<br>– 修改 Operation 执行任务线程的优先级<br>– 设置 Completion Block</p>
<p>##7、执行 Operation 对象<br>– 添加 Operation 到 Operation Queue 中<br>– 手动执行 Operation<br>– 取消 Operation<br>– 等待 Operation 执行完成<br>– 暂停和恢复 Operation Queue</p>
<p>##8、总结</p>
<h1 id="Day-7-Objective-C-Method-Swizzling-的最佳实践"><a href="#Day-7-Objective-C-Method-Swizzling-的最佳实践" class="headerlink" title="# Day 7 : Objective-C Method Swizzling 的最佳实践"></a># Day 7 : <a href="http://blog.leichunfeng.com/blog/2015/06/14/objective-c-method-swizzling-best-practice/" target="_blank" rel="external">Objective-C Method Swizzling 的最佳实践</a></h1><p>由 <a href="http://blog.leichunfeng.com/" target="_blank" rel="external">雷纯锋的技术博客</a> 发布</p>
<p>##1、Method 的数据结构：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="keyword">method_t</span> &#123;</span><br><span class="line">    SEL name; <span class="comment">// 方法的名称，用于唯一标识某个方法，比如 @selector(viewWillAppear:)</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *types; <span class="comment">// 方法的返回值和参数类型</span></span><br><span class="line">    IMP imp; <span class="comment">// 函数指针，指向方法的实现</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">struct</span> SortBySELAddress :</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">std</span>::binary_function&lt;<span class="keyword">const</span> <span class="keyword">method_t</span>&amp;,</span><br><span class="line">                                    <span class="keyword">const</span> <span class="keyword">method_t</span>&amp;, <span class="keyword">bool</span>&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">const</span> <span class="keyword">method_t</span>&amp; lhs,</span><br><span class="line">                         <span class="keyword">const</span> <span class="keyword">method_t</span>&amp; rhs)</span></span><br><span class="line">        </span>&#123; <span class="keyword">return</span> lhs.name &lt; rhs.name; &#125;</span><br><span class="line">    &#125;; <span class="comment">// 一个根据 name 的地址对方法进行排序的函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>– 实例方法保存在类对象中，类方法保存在元类对象中。（参见<a href="http://blog.leichunfeng.com/blog/2015/04/25/objective-c-object-model/" target="_blank" rel="external">Objective-C 对象模型</a>）<br>– 原则上，方法的名称 name 和方法的实现 imp 是一一对应的，而 Method Swizzling 的原理就是动态地改变它们的对应关系，以达到替换方法实现的目的。</p>
<p>##2、Method Swizzling 的最佳实践<br>+load 和 +initialize 是 Objective-C runtime 会自动调用的两个类方法。<br>– +initialize 方法以懒加载的方式被调用的，有可能不会被调用，而 +load 方法是在类被加载的时候调用。<br>– Objective-C runtime 自动调用 +load 方法时，分类中的 +load 方法并不会对主类中的 +load 方法造成覆盖<br>综上，分类中的 +load 方法是实现 Method Swizzling 逻辑的最佳“场所”<br>– 应当使用 dispatch_once 保证 Method Swizzling 只被调用一次</p>
<p>文章示例代码：<br>– 主类本身有实现需要替换的方法，即返回 NO 时，直接交换两个方法的实现；<br>– 主类本身没有实现需要替换的方法，而是继承了父类的实现，即返回 YES 时，将父类的实现替换到我们自定义的 mrc_viewWillAppear 方法中。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@implementation</span> UIViewController (MRCUMAnalytics)</span><br><span class="line">+ (void)load &#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    <span class="selector-tag">dispatch_once</span>(&amp;onceToken, ^&#123;</span><br><span class="line">        Class class = <span class="selector-attr">[self class]</span>;</span><br><span class="line"></span><br><span class="line">        SEL originalSelector = <span class="variable">@selector</span>(<span class="attribute">viewWillAppear</span>:);</span><br><span class="line">        SEL swizzledSelector = <span class="variable">@selector</span>(<span class="attribute">mrc_viewWillAppear</span>:);</span><br><span class="line"></span><br><span class="line">        Method originalMethod = class_getInstanceMethod(class, originalSelector);</span><br><span class="line">        Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);</span><br><span class="line"></span><br><span class="line">        BOOL success = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod));</span><br><span class="line">        <span class="selector-tag">if</span> (success) &#123;</span><br><span class="line">            class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            method_exchangeImplementations(originalMethod, swizzledMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#pragma</span> <span class="selector-tag">mark</span> <span class="selector-tag">-</span> <span class="selector-tag">Method</span> <span class="selector-tag">Swizzling</span></span><br><span class="line"><span class="selector-tag">-</span> (void)<span class="selector-tag">mrc_viewWillAppear</span><span class="selector-pseudo">:(BOOL)animated</span> &#123;</span><br><span class="line">    <span class="selector-attr">[self mrc_viewWillAppear:animated]</span>;</span><br><span class="line">    <span class="selector-attr">[MobClick beginLogPageView:NSStringFromClass([self class]</span>)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure></p>
<h1 id="Day-6-Objective-C-Autorelease-Pool-的实现原理"><a href="#Day-6-Objective-C-Autorelease-Pool-的实现原理" class="headerlink" title="# Day 6 : Objective-C Autorelease Pool 的实现原理"></a># Day 6 : <a href="http://blog.leichunfeng.com/blog/2015/05/31/objective-c-autorelease-pool-implementation-principle/" target="_blank" rel="external">Objective-C Autorelease Pool 的实现原理</a></h1><p>由 <a href="http://blog.leichunfeng.com/" target="_blank" rel="external">雷纯锋的技术博客</a> 发布</p>
<p>##1、autoreleased 对象的释放时机<br>对象 A 被创建时引用计数为 1，当有变量 B 指向这个对象时，引用计数 +1，变量 B 离开作用域后为 nil，对象 A 的引用计数 -1，当对象 A 所在的 autoreleasepool 被 drain ，其中的 autoreleased 对象被 release ，对象 A 的引用计数 -1。当对象 A 的引用计数为 0 时随即被释放。</p>
<p>其中提到了 <code>__weak</code> 的两个特性：<br>– <code>__weak</code> 变量不会影响所指向对象的生命周期<br>– <code>__weak</code> 变量所指向的对象被释放时，<code>__weak</code> 变量的值会被置为 <code>nil</code></p>
<p>##2、AutoreleasePoolPage<br>– 介绍了 AutoreleasePoolPage 的内存结构<br>– Autorelease Pool Blocks 通过 <code>clang -rewrite-objc</code> 改写成 c++ 代码的实现，和其中的 push 操作、autorelease 操作、pop 操作</p>
<p>##3、NSThread、NSRunLoop 和 NSAutoreleasePool</p>
<blockquote>
<p>Each NSThread object, including the application’s main thread, has an NSRunLoop object automatically created for it as needed.</p>
<p>The Application Kit creates an autorelease pool on the main thread at the beginning of every cycle of the event loop, and drains it at the end, thereby releasing any autoreleased objects generated while processing an event.</p>
<p>Each thread (including the main thread) maintains its own stack of NSAutoreleasePool objects.</p>
</blockquote>
<h1 id="Day-5-Objective-C-Associated-Objects-的实现原理"><a href="#Day-5-Objective-C-Associated-Objects-的实现原理" class="headerlink" title="# Day 5 : Objective-C Associated Objects 的实现原理"></a># Day 5 : <a href="http://blog.leichunfeng.com/blog/2015/06/26/objective-c-associated-objects-implementation-principle/" target="_blank" rel="external">Objective-C Associated Objects 的实现原理</a></h1><p>由 <a href="http://blog.leichunfeng.com/" target="_blank" rel="external">雷纯锋的技术博客</a> 发布</p>
<p>##1、相关函数<br>在 Objective-C 中可以通过 Category 给一个现有的类添加属性，但是却不能添加实例变量，我们可以通过 Associated Objects 来弥补这一不足<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_setAssociatedObject</span>(<span class="params">id <span class="keyword">object</span>, <span class="keyword">const</span> <span class="keyword">void</span> *key, id <span class="keyword">value</span>, objc_AssociationPolicy policy</span>)</span>; <span class="comment">// 用于给对象添加关联对象，传入 nil 则可以移除已有的关联对象</span></span><br><span class="line"><span class="function">id <span class="title">objc_getAssociatedObject</span>(<span class="params">id <span class="keyword">object</span>, <span class="keyword">const</span> <span class="keyword">void</span> *key</span>)</span>; <span class="comment">// 用于获取关联对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">objc_removeAssociatedObjects</span>(<span class="params">id <span class="keyword">object</span></span>)</span>; <span class="comment">// 用于移除一个对象的所有关联对象</span></span><br></pre></td></tr></table></figure></p>
<p>##2、key 值<br>上边前两个函数需要传入一个 <code>key</code> 作为唯一变量，作者推荐 <code>selector</code> ，使用 <code>getter</code> 方法的名称作为 key 值。这样就省掉了一个变量名，解决了给这个 key 命名的烦恼。</p>
<p>##3、关联策略  </p>
<table>
<thead>
<tr>
<th>关联策略</th>
<th>等价属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>OBJC_ASSOCIATION_ASSIGN</td>
<td>@property (assign) or @property (unsafe_unretained)</td>
<td>弱引用关联对象</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_RETAIN_NONATOMIC</td>
<td>@property (strong, nonatomic)</td>
<td>强引用关联对象，且为非原子操作</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_COPY_NONATOMIC</td>
<td>@property (copy, nonatomic)</td>
<td>复制关联对象，且为非原子操作</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_RETAIN</td>
<td>@property (strong, atomic)</td>
<td>强引用关联对象，且为原子操作</td>
</tr>
<tr>
<td>OBJC_ASSOCIATION_COPY</td>
<td>@property (copy, atomic)</td>
<td>复制关联对象，且为原子操作</td>
</tr>
</tbody>
</table>
<p>##4、实现 getter setter 方法<br>ViewController+AssociatedObjects.h：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@interface</span> ViewController (AssociatedObjects)</span><br><span class="line"><span class="variable">@property</span> (nonatomic, copy) NSString *associatedObject_copy;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure></p>
<p>ViewController+AssociatedObjects.m：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@implementation</span> ViewController (AssociatedObjects)</span><br><span class="line">- (NSString *)associatedObject_copy &#123;</span><br><span class="line">    return objc_getAssociatedObject(self, _cmd);</span><br><span class="line">&#125;</span><br><span class="line">- (void)<span class="attribute">setAssociatedObject_copy</span>:(NSString *)associatedObject_copy &#123;</span><br><span class="line">    objc_setAssociatedObject(self, <span class="variable">@selector</span>(associatedObject_copy), associatedObject_copy, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">@end</span></span><br></pre></td></tr></table></figure></p>
<p>##5、总结<br>– 关联对象与被关联对象本身的存储并没有直接的关系，它是存储在单独的哈希表中的；<br>– 关联对象的五种关联策略与属性的限定符非常类似，在绝大多数情况下，我们都会使用 OBJC_ASSOCIATION_RETAIN_NONATOMIC 的关联策略，这可以保证我们持有关联对象；<br>– 关联对象的释放时机与移除时机并不总是一致，比如实验中用关联策略 OBJC_ASSOCIATION_ASSIGN 进行关联的对象，很早就已经被释放了，但是并没有被移除，而再使用这个关联对象时就会造成 Crash 。</p>
<h1 id="Day-4-Objective-C-load-vs-initialize"><a href="#Day-4-Objective-C-load-vs-initialize" class="headerlink" title="# Day 4 : Objective-C +load vs +initialize"></a># Day 4 : <a href="http://blog.leichunfeng.com/blog/2015/05/02/objective-c-plus-load-vs-plus-initialize/" target="_blank" rel="external">Objective-C +load vs +initialize</a></h1><p>由 <a href="http://blog.leichunfeng.com/" target="_blank" rel="external">雷纯锋的技术博客</a> 发布</p>
<p>##1、+load<br>– 调用所有类的 +load 方法（包括分类的 +load 方法）是直接使用函数内存地址的方式 <code>(*load_method)(cls, SEL_load);</code> 进行调用的，而不是使用发送消息 <code>objc_msgSend</code> 的方式。也就是说如果子类没有实现 +load 方法，那么当它被加载时 runtime 是不会去调用父类的 +load 方法的。同理，当一个类和它的分类都实现了 +load 方法时，两个方法都会被调用。<br>– 子类的 +load 方法会在它的所有父类的 +load 方法之后执行，而分类的 +load 方法会在它的主类的 +load 方法之后执行。但是不同的类之间的 +load 方法的调用顺序是不确定的。</p>
<p>##2、+initialize<br>– runtime 使用了发送消息 <code>objc_msgSend</code> 的方式对 +initialize 方法进行调用。如果子类没有实现 +initialize 方法，那么继承自父类的实现会被调用；如果一个类的分类实现了 +initialize 方法，那么就会对这个类中的实现造成覆盖。<br>– 如果一个子类没有实现 +initialize 方法，那么父类的实现是会被执行多次的。可以使用下面的代码确保自己的 +initialize 方法只执行一次：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+ (<span class="keyword">void</span>)initialize &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">self</span> == [ClassName <span class="keyword">self</span>]) &#123;</span><br><span class="line">    <span class="comment">// ... do the initialization ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>##3、总结</p>
<table>
<thead>
<tr>
<th></th>
<th>+load</th>
<th>+initialize</th>
</tr>
</thead>
<tbody>
<tr>
<td>调用时机</td>
<td>被添加到 runtime 时</td>
<td>收到第一条消息前，可能永远不调用</td>
</tr>
<tr>
<td>调用顺序</td>
<td>父类-&gt;子类-&gt;分类</td>
<td>父类-&gt;子类</td>
</tr>
<tr>
<td>调用次数</td>
<td>1次</td>
<td>多次</td>
</tr>
<tr>
<td>是否需要显式调用父类实现</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>是否沿用父类的实现</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>分类中的实现</td>
<td>类和分类都执行</td>
<td>覆盖类中的方法，只执行分类的实现</td>
</tr>
</tbody>
</table>
<h1 id="Day-3-Objective-C对象模型及应用"><a href="#Day-3-Objective-C对象模型及应用" class="headerlink" title="# Day 3 : Objective-C对象模型及应用"></a># Day 3 : <a href="http://blog.devtang.com/2013/10/15/objective-c-object-model/" target="_blank" rel="external">Objective-C对象模型及应用</a></h1><p>由 <a href="http://blog.devtang.com/" target="_blank" rel="external">唐巧的博客</a> 发布</p>
<p>##1、ISA 指针<br>– 每一个对象都有一个名为 isa 的指针，指向该对象的类。<br>– 在 Objective-C 语言中，每一个类实际上也是一个对象，每一个类也有一个名为 isa 的指针，指向该类的元类。<br>– 元类的 isa 指针指向根元类。<br>– 根元类的 isa 指针指向自己。    </p>
<p>（文章中有一张图直白的说明了 isa 指针的指向）</p>
<p>##2、Method Swizzling API 说明<br>– <code>class_replaceMethod</code>, 当需要替换的方法可能有不存在的情况时，可以考虑使用该方法。<br>– <code>method_exchangeImplementations</code>，当需要交换 2 个方法的实现时使用。<br>– <code>method_setImplementation</code> 最简单的用法，当仅仅需要为一个方法设置其实现方式时使用。</p>
<h1 id="Day-2-谈Objective-C-block的实现"><a href="#Day-2-谈Objective-C-block的实现" class="headerlink" title="# Day 2 : 谈Objective-C block的实现"></a># Day 2 : <a href="http://blog.devtang.com/2013/07/28/a-look-inside-blocks/" target="_blank" rel="external">谈Objective-C block的实现</a></h1><p>由 <a href="http://blog.devtang.com/" target="_blank" rel="external">唐巧的博客</a> 发布</p>
<p>##1、block 的 struct 结构：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> Block_descriptor &#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> reserved;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="built_in">size</span>;</span><br><span class="line">    <span class="keyword">void</span> (*copy)(<span class="keyword">void</span> *dst, <span class="keyword">void</span> *src);</span><br><span class="line">    <span class="keyword">void</span> (*dispose)(<span class="keyword">void</span> *);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> Block_layout &#123;</span><br><span class="line">    <span class="keyword">void</span> *isa; <span class="comment">// 所有对象都有该指针，用于实现对象相关的功能。</span></span><br><span class="line">    <span class="keyword">int</span> flags; <span class="comment">// 用于按 bit 位表示一些 block 的附加信息，本文后面介绍 block copy 的实现代码可以看到对该变量的使用。</span></span><br><span class="line">    <span class="keyword">int</span> reserved; <span class="comment">// 保留变量。</span></span><br><span class="line">    <span class="keyword">void</span> (*invoke)(<span class="keyword">void</span> *, ...); <span class="comment">// 函数指针，指向具体的 block 实现的函数调用地址。</span></span><br><span class="line">    <span class="keyword">struct</span> Block_descriptor *descriptor; <span class="comment">// 表示该 block 的附加描述信息，主要是 size 大小，以及 copy 和 dispose 函数的指针。</span></span><br><span class="line">    <span class="comment">/* Imported variables. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>##2、clang 命令改写 OC 语言下的 block<br>使用 clang 的 <code>clang -rewrite-objc block.c</code> 命令，可以将 Objetive-C 的源码改写成 c 语言的，生成的 .cpp 文件中有许多关键代码展示了 block 的实现原理。    </p>
<p>其中，block 中操作未经 <code>__block</code> 修饰的外部变量时，.cpp 文件中相关代码为：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __main_block_func_0(<span class="keyword">struct</span> __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  <span class="keyword">int</span> a = __cself-&gt;a; <span class="comment">// bound by copy</span></span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, a);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>block 中操作经 <code>__block</code> 修饰的外部变量时，.cpp 文件中相关代码为：<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123;</span><br><span class="line">  __B<span class="function"><span class="title">lock_byref_a_0</span> *a = __cself-&gt;</span>a; <span class="comment">// bound by ref</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="title">printf</span>("%d\n", (a-&gt;</span>__<span class="function"><span class="title">forwarding</span>-&gt;</span>a));</span><br><span class="line">        (<span class="function"><span class="title">a</span>-&gt;</span>__<span class="function"><span class="title">forwarding</span>-&gt;</span>a) = <span class="number">1023</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>结论：<br>1、在 block 内部修改变量 a 的内容，不会影响外部的实际变量 a，是因为在 block 内部 copy 了一份变量 a。<br>2、当变量使用 __block 修饰时，block 内部是引用的外部变量的指针，所以可以修改外部的实际变量 a。</p>
<h1 id="Day-1-深入理解Objective-C：Category"><a href="#Day-1-深入理解Objective-C：Category" class="headerlink" title="# Day 1 : 深入理解Objective-C：Category"></a># Day 1 : <a href="https://tech.meituan.com/DiveIntoCategory.html" target="_blank" rel="external">深入理解Objective-C：Category</a></h1><p>由 <a href="https://tech.meituan.com/" target="_blank" rel="external">美团点评技术团队</a> 发布</p>
<p>##1、category 在 runtime 层用结构体 category_t 定义：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="keyword">category_t</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *name; <span class="comment">// 类的名字</span></span><br><span class="line">    <span class="keyword">classref_t</span> cls; <span class="comment">// 类</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="keyword">method_list_t</span> *instanceMethods; <span class="comment">// category中所有给类添加的实例方法的列表</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="keyword">method_list_t</span> *classMethods; <span class="comment">// category中所有添加的类方法的列表</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="keyword">protocol_list_t</span> *protocols; <span class="comment">// category实现的所有协议的列表</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="keyword">property_list_t</span> *instanceProperties; <span class="comment">// category中添加的所有属性</span></span><br><span class="line">&#125; <span class="keyword">category_t</span>;</span><br></pre></td></tr></table></figure></p>
<p>由该结构体可以看出 category 可以动态的添加实例方法，类方法，甚至可以实现协议，添加属性，但无法添加实例变量<br>因为无法添加实例变量，所以当采用 category 为类添加属性时，并不会自动生成带有 <code>_</code> 的实例变量，所以 <code>setter</code> 和 <code>getter</code> 方法也需要自己去实现，在文章末尾有介绍采用关联对象来实现，使用 <code>objc_setAssociatedObject</code> 和 <code>objc_getAssociatedObject</code> 方法。</p>
<p>##2、category 替换原来类已有的方法<br>category 的方法被放到了新方法列表的前面，而原来类的方法被放到了新方法列表的后面，运行时在查找方法的时候是顺着方法列表的顺序查找的，它只要一找到对应名字的方法，就会罢休。<br>所以，category 的方法没有“完全替换掉”原来类已经有的方法。在文章第六节也有介绍可以使用 <code>class_copyMethodList</code> 方法获取方法列表，顺着方法列表找到最后一个对应名字的方法，就可以调用原来类的方法</p>
<p>##3、-category 和 +load 方法<br>在类的 +load 方法调用的时候，我们可以调用 category 中声明的方法，因为附加 category 到类的工作会先于 +load 方法的执行<br>+load 的执行顺序是先类，后 category，而 category 的 +load 执行顺序是根据编译顺序决定的（Compile Sources（4 items）里的顺序）</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><ul>
<li><p>小白出手，请多指教。如言有误，还望斧正！</p>
</li>
<li><p>转载请保留原文地址：<a href="http://gonghonglou.com/2017/08/09/100days-100blogs">http://gonghonglou.com/2017/08/09/100days-100blogs</a></p>
</li>
</ul>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/07/29/qinghaihu-cycling/" rel="next" title="记环青海湖骑行">
                <i class="fa fa-chevron-left"></i> 记环青海湖骑行
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div id="sidebar-dimmer"></div>
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="与佳期" />
          <p class="site-author-name" itemprop="name">与佳期</p>
           
              <p class="site-description motion-element" itemprop="description">登白薠兮骋望，与佳期兮夕张。</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">16</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/gonghonglou" target="_blank" title="weibo">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://github.com/gonghonglou" target="_blank" title="github">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  github
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/gonghonglou" target="_blank" title="twitter">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  twitter
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#持续更新中……"><span class="nav-number">1.</span> <span class="nav-text"># 持续更新中……</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-9-Objective-C-Fast-Enumeration-的实现原理"><span class="nav-number">2.</span> <span class="nav-text"># Day 9 : Objective-C Fast Enumeration 的实现原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-8-iOS-并发编程之-Operation-Queues"><span class="nav-number">3.</span> <span class="nav-text"># Day 8 : iOS 并发编程之 Operation Queues</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-7-Objective-C-Method-Swizzling-的最佳实践"><span class="nav-number">4.</span> <span class="nav-text"># Day 7 : Objective-C Method Swizzling 的最佳实践</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-6-Objective-C-Autorelease-Pool-的实现原理"><span class="nav-number">5.</span> <span class="nav-text"># Day 6 : Objective-C Autorelease Pool 的实现原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-5-Objective-C-Associated-Objects-的实现原理"><span class="nav-number">6.</span> <span class="nav-text"># Day 5 : Objective-C Associated Objects 的实现原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-4-Objective-C-load-vs-initialize"><span class="nav-number">7.</span> <span class="nav-text"># Day 4 : Objective-C +load vs +initialize</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-3-Objective-C对象模型及应用"><span class="nav-number">8.</span> <span class="nav-text"># Day 3 : Objective-C对象模型及应用</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-2-谈Objective-C-block的实现"><span class="nav-number">9.</span> <span class="nav-text"># Day 2 : 谈Objective-C block的实现</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Day-1-深入理解Objective-C：Category"><span class="nav-number">10.</span> <span class="nav-text"># Day 1 : 深入理解Objective-C：Category</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#后记"><span class="nav-number">11.</span> <span class="nav-text">后记</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">与佳期</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  

    
      <script id="dsq-count-scr" src="https://gonghonglou.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://gonghonglou.com/2017/08/09/100days-100blogs/';
          this.page.identifier = '2017/08/09/100days-100blogs/';
          this.page.title = '100 Days, 100 Blogs';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://gonghonglou.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  








  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

</body>
</html>
