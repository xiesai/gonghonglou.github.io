<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="与佳期的个人博客" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta name="description" content="《Effective Objective-C 2.0（编写高质量iOS与OS X代码的52个有效方法）》这本书已经买了有一段时间了，一直没有时间读完，趁着这个十一在家没事终于读过了，顺便做一下读书笔记总结记录一下吧。
第 1 章：熟悉Objective-C第 1 条：了解Objective-C语言的起源要点：– Objective-C 为 C 语言添加了面向对象的特性，是其超集。Objective">
<meta property="og:type" content="article">
<meta property="og:title" content="Effective Objective-C 2.0 读书笔记">
<meta property="og:url" content="http://gonghonglou.com/2017/10/08/Effective-Objective-C-note/index.html">
<meta property="og:site_name" content="与佳期的个人博客">
<meta property="og:description" content="《Effective Objective-C 2.0（编写高质量iOS与OS X代码的52个有效方法）》这本书已经买了有一段时间了，一直没有时间读完，趁着这个十一在家没事终于读过了，顺便做一下读书笔记总结记录一下吧。
第 1 章：熟悉Objective-C第 1 条：了解Objective-C语言的起源要点：– Objective-C 为 C 语言添加了面向对象的特性，是其超集。Objective">
<meta property="og:updated_time" content="2017-10-28T13:38:57.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Effective Objective-C 2.0 读书笔记">
<meta name="twitter:description" content="《Effective Objective-C 2.0（编写高质量iOS与OS X代码的52个有效方法）》这本书已经买了有一段时间了，一直没有时间读完，趁着这个十一在家没事终于读过了，顺便做一下读书笔记总结记录一下吧。
第 1 章：熟悉Objective-C第 1 条：了解Objective-C语言的起源要点：– Objective-C 为 C 语言添加了面向对象的特性，是其超集。Objective">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"hide","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://gonghonglou.com/2017/10/08/Effective-Objective-C-note/"/>





  <title>Effective Objective-C 2.0 读书笔记 | 与佳期的个人博客</title>
  














</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">与佳期的个人博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">登白薠兮骋望，与佳期兮夕张。</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="搜索..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://gonghonglou.com/2017/10/08/Effective-Objective-C-note/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="与佳期">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="与佳期的个人博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Effective Objective-C 2.0 读书笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-08T11:50:33+08:00">
                2017-10-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/iOS/" itemprop="url" rel="index">
                    <span itemprop="name">iOS</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2017/10/08/Effective-Objective-C-note/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count"
                        data-disqus-identifier="2017/10/08/Effective-Objective-C-note/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>《Effective Objective-C 2.0（编写高质量iOS与OS X代码的52个有效方法）》这本书已经买了有一段时间了，一直没有时间读完，趁着这个十一在家没事终于读过了，顺便做一下读书笔记总结记录一下吧。</p>
<h1 id="第-1-章：熟悉Objective-C"><a href="#第-1-章：熟悉Objective-C" class="headerlink" title="第 1 章：熟悉Objective-C"></a>第 1 章：熟悉Objective-C</h1><h2 id="第-1-条：了解Objective-C语言的起源"><a href="#第-1-条：了解Objective-C语言的起源" class="headerlink" title="第 1 条：了解Objective-C语言的起源"></a>第 1 条：了解Objective-C语言的起源</h2><p>要点：<br>– Objective-C 为 C 语言添加了面向对象的特性，是其超集。Objective-C 使用动态绑定的消息结构，也就是说，在运行时才会去检查对象类型。接收一条消息之后，究竟应执行何种代码，由运行期环境而非编译器来决定。<br>– 理解 C 语言的核心概念有助于写好 Objective-C 程序。尤其要掌握内存模型与指针。</p>
<h2 id="第-2-条：在类的头文件中尽量少引入其他头文件"><a href="#第-2-条：在类的头文件中尽量少引入其他头文件" class="headerlink" title="第 2 条：在类的头文件中尽量少引入其他头文件"></a>第 2 条：在类的头文件中尽量少引入其他头文件</h2><p>要点：<br>– 除非确有必要，否则不要引入头文件。一般来说，应在某个类的头文件中使用向前声明来提及别的类，并在实现文件中引入那些类的头文件。这样做可以尽量降低类之间的耦合（coupling）。<br>– 有时无法使用向前声明，比如要声明某个类遵循一项协议。这种情况下，尽量把“该类遵循某协议”的这条声明移至“class-continuation分类”中。如果不行的话，就把协议单独放在一个头文件中，然后将其引入。</p>
<h2 id="第-3-条：多用字面量语法，少用与之等价的方法"><a href="#第-3-条：多用字面量语法，少用与之等价的方法" class="headerlink" title="第 3 条：多用字面量语法，少用与之等价的方法"></a>第 3 条：多用字面量语法，少用与之等价的方法</h2><p>要点：<br>– 应该使用字面量语法来创建字符串、数值、数组、字典。与创建此类对象的常规方法相比，这么做更加简明扼要。<br>– 应该通过取下标操作在访问数组下标或字典中的键所对应的元素。<br>– 用字面量语法创建数组或字典时，若值中有 nil，则会抛出异常。因此，务必确保值里不含 nil。</p>
<h2 id="第-4-条：多用类型常量，少用-define预处理指令"><a href="#第-4-条：多用类型常量，少用-define预处理指令" class="headerlink" title="第 4 条：多用类型常量，少用#define预处理指令"></a>第 4 条：多用类型常量，少用#define预处理指令</h2><p>要点：<br>– 不要用预处理指令定义常量。这样定义出来的常量不含类型信息，编译器只是会在编译前据此执行查找与替换操作。即使有人重新定义了常量值，编译器也不会产生警告信息，这将导致应用程序中的常量值不一致。<br>– 在实现文件中使用 static const 来定义“只在编译单元内可见的常量”（translation-unit-specific constant）。由于此类常量不在全局符号表中，所以无须为其名称加前缀。<br>– 在头文件中使用 extern 来声明全局变量，并在相关实现文件中定义其值。这种常量要出现在全局符号表中，所以其名称应加以区隔，通常用与之相关的类名做前缀。</p>
<h2 id="第-5-条：用枚举表示状态、选项、状态码"><a href="#第-5-条：用枚举表示状态、选项、状态码" class="headerlink" title="第 5 条：用枚举表示状态、选项、状态码"></a>第 5 条：用枚举表示状态、选项、状态码</h2><p>要点：<br>– 应该用枚举来表示状态机的状态、传递给方法的选项以及状态码等值，给这些值起个易懂的名字。<br>– 如果把传递给某个方法的选项表示为枚举类型，而多个选项又可同时使用，那么就将各选项值定义为2的幂，以便通过按位或操作将其组合起来。<br>– 用 NS_ENUM 与 NS_OPTIONS 宏来定义枚举类型，并指明其底层数据类型。这样做可以确保枚举是用开发者所选的底层数据类型实现出来的，而不会采用编译器所选的类型。<br>– 在处理枚举类型的 switch 语句中不要实现 default 分支。这样的话，加入新枚举之后，编译器就会提示开发者：switch 语句并未处理所有枚举。</p>
<h1 id="第-2-章：对象、消息、运行期"><a href="#第-2-章：对象、消息、运行期" class="headerlink" title="第 2 章：对象、消息、运行期"></a>第 2 章：对象、消息、运行期</h1><h2 id="第-6-条：理解“属性”这一概念"><a href="#第-6-条：理解“属性”这一概念" class="headerlink" title="第 6 条：理解“属性”这一概念"></a>第 6 条：理解“属性”这一概念</h2><p>– ABI（Application Binary Interface）：应用程序二进制接口。<br>– 使用 @dynamic 关键字能阻止编译器自动合成存取方法，他会告诉编译器：不要自动创建实现属性所用的实例变量，也就不要为其创建存取方法。</p>
<p>要点：<br>– 可以用 @property 语法来定义对象中所封装的数据。<br>– 通过 “特质” 来指定存储数据所需的正确语义。<br>– 在设置属性所对应的实例变量时，一定要遵从该属性所声明的语义。<br>– 开发 iOS 程序时应该使用 nonatomic 属性，因为 atomic 属性会严重影响性能。</p>
<h2 id="第-7-条：在对象内部尽量直接访问实例变量"><a href="#第-7-条：在对象内部尽量直接访问实例变量" class="headerlink" title="第 7 条：在对象内部尽量直接访问实例变量"></a>第 7 条：在对象内部尽量直接访问实例变量</h2><p>要点：<br>– 在对象内部读取数据时，应该直接通过实例变量来读，而写入数据时，则应该通过属性来写。<br>– 在初始化方法及 dealloc 方法中，总是应该直接通过实例变量来读写数据。<br>– 有时会使用惰性初始化技术配置某份数据，在这种情况下，需要通过属性来读去数据。</p>
<h2 id="第-8-条：理解“对象等同性”这一概念"><a href="#第-8-条：理解“对象等同性”这一概念" class="headerlink" title="第 8 条：理解“对象等同性”这一概念"></a>第 8 条：理解“对象等同性”这一概念</h2><p>要点：<br>– 若想检测对象的等同性，请提供“isEqual:”与 hash 方法。<br>– 相同的对象必须具有相同的哈希码，但是两个哈希码相同的对象却未必相同。<br>– 你要盲目地逐个检测每条属性，而是应该按照具体需求来制定检测方案。<br>– 编写 hash 方法时，应该使用计算速度快而且哈希码碰撞几率低的算法。</p>
<h2 id="第-9-条：以“类族模式”隐藏实现细节"><a href="#第-9-条：以“类族模式”隐藏实现细节" class="headerlink" title="第 9 条：以“类族模式”隐藏实现细节"></a>第 9 条：以“类族模式”隐藏实现细节</h2><p>要点：<br>– 类族模式可以把实现细节隐藏在一套简单的公共接口后面。<br>– 系统框架中经常使用类族。<br>– 从类族的公共抽象基类中继承子类时要当心，若有开发文档，则应首先阅读。</p>
<h2 id="第-10-条：在既有类中使用关联对象存放自定义数据"><a href="#第-10-条：在既有类中使用关联对象存放自定义数据" class="headerlink" title="第 10 条：在既有类中使用关联对象存放自定义数据"></a>第 10 条：在既有类中使用关联对象存放自定义数据</h2><p>要点：<br>– 可以通过“关联对象”机制把两个对象连起来。<br>– 定义关联对象时可指定内存管理语义，用以模仿定义属性时所采用的“拥有关系”与“非拥有关系”。<br>– 只有在其他做法不可行时才应选用关联对象，因为这种做法通常会引入难于查找的 bug。</p>
<h2 id="第-11-条：理解-objc-msgSend-的作用"><a href="#第-11-条：理解-objc-msgSend-的作用" class="headerlink" title="第 11 条：理解 objc_msgSend 的作用"></a>第 11 条：理解 objc_msgSend 的作用</h2><p>要点：<br>– 消息由接受者、选择子及参数构成。给某对象“发送消息”（invoke a message）也就相当于在该对象上“调用方法”（call a method）。<br>– 发给某对象的全部消息都要由“动态消息派发系统”（dynamic message dispatch system）来处理，该系统会查出对应的方法，并执行其代码。</p>
<h2 id="第-12-条：理解消息转发机制"><a href="#第-12-条：理解消息转发机制" class="headerlink" title="第 12 条：理解消息转发机制"></a>第 12 条：理解消息转发机制</h2><p>要点：<br>– 若对象无法响应某个选择子，则进入消息转发流程。<br>– 通过运行期的动态方法解析功能，我们可以在需要用到某个方法时再将其加入类中。<br>– 对象可以把其无法解读的某些选择子转交给其他对象来做。<br>– 经过上述两步后，如果还是没办法处理选择子，那就启动完整的消息转发机制。</p>
<h2 id="第-13-条：用“方法调配技术”调试“黑盒方法”"><a href="#第-13-条：用“方法调配技术”调试“黑盒方法”" class="headerlink" title="第 13 条：用“方法调配技术”调试“黑盒方法”"></a>第 13 条：用“方法调配技术”调试“黑盒方法”</h2><p>要点：<br>– 在运行期，可以向类中新增或替换选择子所对应的方法实现。<br>– 使用另一份实现来替换原有的方法实现，这道工序叫做“方法调配”，开发者常用此技术向原有实现中添加新功能。<br>– 一般来说，只有调试程序的时候才需要在运行期修改方法实现，这种做法不宜滥用。</p>
<h2 id="第-14-条：理解“类对象”的用意"><a href="#第-14-条：理解“类对象”的用意" class="headerlink" title="第 14 条：理解“类对象”的用意"></a>第 14 条：理解“类对象”的用意</h2><p>要点：<br>– 每个实例都有一个指向 Class 对象的指针，用以表明其类型，而这些 Class 对象则构成了类的集成体系。<br>– 如果对象类型无法在编译器确定，那么就应该使用类型信息查询方法来探知。<br>– 尽量使用类型信息查询方法来确定对象类型，而不要直接比较类对象，因为某些对象可能实现了消息转发功能。</p>
<h1 id="第-3-章：接口与-API-设计"><a href="#第-3-章：接口与-API-设计" class="headerlink" title="第 3 章：接口与 API 设计"></a>第 3 章：接口与 API 设计</h1><h2 id="第-15-条：用前缀避免命名空间冲突"><a href="#第-15-条：用前缀避免命名空间冲突" class="headerlink" title="第 15 条：用前缀避免命名空间冲突"></a>第 15 条：用前缀避免命名空间冲突</h2><p>要点：<br>– 选择与你的公司、应用程序或二者皆有关联之名称作为类名的前缀，并在所有代码中均使用这一前缀。<br>– 若自己所开发的程序库中用到了第三方库，则应为其中的名称加上前缀。</p>
<h2 id="第-16-条：提供“全能初始化方法”"><a href="#第-16-条：提供“全能初始化方法”" class="headerlink" title="第 16 条：提供“全能初始化方法”"></a>第 16 条：提供“全能初始化方法”</h2><p>要点：<br>– 在类中提供一个全能初始化方法，并于文档中指明。其他初始化方法均应调用此方法。<br>– 若全能初始化方法与超类不同，则需覆写超类中的对应方法。<br>– 如果类的初始化方法不适用于子类，那么应该覆写这个超类方法，并在其中抛出异常。</p>
<h2 id="第-17-条：实现-description-方法"><a href="#第-17-条：实现-description-方法" class="headerlink" title="第 17 条：实现 description 方法"></a>第 17 条：实现 description 方法</h2><p>要点：<br>– 实现 description 方法返回一个有意义的字符串，用以描述实例。<br>– 若想在调试时候打印出更详尽的对象描述信息，则应实现 debugDescription 方法。</p>
<h2 id="第-18-条：尽量使用不可变对象"><a href="#第-18-条：尽量使用不可变对象" class="headerlink" title="第 18 条：尽量使用不可变对象"></a>第 18 条：尽量使用不可变对象</h2><p>要点：<br>– 尽量创建不可变的对象。<br>– 若某些属性仅可于对象内部修改，则在 “class-continuation 分类” 中将其有 readonly 属性扩展为 readwrite 属性。<br>– 不要把可变的 collection 作为属性公开，而应该提供相关的方法，以此修改对象中的可变 collection。</p>
<h2 id="第-19-条：使用清晰而协调的命名方式"><a href="#第-19-条：使用清晰而协调的命名方式" class="headerlink" title="第 19 条：使用清晰而协调的命名方式"></a>第 19 条：使用清晰而协调的命名方式</h2><p>要点：<br>– 起名时应遵从标准的 Objective-C 命名规范，这样创建出来的接口更容易为开发者所理解。<br>– 方法名要言简意赅，从左到右读起来要像个日常用语中的句子才好。<br>– 方法名里不要使用缩略后的类型名称。<br>– 给方法起名时的第一要务就是确保其风格与你自己的代码或所要集成的框架相符。</p>
<h2 id="第-20-条：为私有名称加前缀"><a href="#第-20-条：为私有名称加前缀" class="headerlink" title="第 20 条：为私有名称加前缀"></a>第 20 条：为私有名称加前缀</h2><p>要点：<br>– 给私有方法的名称加上前缀，这样就可以很容易的将其同公共方法区分开。<br>– 不要单用一个下划线做私有方法的前缀，因为这种做法是预留给苹果公司用的。</p>
<h2 id="第-21-条：理解-Objective-C-错误类型"><a href="#第-21-条：理解-Objective-C-错误类型" class="headerlink" title="第 21 条：理解 Objective-C 错误类型"></a>第 21 条：理解 Objective-C 错误类型</h2><p>要点：<br>– 只有发生了可使整个应用程序崩溃的严重错误时，才应使用异常。<br>– 在错误不那么严重的情况下，可以指派“委托方法”（delegate method）来处理错误，也可以把错误信息放在 NSError 对象里，经由“输出参数”返回给调用者。</p>
<h2 id="第-22-条：理解-NSCopying-协议"><a href="#第-22-条：理解-NSCopying-协议" class="headerlink" title="第 22 条：理解 NSCopying 协议"></a>第 22 条：理解 NSCopying 协议</h2><p>要点：<br>– 若想令自己所写的对象具有拷贝功能，则需要实现 NSCopying 协议。<br>– 如果自定义的对象分为可变版本与不可变版本，那么就要同时实现 NSCopying 与 NSMutableCopying 协议。<br>– 复制对象时需要决定采用浅拷贝还是深拷贝，一般情况下应该尽量执行浅拷贝。<br>– 如果你所写的对象需要深拷贝，那么可考虑新增一个专门执行深拷贝的方法。</p>
<h1 id="第-4-章：协议与分类"><a href="#第-4-章：协议与分类" class="headerlink" title="第 4 章：协议与分类"></a>第 4 章：协议与分类</h1><h2 id="第-23-条：通过委托与数据源协议进行对象间通信"><a href="#第-23-条：通过委托与数据源协议进行对象间通信" class="headerlink" title="第 23 条：通过委托与数据源协议进行对象间通信"></a>第 23 条：通过委托与数据源协议进行对象间通信</h2><p><code>@property (nonatomic, weak) id&lt;EOCNetworkFetcherDelegate&gt; delegate;</code>，这个属性需定义成 weak，而非 strong，因为两者之间必须为“非拥有关系”（nonowning relationship）。<br>存放委托对象的这个属性要么定义成 weak，要么定义成 unsafe unretained，如果需要在相关对象销毁时自动清空（autoniling， 参见第 6 条），则定义为前者，若不需要自动清空，则定义为后者。</p>
<p>要点：<br>– 委托模式为对象提供了一套接口，使其可由此将相关事件告知其他对象。<br>– 将委托对象应该支持的接口定义成协议，在协议中把可能需要处理的事件定义成方法。<br>– 当某对象需要从另外一个对象中获取数据时，可以使用委托模式。在这种情境下，该模式亦称“数据源模式”（data source protocal）。<br>– 若有必要，可实现含有位段的结构体，将委托对象是否能响应相关协议方法这一信息缓存至其中。</p>
<h2 id="第-24-条：将类的实现代码分散到便于管理的数个分类之中"><a href="#第-24-条：将类的实现代码分散到便于管理的数个分类之中" class="headerlink" title="第 24 条：将类的实现代码分散到便于管理的数个分类之中"></a>第 24 条：将类的实现代码分散到便于管理的数个分类之中</h2><p>要点：<br>– 使用分类机制把类的实现代码划分成易于管理的小块。<br>– 将应该视为“私有”的方法归入名为 private 的分类中，以隐藏实现细节。</p>
<h2 id="第-25-条：总是为第三方类的分类名称加前缀"><a href="#第-25-条：总是为第三方类的分类名称加前缀" class="headerlink" title="第 25 条：总是为第三方类的分类名称加前缀"></a>第 25 条：总是为第三方类的分类名称加前缀</h2><p>要点：<br>– 向第三方类中添加分类时，总应给其名称加上你专用的前缀。<br>– 向第三方类中添加分类时，总应给其中的方法加上你专用的前缀。</p>
<h2 id="第-26-条：勿在分类中声明属性"><a href="#第-26-条：勿在分类中声明属性" class="headerlink" title="第 26 条：勿在分类中声明属性"></a>第 26 条：勿在分类中声明属性</h2><p>要点：<br>– 把封装数据所用的全部属性都定义在主接口里。<br>– 在“class-continuation 分类”之外的其他分类中，可以定义存取方法，但尽量不要定义属性。</p>
<h2 id="第-27-条：使用“class-continuation-分类”隐藏实现细节"><a href="#第-27-条：使用“class-continuation-分类”隐藏实现细节" class="headerlink" title="第 27 条：使用“class-continuation 分类”隐藏实现细节"></a>第 27 条：使用“class-continuation 分类”隐藏实现细节</h2><p>要点：<br>– 通过“class-continuation 分类”向类中新增实例变量<br>– 通过某属性在主接口中声明为“只读”，而类的内部又要用设置方法修改此属性，那么就在“class-continuation 分类”中将其扩展为“可读写”。<br>– 把私有方法的原型声明在“class-continuation 分类”里面。<br>– 若想使类所遵循的协议不为人所知，则可于“class-continuation 分类”中声明。</p>
<h2 id="第-28-条：通过协议提供匿名对象"><a href="#第-28-条：通过协议提供匿名对象" class="headerlink" title="第 28 条：通过协议提供匿名对象"></a>第 28 条：通过协议提供匿名对象</h2><p>要点：<br>– 协议可在某种程度上提供匿名类型。具体的对象类型可以淡化成遵从某协议的 id 类型，协议里规定了对象所应实现的方法。<br>– 使用匿名对象来隐藏类型名称（或类名）。<br>– 如果具体类型不确定，重要的是对象能够响应（定义在协议里的）特定方法，那么可以使用匿名对象来表示。</p>
<h1 id="第-5-章：内存管理"><a href="#第-5-章：内存管理" class="headerlink" title="第 5 章：内存管理"></a>第 5 章：内存管理</h1><h2 id="第-29-条：理解引用计数"><a href="#第-29-条：理解引用计数" class="headerlink" title="第 29 条：理解引用计数"></a>第 29 条：理解引用计数</h2><p>要点：<br>– 引用计数机制通过可以递增递减的计数器来管理内存。对象创建好之后，其保留技术至少为 1。若保留计数为正，则对象继续存活。当保留计数降为 0 时，对象就被销毁了。<br>– 在对象生命期中，其余对象通过引用来保留或释放次对象。保留与释放操作分别会递增及递减保留计数。</p>
<h2 id="第-30-条：以-ARC-简化引用计数"><a href="#第-30-条：以-ARC-简化引用计数" class="headerlink" title="第 30 条：以 ARC 简化引用计数"></a>第 30 条：以 ARC 简化引用计数</h2><p>在应用程序中，可用下列修饰符来改变局部变量与实例变量的语义：<br>– <strong>strong：默认语义，保留此值。<br>– </strong>unsafe_unretained：不保留此值，这么做可能不安全，因为等到再次使用变量时，其对象可能已经回收了。<br>– <strong>weak：不保留此值，但是变量可以安全使用，因为如果系统把这个对象回收了，那么变量也会自动清空。<br>– </strong>autoreleasing：把对象“按引用传递”（pass by reference）给方法时，使用这个特殊的修饰符。此值在方法返回时自动释放。</p>
<p>要点：<br>– 在 ARC 之后，程序员就无须担心内存管理问题了。使用 ARC 来编程，可省去类中的许多“样板代码”。<br>– ARC 管理对象生命期的方法基本上就是：在合适的地方插入“保留”及“释放”操作。在 ARC 环境下，变量的内存管理语义可以通过修饰符指明，而原来则需要手工执行“保留”及”释放“操作。<br>– 有方法所返回的对象，其内存管理语义总是通过方法名来实现。ARC 将此确定为开发者必须遵守的规则。<br>– ARC 只负责管理 Objective-C 对象的内存。尤其注意：CoreFoundation 对象不归 ARC 管理，开发者必须适时调用 CFRetain／CFRelease。</p>
<h2 id="第-31-条：在-dealloc-方法中只释放引用并解除监听"><a href="#第-31-条：在-dealloc-方法中只释放引用并解除监听" class="headerlink" title="第 31 条：在 dealloc 方法中只释放引用并解除监听"></a>第 31 条：在 dealloc 方法中只释放引用并解除监听</h2><p>要点：<br>– 在 dealloc 方法里，应该做的事情就是释放指向其他对象的引用，并取消原来订阅的”键值观察“（KVO）或 NSNotificationCenter 等通知，不要做其他事情。<br>– 如果对象持有文件描述符等系统资源，那么就应该专门编写一个方法来释放此种资源。这样的类要和其他使用者约定：用完资源后必须调用 close 方法。<br>– 执行异步任务的方法不应在 dealloc 里调用；只能在正常状态下执行的那些方法也不应在 dealloc 里调用，因为此时对象已处于正在回收的状态了。</p>
<h2 id="第-32-条：编写“异常安全代码”时留意内存管理问题"><a href="#第-32-条：编写“异常安全代码”时留意内存管理问题" class="headerlink" title="第 32 条：编写“异常安全代码”时留意内存管理问题"></a>第 32 条：编写“异常安全代码”时留意内存管理问题</h2><p>要点：<br>– 捕获异常时，一定要注意将 try 块内所创立的对象清理干净。<br>– 在默认情况下，ARC 不生成安全处理异常所需的清理代码。开启编译器标志后，可生成这种代码，不过会导致应用程序变大，而且会降低运行效率。</p>
<h2 id="第-33-条：以弱引用避免保留环"><a href="#第-33-条：以弱引用避免保留环" class="headerlink" title="第 33 条：以弱引用避免保留环"></a>第 33 条：以弱引用避免保留环</h2><p>要点：<br>– 将某些引用设为 weak，可避免出现“保留环”。<br>– weak 引用可以自动清空，也可以不自动清空。自动清空（autonilling）是随着 ARC而引入的新特性，由运行期系统来实现。在具备自动清空功能的弱引用上，可以随意读取其数据，因为这种引用不会指向已经回收过的对象。</p>
<h2 id="第-34-条：以“自动释放池块”降低内存峰值"><a href="#第-34-条：以“自动释放池块”降低内存峰值" class="headerlink" title="第 34 条：以“自动释放池块”降低内存峰值"></a>第 34 条：以“自动释放池块”降低内存峰值</h2><p>要点：<br>– 自动释放池排布在栈中，对象收到 autorelease 消息后，系统将其放入最顶端的池里。<br>– 合理运用自动释放池，可降低应用程序的内存峰值。<br>– @autoreleasepool 这种新式写法能创建出更为轻便的自动释放池。</p>
<h2 id="第-35-条：用“僵尸对象”调试内存管理问题"><a href="#第-35-条：用“僵尸对象”调试内存管理问题" class="headerlink" title="第 35 条：用“僵尸对象”调试内存管理问题"></a>第 35 条：用“僵尸对象”调试内存管理问题</h2><p>要点：<br>– 系统在回收对象时，可以不将其真的回收，而是把它转化为僵尸对象。通过环境变量 NSZombisEnabled 可开启此功能。<br>– 系统会修改对象的 isa 指针，令其指向特殊的僵尸类，从而使该对象变为僵尸对象。僵尸类能够响应所有的选择子，响应方式为：打印一条包含消息内容及其接受者的消息，然后终止应用程序。</p>
<h2 id="第-36-条：不要使用-retainCount"><a href="#第-36-条：不要使用-retainCount" class="headerlink" title="第 36 条：不要使用 retainCount"></a>第 36 条：不要使用 retainCount</h2><p>要点：<br>– 对象的保留计数看似有用，实则不然，因为任何给定时间点上的“绝对保留计数”（absolute retain count）都无法反映对象生命周期的全貌。<br>– 引入 ARC 之后，retainCount 方法就正式废止了，在 ARC 下调用该方法会导致编译器报错。</p>
<h1 id="第-6-章：块与大中枢派发"><a href="#第-6-章：块与大中枢派发" class="headerlink" title="第 6 章：块与大中枢派发"></a>第 6 章：块与大中枢派发</h1><h2 id="第-37-条：理解“块”这一概念"><a href="#第-37-条：理解“块”这一概念" class="headerlink" title="第 37 条：理解“块”这一概念"></a>第 37 条：理解“块”这一概念</h2><p>– self 也是个对象，因而块在捕获它时也会将其保留。如果 self 所指代的哪个对象同时也保留了块。那么这种情况通常就会导致“保留环”。<br>–定义在 if 及 else 语句中的两个块都分配在栈内存中。编译器会给每个块分配好栈内存，然而等离开了相应的范围之后，编译器有可能把分配给块的内存覆写掉。于是，这两个块只能保证在对应的 if 或 else 语句范围内有效。这样写出来的代码可以编译，但是运行起来时而正确，时而错误。若编译器未覆写待执行的块，则程序照常运行，若覆写，则程序崩溃。<br>为解决此问题，可给块对象发送 copy 消息以拷贝之。这样的话，就可以把块从栈复制到堆了。拷贝后的块，可以在定义它的那么范围之外使用。而且，一旦复制到堆上，块就成了带引用计数的对象了。后续的复制操作都不会真的执行复制，只是递增块对象的引用计数。</p>
<p>要点：<br>– 块是 C、C++、Objective-C 中的语法闭包。<br>– 块可接受参数，也可返回值。<br>– 块可以分配在栈或者堆上，也可以是全局的，分配在栈上的块可拷贝到堆里，这样的话，就和标准的 Objective-C 对象一样，具备引用计数了。</p>
<h2 id="第-38-条：为常用的块类型创建-typedef"><a href="#第-38-条：为常用的块类型创建-typedef" class="headerlink" title="第 38 条：为常用的块类型创建 typedef"></a>第 38 条：为常用的块类型创建 typedef</h2><p>要点：<br>– 以 typedef 重新定义块类型，可令块变量用起来更加简单。<br>– 定义新类型时应遵从现有的命名习惯，勿使其名称与别的类型相冲突。<br>– 不妨为同一个块签名定义多个类型别名。如果要重构的代码使用了块类型的某个别名，那么只需改相应 typedef 中的块签名即可，无须改动其他 typedef。</p>
<h2 id="第-39-条：用-handle-块降低代码分散程度"><a href="#第-39-条：用-handle-块降低代码分散程度" class="headerlink" title="第 39 条：用 handle 块降低代码分散程度"></a>第 39 条：用 handle 块降低代码分散程度</h2><p>要点：<br>– 在创建对象时，可以使用内联的 handle 块将相关业务逻辑一并声明。<br>– 在有多个实例需要监控时，如果采用委托模式，那么经常需要根据传入的对象来切换，而若改用 handle 块来实现，则可直接将块与相关对象放在一起。<br>– 设计 API 时如果用到了 handle 块，那么可以增加一个参数，使调用者可通过此参数来决定应该把块安排在哪个队列上执行。</p>
<h2 id="第-40-条：用块引用其所属对象时不要出现保留环"><a href="#第-40-条：用块引用其所属对象时不要出现保留环" class="headerlink" title="第 40 条：用块引用其所属对象时不要出现保留环"></a>第 40 条：用块引用其所属对象时不要出现保留环</h2><p>要点：<br>– 如果块所捕获的对象直接或间接地保留了块本身，那么就得当心保留环问题。<br>– 一定要找个适当的时机接触保留环，而不能把责任推给 API 的调用者。</p>
<h2 id="第-41-条：多用派发队列，少用同步锁"><a href="#第-41-条：多用派发队列，少用同步锁" class="headerlink" title="第 41 条：多用派发队列，少用同步锁"></a>第 41 条：多用派发队列，少用同步锁</h2><p>要点：<br>– 派发队列可用来表述同步语义（synchronization semantic），这种做法要比使用 @synchronized 块或 NSLock 对象更简单。<br>– 将同步与异步派发结合起来，可以实现与普通枷锁机制一样的同步行为，而这么做却不会阻塞执行异步派发的线程。<br>– 使用同步队列栅栏块，可以令同步行为更加高效。</p>
<h2 id="第-42-条：多用-GCD，少用-performSelector-系列方法"><a href="#第-42-条：多用-GCD，少用-performSelector-系列方法" class="headerlink" title="第 42 条：多用 GCD，少用 performSelector 系列方法"></a>第 42 条：多用 GCD，少用 performSelector 系列方法</h2><p>要点：<br>– performSelector 系列方法在内存管理方面容易有疏失。它无法确定将要执行的选择子具体是什么，因而 ARC 编译器也就无法插入适当的内存管理方法。<br>– performSelector 系列方法所能处理的选择子太过于局限了，选择子的返回值类型及发送给方法的参数个数都受到限制。<br>– 如果想把任务放在另一个线程上执行，那么最好不要用 performSelector 系列方法，而是应该把任务封装到块里，然后调用大中枢派发机制的相关方法来实现。</p>
<h2 id="第-43-条：掌握-GCD-及操作队列的使用时机"><a href="#第-43-条：掌握-GCD-及操作队列的使用时机" class="headerlink" title="第 43 条：掌握 GCD 及操作队列的使用时机"></a>第 43 条：掌握 GCD 及操作队列的使用时机</h2><p>要点：<br>– 在解决多线程与任务管理问题时，派发队列并非唯一方案。<br>– 操作队列提供了一套高层的 Objective-C API，能实现纯 GCD 所具备的绝大部分功能，而且还能完成一些更为复杂的操作，那些操作若改用 GCD 来实现，则需另外编写代码。</p>
<h2 id="第-44-条：通过-Dispatch-Group-机制，根据系统资源状况来执行任务"><a href="#第-44-条：通过-Dispatch-Group-机制，根据系统资源状况来执行任务" class="headerlink" title="第 44 条：通过 Dispatch Group 机制，根据系统资源状况来执行任务"></a>第 44 条：通过 Dispatch Group 机制，根据系统资源状况来执行任务</h2><p>要点：<br>– 一系列任务可归入一个 dispatch group 之中。开发者可以在这组任务执行完毕时获得通知。<br>– 通过 dispatch group，可以在并发式派发队列里同时执行多项任务。此时 GCD 会根据系统资源状况来调度这些并发执行的任务。开发者若自己来实现此功能，则需编写大量代码。</p>
<h2 id="第-45-条：使用-dispatch-once-来执行只需运行一次的线程安全代码"><a href="#第-45-条：使用-dispatch-once-来执行只需运行一次的线程安全代码" class="headerlink" title="第 45 条：使用 dispatch_once 来执行只需运行一次的线程安全代码"></a>第 45 条：使用 dispatch_once 来执行只需运行一次的线程安全代码</h2><p>在单例模式中所用的 sharedInstance 方法里，<code>static EOCClass *sharedInstance = nil</code>，把该变量定义在 static 作用域中，可以保证编译器在每次执行 sharedInstance 方法是都会复用这个变量，而不会创建新变量。</p>
<p>要点：<br>– 经常需要编写“只需执行一次的线程安全代码”（thread-safe single-code execution）。通过 GCD 所提供的 dispatch_once 函数，很容易就能实现此功能。<br>– 标记应该声明在 static 或 global 作用域中，这样的话，在把只需执行一次的块传给 dispatch_once 函数时，传进去的标记也是相同的。</p>
<h2 id="第-46-条：不要使用-dispatch-get-current-queue"><a href="#第-46-条：不要使用-dispatch-get-current-queue" class="headerlink" title="第 46 条：不要使用 dispatch_get_current_queue"></a>第 46 条：不要使用 dispatch_get_current_queue</h2><p>要点：<br>– dispatch_get_current_queue 函数的行为常常与开发者所预期的不同。次函数已经废弃，只应做调试之用。<br>– 由于派发队列是按层级来组织的，所以无法单用某个队列对象来描述“当前队列”这一概念。<br>– dispatch_get_current_queue 函数用于解决由不可重入的代码所引发的死锁，然而能用此函数解决的问题，通常也能改用“队列特定数据”来解决。</p>
<h1 id="第-7-章：系统框架"><a href="#第-7-章：系统框架" class="headerlink" title="第 7 章：系统框架"></a>第 7 章：系统框架</h1><h2 id="第-47-条：熟悉系统框架"><a href="#第-47-条：熟悉系统框架" class="headerlink" title="第 47 条：熟悉系统框架"></a>第 47 条：熟悉系统框架</h2><p>要点：<br>– 许多系统框架都可以直接使用。其中最重要的是 FOundation 与 CoreFoundation，这两个框架提供了构建应用程序所需的许多核心功能。<br>– 很多常见任务都能用框架来做，例如音频与视频处理、网络通信、数据管理等。<br>– 请记住：用纯 C 写成的框架与用 Objective-C 写成的一样重要，若想成为优秀的 Objective-C 开发者，应该掌握 C 语言的核心概念。</p>
<h2 id="第-48-条：多用块枚举，少用-for-循环"><a href="#第-48-条：多用块枚举，少用-for-循环" class="headerlink" title="第 48 条：多用块枚举，少用 for 循环"></a>第 48 条：多用块枚举，少用 for 循环</h2><p>要点：<br>– 遍历 collection 有四种方式。最基本的办法就是 for 循环，其次是 NSEnumerator 遍历法及快速遍历法，最新、最先进的方法则是“块枚举法”。<br>– “块枚举法”本身就能通过 GCD 来并发执行遍历操作，无须另行编写代码。而采用其它遍历方法则无法轻易实现这一点。<br>– 若提前知道待遍历的 collection 含有何种对象，则应修改块签名，指出对象的具体类型。</p>
<h2 id="第-49-条：对自定义其内存管理语义的-collection-使用无缝桥街"><a href="#第-49-条：对自定义其内存管理语义的-collection-使用无缝桥街" class="headerlink" title="第 49 条：对自定义其内存管理语义的 collection 使用无缝桥街"></a>第 49 条：对自定义其内存管理语义的 collection 使用无缝桥街</h2><p>要点：<br>– 通过无缝桥接技术，可以在 Foundation 框架中的 Objective-C 对象与 CoreFoundation 框架中的 C 语言数据结构之间来回转换。<br>– 在 CoreFoundation 层面创建 collection 时，可以指定许多回调函数，这些函数表示此 collection 应如何处理其元素。然后，可运用无缝桥接技术，将其转换成具备特殊内存管理语义的 Objective-C collection。</p>
<h2 id="第-50-条：构建缓存时选用-NSCache-而非-NSDictionary"><a href="#第-50-条：构建缓存时选用-NSCache-而非-NSDictionary" class="headerlink" title="第 50 条：构建缓存时选用 NSCache 而非 NSDictionary"></a>第 50 条：构建缓存时选用 NSCache 而非 NSDictionary</h2><p>要点：<br>– 实现缓存时应选用 NSCache 而非 NSDictionary 对象。因为 NSCache 可以提供优雅的自动删减功能，而且是“线程安全的”，此外，它与字典不同，并不会拷贝键。<br>– 可以给 NScache 对象设置上限，用以限制缓存中的对象总个数及“总成本”，而这些尺度则定义了缓存删减其中对象的时机。但是绝对不要把这些尺度当成可靠的“硬限制”（hard limit），它们仅对 NSCache 起指导作用。<br>– 将 NSPurgeableData 与 NSCache 搭配使用，可实现自动清除数据的功能，也就是说，当 NSPuergeableData 对象所占内存为系统所丢弃时，该对象自身也会从缓存中移除。<br>– 如果缓存使用得当，那么应用程序的响应速度就能提高。只有那种“重新计算起来很费事的”数据，才值得放入缓存，比如那些需要从网络获取或从磁盘读取的数据。</p>
<h2 id="第-51-条：精简-initialize-与-load-的实现代码"><a href="#第-51-条：精简-initialize-与-load-的实现代码" class="headerlink" title="第 51 条：精简 initialize 与 load 的实现代码"></a>第 51 条：精简 initialize 与 load 的实现代码</h2><p>要点：<br>– 在加载阶段，如果类实现了 load 方法，那么系统就会调用它。分类里也可以定义此方法，类的 load 方法要比分类中的先调用。与其他方法不同，load 方法不参与覆写机制。<br>– 首次使用某个类之前，系统会向其发送 initialize 消息。由于此方法遵从普通的覆写规则，所以通常应该在里面判断当前要初始化的哪个类。<br>– load 与 initialize 方法都应该实现得精简一些，这有助于保持应用程序的响应能力，也能减少引入“依赖环”（interdependency cycle）的几率。<br>– 无法在编译期设定的全局变量，可以放在 initialize 方法里初始化。</p>
<h2 id="第-52-条：别忘了-NSTimer-会保留其目标对象"><a href="#第-52-条：别忘了-NSTimer-会保留其目标对象" class="headerlink" title="第 52 条：别忘了 NSTimer 会保留其目标对象"></a>第 52 条：别忘了 NSTimer 会保留其目标对象</h2><p>要点：<br>– NSTimer 对象会保留其目标，直到计数器本身失效为止，调用 invalidate 方法可令计时器实效，另外，一次性的计数器在触发完任务之后也会失效。<br>– 反复执行任务的计数器（repeating timer），很容易引入保留环，如果这种计时器的目标对象又保留了计时器本身，那肯定会导致保留环。这种环状保留关系，可能是直接发生的，也可能是通过对象图里的其他对象间接发生的。<br>– 可以扩充 NStimer 的功能，用“块”来打破保留环。不过，除非 NSTimer 将来在公共接口里提供此功能，否则必须创建分类，将相关实现代码加入其中。</p>
<h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>记了一遍笔记（不过是将书中的每节要点整理了出来），又粗略阅读了一遍这本书，温故知新。所以，做这份笔记还是很有益处的～</p>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/09/07/analyse-safekit/" rel="next" title="从 SafeKit 看异常保护及 Method Swizzling 使用分析">
                <i class="fa fa-chevron-left"></i> 从 SafeKit 看异常保护及 Method Swizzling 使用分析
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div id="sidebar-dimmer"></div>
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.png"
               alt="与佳期" />
          <p class="site-author-name" itemprop="name">与佳期</p>
           
              <p class="site-description motion-element" itemprop="description">登白薠兮骋望，与佳期兮夕张。</p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives/">
                <span class="site-state-item-count">19</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/gonghonglou" target="_blank" title="weibo">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  weibo
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://github.com/gonghonglou" target="_blank" title="github">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  github
                </a>
              </span>
            
              <span class="links-of-author-item">
                <a href="https://twitter.com/gonghonglou" target="_blank" title="twitter">
                  
                    <i class="fa fa-fw fa-globe"></i>
                  
                  twitter
                </a>
              </span>
            
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#第-1-章：熟悉Objective-C"><span class="nav-number">1.</span> <span class="nav-text">第 1 章：熟悉Objective-C</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#第-1-条：了解Objective-C语言的起源"><span class="nav-number">1.1.</span> <span class="nav-text">第 1 条：了解Objective-C语言的起源</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第-2-条：在类的头文件中尽量少引入其他头文件"><span class="nav-number">1.2.</span> <span class="nav-text">第 2 条：在类的头文件中尽量少引入其他头文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第-3-条：多用字面量语法，少用与之等价的方法"><span class="nav-number">1.3.</span> <span class="nav-text">第 3 条：多用字面量语法，少用与之等价的方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第-4-条：多用类型常量，少用-define预处理指令"><span class="nav-number">1.4.</span> <span class="nav-text">第 4 条：多用类型常量，少用#define预处理指令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第-5-条：用枚举表示状态、选项、状态码"><span class="nav-number">1.5.</span> <span class="nav-text">第 5 条：用枚举表示状态、选项、状态码</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-2-章：对象、消息、运行期"><span class="nav-number">2.</span> <span class="nav-text">第 2 章：对象、消息、运行期</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#第-6-条：理解“属性”这一概念"><span class="nav-number">2.1.</span> <span class="nav-text">第 6 条：理解“属性”这一概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第-7-条：在对象内部尽量直接访问实例变量"><span class="nav-number">2.2.</span> <span class="nav-text">第 7 条：在对象内部尽量直接访问实例变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第-8-条：理解“对象等同性”这一概念"><span class="nav-number">2.3.</span> <span class="nav-text">第 8 条：理解“对象等同性”这一概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第-9-条：以“类族模式”隐藏实现细节"><span class="nav-number">2.4.</span> <span class="nav-text">第 9 条：以“类族模式”隐藏实现细节</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第-10-条：在既有类中使用关联对象存放自定义数据"><span class="nav-number">2.5.</span> <span class="nav-text">第 10 条：在既有类中使用关联对象存放自定义数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第-11-条：理解-objc-msgSend-的作用"><span class="nav-number">2.6.</span> <span class="nav-text">第 11 条：理解 objc_msgSend 的作用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第-12-条：理解消息转发机制"><span class="nav-number">2.7.</span> <span class="nav-text">第 12 条：理解消息转发机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第-13-条：用“方法调配技术”调试“黑盒方法”"><span class="nav-number">2.8.</span> <span class="nav-text">第 13 条：用“方法调配技术”调试“黑盒方法”</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第-14-条：理解“类对象”的用意"><span class="nav-number">2.9.</span> <span class="nav-text">第 14 条：理解“类对象”的用意</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-3-章：接口与-API-设计"><span class="nav-number">3.</span> <span class="nav-text">第 3 章：接口与 API 设计</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#第-15-条：用前缀避免命名空间冲突"><span class="nav-number">3.1.</span> <span class="nav-text">第 15 条：用前缀避免命名空间冲突</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第-16-条：提供“全能初始化方法”"><span class="nav-number">3.2.</span> <span class="nav-text">第 16 条：提供“全能初始化方法”</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第-17-条：实现-description-方法"><span class="nav-number">3.3.</span> <span class="nav-text">第 17 条：实现 description 方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第-18-条：尽量使用不可变对象"><span class="nav-number">3.4.</span> <span class="nav-text">第 18 条：尽量使用不可变对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第-19-条：使用清晰而协调的命名方式"><span class="nav-number">3.5.</span> <span class="nav-text">第 19 条：使用清晰而协调的命名方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第-20-条：为私有名称加前缀"><span class="nav-number">3.6.</span> <span class="nav-text">第 20 条：为私有名称加前缀</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第-21-条：理解-Objective-C-错误类型"><span class="nav-number">3.7.</span> <span class="nav-text">第 21 条：理解 Objective-C 错误类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第-22-条：理解-NSCopying-协议"><span class="nav-number">3.8.</span> <span class="nav-text">第 22 条：理解 NSCopying 协议</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-4-章：协议与分类"><span class="nav-number">4.</span> <span class="nav-text">第 4 章：协议与分类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#第-23-条：通过委托与数据源协议进行对象间通信"><span class="nav-number">4.1.</span> <span class="nav-text">第 23 条：通过委托与数据源协议进行对象间通信</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第-24-条：将类的实现代码分散到便于管理的数个分类之中"><span class="nav-number">4.2.</span> <span class="nav-text">第 24 条：将类的实现代码分散到便于管理的数个分类之中</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第-25-条：总是为第三方类的分类名称加前缀"><span class="nav-number">4.3.</span> <span class="nav-text">第 25 条：总是为第三方类的分类名称加前缀</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第-26-条：勿在分类中声明属性"><span class="nav-number">4.4.</span> <span class="nav-text">第 26 条：勿在分类中声明属性</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第-27-条：使用“class-continuation-分类”隐藏实现细节"><span class="nav-number">4.5.</span> <span class="nav-text">第 27 条：使用“class-continuation 分类”隐藏实现细节</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第-28-条：通过协议提供匿名对象"><span class="nav-number">4.6.</span> <span class="nav-text">第 28 条：通过协议提供匿名对象</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-5-章：内存管理"><span class="nav-number">5.</span> <span class="nav-text">第 5 章：内存管理</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#第-29-条：理解引用计数"><span class="nav-number">5.1.</span> <span class="nav-text">第 29 条：理解引用计数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第-30-条：以-ARC-简化引用计数"><span class="nav-number">5.2.</span> <span class="nav-text">第 30 条：以 ARC 简化引用计数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第-31-条：在-dealloc-方法中只释放引用并解除监听"><span class="nav-number">5.3.</span> <span class="nav-text">第 31 条：在 dealloc 方法中只释放引用并解除监听</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第-32-条：编写“异常安全代码”时留意内存管理问题"><span class="nav-number">5.4.</span> <span class="nav-text">第 32 条：编写“异常安全代码”时留意内存管理问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第-33-条：以弱引用避免保留环"><span class="nav-number">5.5.</span> <span class="nav-text">第 33 条：以弱引用避免保留环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第-34-条：以“自动释放池块”降低内存峰值"><span class="nav-number">5.6.</span> <span class="nav-text">第 34 条：以“自动释放池块”降低内存峰值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第-35-条：用“僵尸对象”调试内存管理问题"><span class="nav-number">5.7.</span> <span class="nav-text">第 35 条：用“僵尸对象”调试内存管理问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第-36-条：不要使用-retainCount"><span class="nav-number">5.8.</span> <span class="nav-text">第 36 条：不要使用 retainCount</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-6-章：块与大中枢派发"><span class="nav-number">6.</span> <span class="nav-text">第 6 章：块与大中枢派发</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#第-37-条：理解“块”这一概念"><span class="nav-number">6.1.</span> <span class="nav-text">第 37 条：理解“块”这一概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第-38-条：为常用的块类型创建-typedef"><span class="nav-number">6.2.</span> <span class="nav-text">第 38 条：为常用的块类型创建 typedef</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第-39-条：用-handle-块降低代码分散程度"><span class="nav-number">6.3.</span> <span class="nav-text">第 39 条：用 handle 块降低代码分散程度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第-40-条：用块引用其所属对象时不要出现保留环"><span class="nav-number">6.4.</span> <span class="nav-text">第 40 条：用块引用其所属对象时不要出现保留环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第-41-条：多用派发队列，少用同步锁"><span class="nav-number">6.5.</span> <span class="nav-text">第 41 条：多用派发队列，少用同步锁</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第-42-条：多用-GCD，少用-performSelector-系列方法"><span class="nav-number">6.6.</span> <span class="nav-text">第 42 条：多用 GCD，少用 performSelector 系列方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第-43-条：掌握-GCD-及操作队列的使用时机"><span class="nav-number">6.7.</span> <span class="nav-text">第 43 条：掌握 GCD 及操作队列的使用时机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第-44-条：通过-Dispatch-Group-机制，根据系统资源状况来执行任务"><span class="nav-number">6.8.</span> <span class="nav-text">第 44 条：通过 Dispatch Group 机制，根据系统资源状况来执行任务</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第-45-条：使用-dispatch-once-来执行只需运行一次的线程安全代码"><span class="nav-number">6.9.</span> <span class="nav-text">第 45 条：使用 dispatch_once 来执行只需运行一次的线程安全代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第-46-条：不要使用-dispatch-get-current-queue"><span class="nav-number">6.10.</span> <span class="nav-text">第 46 条：不要使用 dispatch_get_current_queue</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-7-章：系统框架"><span class="nav-number">7.</span> <span class="nav-text">第 7 章：系统框架</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#第-47-条：熟悉系统框架"><span class="nav-number">7.1.</span> <span class="nav-text">第 47 条：熟悉系统框架</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第-48-条：多用块枚举，少用-for-循环"><span class="nav-number">7.2.</span> <span class="nav-text">第 48 条：多用块枚举，少用 for 循环</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第-49-条：对自定义其内存管理语义的-collection-使用无缝桥街"><span class="nav-number">7.3.</span> <span class="nav-text">第 49 条：对自定义其内存管理语义的 collection 使用无缝桥街</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第-50-条：构建缓存时选用-NSCache-而非-NSDictionary"><span class="nav-number">7.4.</span> <span class="nav-text">第 50 条：构建缓存时选用 NSCache 而非 NSDictionary</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第-51-条：精简-initialize-与-load-的实现代码"><span class="nav-number">7.5.</span> <span class="nav-text">第 51 条：精简 initialize 与 load 的实现代码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#第-52-条：别忘了-NSTimer-会保留其目标对象"><span class="nav-number">7.6.</span> <span class="nav-text">第 52 条：别忘了 NSTimer 会保留其目标对象</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#后记"><span class="nav-number">8.</span> <span class="nav-text">后记</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2016 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">与佳期</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  

    
      <script id="dsq-count-scr" src="https://gonghonglou.disqus.com/count.js" async></script>
    

    
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'http://gonghonglou.com/2017/10/08/Effective-Objective-C-note/';
          this.page.identifier = '2017/10/08/Effective-Objective-C-note/';
          this.page.title = 'Effective Objective-C 2.0 读书笔记';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://gonghonglou.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
    

  




	





  








  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

</body>
</html>
