<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[一小时轻松实现科学上网]]></title>
    <url>%2F2017%2F07%2F10%2Fss-vps%2F</url>
    <content type="text"><![CDATA[之前一直在用 Green VPN，而且 Green 的智能分流等功能做的也是越来越好，可惜，突然听到 Green 要关闭服务了，发生了什么？？访问 Green 官网 就看到这则「相遇有时，后会无期」的公告。 我还能说什么，当然是选择原谅她。。。 正是因为这则公告，我失去了又一个科学上网的工具，干脆自己买 vps 搭一个。以下是几种服务的对比： PPTP： – 优点：网上关于搭建 PPTP 服务的教程最多 – 缺点：可能是因为 PPTP 不够安全，所以苹果禁用了这种服务的连接。就是说 Mac OX 和 iOS 系统上是不能使用这种服务的。 L2TP、IKEv2、IPSec： – 优点：Mac OX 和 iOS 系统上可以使用 – 缺点：使用系统添加此类服务的 VPN 配置无法实现智能分流，也就是 Shadowsocks 里的「自动代理模式」（PPTP 同样存在这个缺点） Shadowsocks： – 优点：可以实现自动代理模式，实现国内国外线路智能分流。 – 缺点：必须下载 Shadowsocks 客户端来使用该服务 所以，为了自动代理，我选择了 Shadowsocks。简单来说就是在自己的服务器上搭建一个 Shadowsocks 服务，对外提供「IP 地址 + 端口号」和「密码」 实现的功能： 服务器开机自动启动 Shadowsocks 服务 可配置多个账号（即：多个端口号 + 密码） 实现自动代理模式 所以我们需要： 购买服务器（vps） 装载 Shadowsocks 服务 下载 iOS、Mac 客户端连接 vps 购买 VPS在 搬瓦工 购买一款适合你的主机，单纯搭建 Shadowsocks 服务的话「10G VPS」已经完全够用了，一年 19.9 美元，网上搜一个 6% 的优惠码，折合人民币大概 130 块一年。购买过程可以参考：新手用户搬瓦工VPS购买图文指导教程关于 KVM 和 OpenVZ的区别可以参考：Linux VPS基本常识 - KVM与OpenVZ架构的区别 购买成功后，在这个地址点击 KiwiVM Control Panel 跳转至 KiwiVM 可管理你的主机然后就可以看到你主机的详细信息了，并且搬瓦工已经帮你装好了 centos 系统： 装载 Shadowsocks 服务接下来，你有两种选择： 一键安装 – 优点：方便快捷 – 缺点：不能添加账号，不能随意更改密码（只能重新生成） 自己搭建 Shadowsocks 服务 – 优点：可以添加多个账号（任意增删端口号即可），可以修改密码 – 缺点：ssh 连接服务器，执行一系列命令行命令（不过，这对于想要捣鼓捣鼓服务器的人来说，比如我，这也算是优点） 一键安装如下图，点击 Intsall Shadowsocks Server 即可： 安装成功后如下图，会提供给我们：端口号、加密方式、密码，其中密码只能重新生成，不能更改。 下载 iOS、Mac 客户端连接 vps Mac 客户端：ShadowsocksX iOS 客户端：App Store 搜索「Wingy」或着「Shadowrocket」 windows 客户端：Shadowsocks Windows 如下图为 Shadowsocks Mac 客户端，填入服务器 IP 地址、上图中 Shadowsocks Server 端口号、加密方式、密码确定即可连接 VPS 的 Shadowsocks 服务，iOS 上的软件也是填写这些内容： 如此，便可以科学上网了，一键安装，就是这么简单～接下来是略微专业一点的做法，需要了解一些 Linux 命令。 自己搭建 Shadowsocks 服务接下来，该是此篇博客最有趣的内容了：操作 Linux 服务器，搭建 Shadowsocks 服务。 首先如果你使用了上一种方式一键安装了 Shadowsocks，那么，在采用这种方式搭建服务前应当卸载上一个 Shadowsocks 服务，上一张图片所在网页的最下方会有一键卸载：Unintsall Shadowsocks Server。如果不卸载该服务，会和接下来自己手动安装的 Shadowsocks 服务冲突。 保险起见，你可以选择从头来过：重装系统。这里又是开始～如下图选择一款操作系统来安装，墙裂建议选择 centos-7-x86_64-bbr，因为接下来安装 Shadowsocks 要依赖 python2.7 版本，而 centos-6 默认安装的是 python2.6： 重装完成后，你会受到一封告知邮件，并且附有一份临时服务器登录密码。当然，你也可以点击上图中的 Root password modification 重新生成一份密码。注意：生成密码前需要先 stop 服务器。 连接服务器开启终端，使用 ssh 远程连接服务器：1ssh root@you_server_ip -p you_server_port you_server_ip：你的服务器 ip 地址，you_server_port：你的服务器端口号，回车输入 root 登录密码即可。如果你之前 ssh 登录过服务器，又重装之后再次登录可能会有以下问题： @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ WARNING: POSSIBLE DNS SPOOFING DETECTED! @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 执行如下命令，将 known_hosts 文件里包含你服务器 ip 地址那一段删掉即可成功连接：1vim ~/.ssh/known_hosts 为方便之后 ssh 登录，可执行以下命令修改 root 密码：1passwd 回车输入新密码确认即可。 安装 Shadowsocks安装 setuptools 和 pip ，在终端执行以下命令：1yum install python-setuptools &amp;&amp; easy_install pip 安装 Python-Gevent，用于提高性能，在终端执行以下命令：123yum install libeventyum install python-develpip install gevent 安装 M2Crypto，用于加密的第三库，在终端执行以下命令：1234yum install openssl-develyum install swigyum install gccpip install M2Crypto 安装 Shadowsocks 服务端，在终端执行以下命令：1pip install shadowsocks 配置 Shadowsocks新建配置文件，在终端执行以下命令：1vi /etc/shadowsocks.json 编辑 shadowsocks.json 文件内容如下：12345678910111213&#123; "server":"you_server_ip", "local_address":"127.0.0.1", "local_port":1080, "port_password":&#123; "9000":"9000password", "9001":"9001password", "9002":"9002password" &#125;, "timeout":300, "method":"rc4-md5", "fast_open": false&#125; 解释一下： Name Explanation server 服务器 IP 地址 server_port 服务器端口号 local_address 本地代理地址 local_port 本地代理端口 port_password Shadowsocks 服务端口号及密码 timeout 超时断开，以秒为单位 method 加密方式，推荐使用 rc4-md5，比 aes-256-cfb 速度快很多 fast_open 是否使用TCP 后端开启与停止 Shadowsocks 服务，在终端执行以下命令：12ssserver -c /etc/shadowsocks.json -d startssserver -c /etc/shadowsocks.json -d stop 或者选择前端开启 Shadowsocks 服务，在终端执行以下命令：执行该命令当连接成功或出错时终端会打印详情信息，建议第一次开启 Shadowsocks 服务时执行该命令：1ssserver -c /etc/shadowsocks.json 至此，使用 Shadowsocks 客户端就可以科学上网了。 设置服务器开机启动设置开机启动，在终端执行以下命令：1vi /etc/rc.local 将以下开启 Shadowsocks 服务命令加入 rc.local 文件：1ssserver -c /etc/shadowsocks.json -d start 保存退出即可。执行命令 reboot 重启服务器试试看～ 至此，已经可以科学上网，秒开 Youtobe，1080无压力～ 给安装 centos-6 的补充补充一：如果你装的系统是 centos-6 那么执行 pip install ... 或许会有以下报错： DEPRECATION: Python 2.6 is no longer supported by the Python core team, please upgrade your Python. A future version of pip will drop support for Python 2.6 说明，你的 Python 版本是 2.6，终端执行命令 Python -V 查看 Python 版本。你可以执行以下命令简单升级 Python2.7123yum install centos-release-SCLyum install python27. /opt/rh/python27/enable 然后执行命令 Python -V 验证此时的 Python 版本，注意，此时不要更换操作目录，接下来的安装和启动 Shadowsocks 都需要在这个目录下完成，因为你的 Shadowsocks 就是用这个目录下的 Python2.7 安装的。设置开机自启动时， 也应该在 rc.local 文件里加入以下命令：12. /opt/rh/python27/enablessserver -c /etc/shadowsocks.json -d start 补充二：然而，当你第二次在 python2.6 环境下执行 pip install shadowsocks 也许会有如下提示： DEPRECATION: Python 2.6 is no longer supported by the Python core team, please upgrade your Python. A future version of pip will drop support for Python 2.6Requirement already stisfied:shadowsocks in /usr/lib/python2.6/site-packages 虽然有报错，但你的确已经在 python2.6 环境下安装好了 shadowsocks 服务，那么在任意目录下你都可以执行 ssserver -c /etc/shadowsocks.json 命令开启 shadowsocks 服务。 补充三：你当然可以自行 Google 完全升级 Python 的方法。 后记以上便是我搭建个人 VPS，实现科学上网的全过程，希望对大家有所帮助，欢迎吐槽～ 转载请保留原文地址：http://gonghonglou.com/2017/07/10/ss-vps 参考链接 安装SSserver和配置(二)]]></content>
      <categories>
        <category>Technology</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[UITableViewCell计算行高的几种方式]]></title>
    <url>%2F2017%2F07%2F05%2Fcell-height%2F</url>
    <content type="text"><![CDATA[当我还是小白时（比现在更白的时候）对于 UITableViewCell 的行高问题还是比较头疼的，当然这个算是 iOS 开发中相当基础的内容了，但是当时的我就想过，将 UITableViewCell 的行高问题解决了一定写一篇总结博客，所以就有了这篇博客。尽管拖了这。么。久。。。 iOS 的界面中，UITableView 应该是用的最多的控件之一了吧：微信列表、聊天记录、朋友圈、微博 time line。。。哪哪离不开 UITableView。而 UITableView 则是由 UITableViewCell 组成的，这些 cell 有的行高是固定的，大部分则需要根据内容反计算行高来展示。本篇博客则来介绍 UITableViewCell 计算行高的几种方式。 固定行高有相当一部分 UITableView 的行高是固定的，这种 cell 在代码书写和代码性能上相比而言就简单了许多，有以下两种方式设定行高： 统一设定1self.tableView.rowHeight = 44; // 系统自带的 cell 的行高大概就是 44 优点：这种方式最为简单。 缺点：相对的对 tableView 的可控性也最弱，它会将 tableView 所有的 cell 高度统一设置为 44。 通过代理设定通过实现 UITableViewDelegate 方法，同样可以控制 tableView 的行高。 123456789101112131415161718- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath &#123; // 1. // return 44; // 2. // if (tableView == self.tableView1) &#123; // return 44; // &#125; else &#123; // return 88; // &#125; // 3. if (indexPath.row == 1) &#123; return 44; &#125; else &#123; return 88; &#125;&#125; 优点：采用这种实现代理的方法可以对不同的 tableView 、tableView 中不同的 section、row，进行判断分别设置，可控性更强。 缺点：因为在每次展示 cell 时都会调用了一次该代理方法，所以较于第一种方法一些性能损耗。 这个缺点在苹果介绍 rowHeight 属性的文档里也有指明： There are performance implications to using tableView:heightForRowAtIndexPath: instead of rowHeight. Every time a table view is displayed, it calls tableView:heightForRowAtIndexPath: on the delegate for each of its rows, which can result in a significant performance problem with table views having a large number of rows (approximately 1000 or more). 所以，如果你的 tableView 的行高是统一的、固定的，那么最好采用第一种方法，直接设置 rowHeight。 不定行高固定行高的 tableView 已经算是小儿科了，但是也属于 UITableViewCell 行高的范畴，所以还是简单提了一下。那么，当 tableView 的行高不固定时，有以下几种计算方式。 估算行高其实，UITableView 的 rowHeight 可以设置为 UITableViewAutomaticDimension，顾名思义，cell 可以设置为自动计算行高。然而，仅仅将 rowHeight 设置为 UITableViewAutomaticDimension 对自计算行高是不起效的，这时候就需要另一个属性：estimatedRowHeight。 iOS8 苹果推出了 self-sizing 的概念。UITableView 在 iOS7 就增加了一个属性： estimatedRowHeight ，苹果是这样描述的： Providing a nonnegative estimate of the height of rows can improve the performance of loading the table view. If the table contains variable height rows, it might be expensive to calculate all their heights when the table loads. Using estimation allows you to defer some of the cost of geometry calculation from load time to scrolling time.When you create a self-sizing table view cell, you need to set this property and use constraints to define the cell’s size.The default value is 0, which means there is no estimate. 你可以使用这个属性来给 cell 估算行高，但是默认值为 0，不会进行估算。所以如果想开启估算行高的话，必须设置 estimatedRowHeight，如： 12self.tableView.estimatedRowHeight = 60;self.tableView.rowHeight = UITableViewAutomaticDimension; 将 estimatedRowHeight 设置为一个大概的估计行高值即可，没有严格的限制。比如你的 cell 高度大概在 50 到 100 之间，那么你可以将 estimatedRowHeight 设置为 75；rowHeight 的默认值为 UITableViewAutomaticDimension，所以第二行可以省略。 然后就是对你的 cell 进行布局设置，这里以 Masonry 为例（AutoLayout 的话，这个框架大家应该都在用吧？～）伪代码如下： 12345678910111213141516171819202122232425262728- (instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier &#123; self = [super initWithStyle:style reuseIdentifier:reuseIdentifier]; if (self) &#123; __weak __typeof(self)weakSelf = self; UILabel *label1 = [UILabel new]; [self.contentView addSubview:label1]; [label1 mas_makeConstraints:^(MASConstraintMaker *make) &#123; __strong __typeof(weakSelf)strongSelf = weakSelf; make.top.equalTo(strongSelf.contentView).with.offset(10); make.left.equalTo(strongSelf.contentView).with.offset(10); make.right.equalTo(strongSelf.contentView).with.offset(-10); make.height.mas_equalTo(22); // ① &#125;]; UILabel *label2 = [UILabel new]; [label2 setNumberOfLines:0]; [self.contentView addSubview:label2]; [label2 mas_makeConstraints:^(MASConstraintMaker *make) &#123; __strong __typeof(weakSelf)strongSelf = weakSelf; make.top.equalTo(label1.mas_bottom).with.offset(10); make.left.equalTo(label1); make.right.equalTo(label1); make.bottom.equalTo(strongSelf.contentView.mas_bottom).with.offset(-10); // ② &#125;]; &#125; return self;&#125; 注释①：该条约束可以注释掉，然后将 label1 设置为 [label1 setNumberOfLines:0]; 这样 label1 就可以根据内容自动计算高度。注释②：必须设置该条约束。为了确定 cell 的高度，最接近 cell bottom 的控件需要设置一个距离 cell bottom 的约束。 布局结果大概是这样的效果： 优点：代码书写简单，页面布局快捷。在 cell 的 initWithStyle: 方法里就已经新建各个控件并将位置设置好，并且不需要单独计算 cell 的高度。 缺点：效率低，稍微复杂些的页面就能感觉到 tableView 滑动时的掉帧。 代理计算行高首先来执行一波伪代码，用打印来观察各个代理方法的执行顺序： 1234567891011121314151617181920#pragma mark - UITableViewDataSource- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section &#123; NSLog(@"---方法 : numberOfRowsInSection: ---section : %ld", (long)section); return 10;&#125;- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; NSLog(@"---方法 : cellForRowAtIndexPath: ---row : %ld", (long)indexPath.row); UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@"cell"]; return cell;&#125;#pragma mark - UITableViewDelegate- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath &#123; NSLog(@"---方法 : heightForRowAtIndexPath: ---row : %ld", (long)indexPath.row); return cellHight;&#125; 控制台打印结果如下： ①：首先执行 numberOfRowsInSection: 方法，返回 cell 个数为 10。②：其次执行的就是 heightForRowAtIndexPath: 方法，如上图，此时执行该方法会将所有 cell 的高度全部返回。③④⑤：这时候就开始执行 cellForRowAtIndexPath: 方法，因为当前页面只能布局 3 条 cell，所以该方法会被执行三次。并且，执行一次 cellForRowAtIndexPath: 方法紧接着就会执行一次 heightForRowAtIndexPath: 方法返回 cell 高度。 因此，当我们从网络或者本地缓存中获取到所需数据（ array ）后，可以直接执行代码： 1[self.tableView reloadData]; 然后就会调用 cellForRowAtIndexPath: 方法和 heightForRowAtIndexPath: 方法。 cell 的 initWithStyle: 方法：123456789101112- (instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier &#123; self = [super initWithStyle:style reuseIdentifier:reuseIdentifier]; if (self) &#123; UILabel *label1 = [UILabel new]; [self.contentView addSubview:label1]; UILabel *label2 = [UILabel new]; [label2 setNumberOfLines:0]; [self.contentView addSubview:label2]; &#125; return self;&#125; 我们可以在 cellForRowAtIndexPath: 方法进行 cell 布局，如： 123456789101112131415161718- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@"cell"]; if (!cell) &#123; cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:@"cell"]; &#125; // 内容 cell.label1.text = @"..."; cell.label2.text = @"..."; // 布局 CGFloat viewWidth = [UIScreen mainScreen].bounds.size.width; cell.label1.fream = CGRectMake(10, 10, viewWidth-20, 22); CGFloat label2Height = [text boundingRectWithSize:CGSizeMake(viewWidth-20, MAXFLOAT) options:NSStringDrawingUsesLineFragmentOrigin attributes:@&#123;NSFontAttributeName:font&#125; context:nil].size.height; cell.label2.fream = CGRectMake(10, 10, viewWidth-20, label2Height); return cell;&#125; 布局结果大概是这样的效果： 然后在 heightForRowAtIndexPath: 方法里根据 array 数据计算 cell 的高度，如：12345- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath &#123; CGFloat viewWidth = [UIScreen mainScreen].bounds.size.width; CGFloat label2Height = [text boundingRectWithSize:CGSizeMake(viewWidth-20, MAXFLOAT) options:NSStringDrawingUsesLineFragmentOrigin attributes:@&#123;NSFontAttributeName:font&#125; context:nil].size.height; return 10 + 22 + 10 + label2Height + 10;&#125; 优点：通过 feram 的方式能够提高布局效率 缺点：因为每次 cell 将要出现时都去执行一次 heightForRowAtIndexPath: 所以效率还是不够高，而且行高没有得到缓存，造成大量不必要的计算上的浪费。所以就有了下边这种方法。 提前计算行高这种方式是出自 MVVM 的产物，因为最近都在使用 MVVM 框架，所有的计算都放到了 viewModel 里，所以在 viewModel 从网络或者本地缓存拿到数据后接着就会处理，将原始数据处理封装成 cell 的 VO（view object） 类对象，该 VO 类里包含着 cell 所需要的展示内容和尺寸，如： 12345678910@interface TableViewCellVO : NSObject// 数据@property (nonatomic, copy) NSString *label1Text;@property (nonatomic, copy) NSString *label2Text;// 尺寸@property (nonatomic, assign) CGRect label1Fream;@property (nonatomic, assign) CGRect label2Fream;// 行高@property (nonatomic, assign) CGFloat cellHeight;@end 然后将处理好的 cellVOArray 传给 UITableView 的数据源和代理，在 cellForRowAtIndexPath: 方法直接赋值： 1234567891011121314- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@"cell"]; if (!cell) &#123; cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:@"cell"]; &#125; TableViewCellVO *cellVO = cellVOArray[indexPath.row]; // 数据 cell.label1.text = cellVO.label1Text; cell.label2.text = cellVO.label2Text; // 布局 cell.label1.fream = cellVO.label1Fream; cell.label2.fream = cellVO.label2Fream; return cell;&#125; 在 heightForRowAtIndexPath: 方法里直接返回行高： 1234- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath &#123; TableViewCellVO *cellVO = cellVOArray[indexPath.row]; return cellVO.cellHeight&#125; 优点：行高与 cell 内的各控件尺寸都提前计算好，在执行 cellForRowAtIndexPath: 方法和 heightForRowAtIndexPath: 方法时比较快，且行高得到缓存，避免了冗余的计算。 缺点：在从网络或者本地缓存拿到数据之后，执行 [self.tableView reloadData]; 之前需要花费时间处理数据及计算 fream。这里需要谨慎处理数据，可以采用多线程等技术缩短数据处理的时间。 因为在数据处理上所花费的时间要远小于页面滚动时所消耗的时间。凡是涉及页面的操作都是相当耗费时间的，相比而言对于 cpu 在处理数据上的时间就可以忽略不计了，毕竟我们所要处理的数据都不会太大，如果数据过多的话可以做分次获取处理（下拉刷新操作），所以这里的缺点相对于上一种方法还是可以忍受的。 XIB 方式处理 UITableViewCell 的行高问题对于纯 Code 和 SB 方式的页面布局问题业界已经相爱相杀了很久，各有各的道理。我的观点是：哪种布局方式适合自己就好了，看个人喜好。相比于 SB 的“所见即所得”，快速布局等，我个人更喜欢纯 Code 的方式，对代码的可控性更强（亦不排除我个人是比较喜欢 Coding 的因素）。不过，如果你是偏好 SB 的布局方式，采用 XIB 方式处理 UITableViewCell，那么你可以看看sunnyxx 的 UITableView-FDTemplateLayoutCell（点击可查看GitHub）这种解决方案。而且，本文的前一部分也参考了 sunnyxx 的这篇博客 优化UITableViewCell高度计算的那些事 ，推荐阅读。 后记 小白出手，请多指教。如言有误，还望斧正！ 转载请保留原文地址：http://gonghonglou.com/2017/07/03/cell-height]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Say Bye 2016]]></title>
    <url>%2F2016%2F12%2F26%2Fsaybye2016%2F</url>
    <content type="text"><![CDATA[嘿，不觉间 2016 马上就要结束了，所以，这一年你都干了啥？ 2016 年，最大的变动就是毕了业，十六年的求学历程 结束了，然后，从一名学生变成了员工！ 怀念毕业了，才发现真的会怀念学生时代。 早晨拖着身子爬起来上课，然而课上少有听讲，就那样浪费着时间蚕食着生命，可那也是我的大学生活啊，不再有的挥霍时光。到学校食堂吃饭，乌泱泱的人群，打饭都要先占座，可以的，那也是我怀念的。每学期的宿舍聚餐、班级聚会、元旦晚会，终究会怀念身处群体中的日子，和身处公司不同。真心希望有一天会在社会团体中找到校园中的集体感，大概就像 Nicholas Tse 描述的 PO 那样的团体吧，如果是自己建立的就最完美了，Fighting ！做学生时没有发现，原来这个社会对于学生的照顾这么多，电话费、住宿费、食堂、车票、景区门票等等等等这些有形的和那些无形的对于「学生」这一称号，每每感受到这一点在小小怀念学生时代之外都会多少感概这个社会还是很美好的，嗯。毕业后每当看到朋友圈有人晒出学校照片都会特别感概真想回去看看，当初吃够了的商业街现在也是很怀念扬州炒饼和如意捞的火锅小料。 期待未知年后的大学聚会，我们校园一聚。 选择2016 年 1 月 11 日实习入职，马上我也要工作满一年了呢。当时找工作时收到了几份 offer ，最终选择了卓骥（现在的公司），也很幸运遇到了卓骥： 1、实习入职的第二天就开始负责写 iPad 项目重构版的网络请求库。2、实习结束回学校前的一个月开始接手整个 iPad 项目的重构版本。3、正式入职后花费了四个月的时间完成了 iPad 项目重构的大部分内容。4、紧接着接手了公司所有 iOS 业务（ iPad 和 iTouch 端）。5、之后很快将会进行 iTouch 项目的重构 这些都让我觉得：当初的选择没错。 成绩2016，应该是我技术道路的正式开端，因为这些，所以还不算荒废： 1、算上这篇，今年该是写了十二篇博客。不像那些大 V 的博客对于求学者有较高的技术学习和参考价值，迄今为止「与佳期的个人博客」的主要内容或者功能应该是给自己的技术总结吧。切身体会对于很多技术，代码实现和博客输出还是有很大差距的，开始写某项技术博客前以为对该项技术已经掌握了，开始后和结束后才发现自己 too young too simple ，每篇技术博客写下来都觉得获益匪浅能学到更多知识，即便这样我也深知还仅是皮毛而已。继续努力吧，希望以后自己的博客输出也能在技术深度上对别人有所帮助和影响。2、顺利完成毕业设计，还要感谢马根老师（我的学术指导老师）我的毕业设计也是做的 iOS 的一款跳蚤市场类软件。3、完成了公司 iPad 项目重构版的网络请求库的开发。熟悉了网络请求、数据解析和部分缓存操作。4、完成了公司 iPad 的重构项目，主要代码成绩就是这个了，花费了约四五个月的时间，大部分的技术成长也都在这里了，从控件使用、页面布局、业务实现到设计模式、工程架构。5、接手公司所有 iOS 业务（ iPad 和 iTouch 端）。主要成长了 Debug 的能力吧以及对公司业务的熟悉。6、上线了一款个人 App：RDER，一款轻量极简的 RSS 订阅软件。大概有七八千行代码，虽然软件简单但是一点一滴都是自己细心雕琢的，因为这款软件也了解了关于一款软件上线的所有流程，而且用到了 relam ，和 sqlite 有了比较。 以上，今年大概写了有近十万行代码。 幸运一直都觉得自己少有努力，更多是幸运。 大一大二浑浑噩噩度过了两年，大二末总觉得该做点什么，所以办了个兼职中心，起名「曙光」。希望更多和我一样在大学迷茫的同学们能够因此看到方向，至少生活不再荒诞。然而最终也没办成个样子，现在看来那种职业生活的确不是我喜欢的，所以没有成样子也是有原因的。可也正因为这个兼职中心才让我遇到了马根老师（还要多谢班主任盛莉老师的引荐），遇到了编程，遇到了 iOS ，遇到了自己真正喜欢的东西。 大三到大四有近一年的时间都待在马老师的实验室里，机电楼 C 228。这间实验并不是开放实验室，偶尔有班级过来做实验的时间我就会带电脑到图书馆，所以大部分时间实验室只有我一个人在，偶尔晚上马老师也在。早上八九点钟吃过早饭到实验室，然后午饭、晚饭，晚上大概十点半十一点回宿舍，就这样日复一日匆匆过了一年。没有无聊反而一直很充实。那时候打开浏览器真的就感觉“徜徉在（互联网的）知识的海洋里”，那是我上了十几年学第一次有“知识的海洋”的概念。经过物联网 -&gt; 计算机 -&gt; 前端 -&gt; iOS -&gt; Objective-C 这一层层，要学的知识仍然像“海洋”一样望不到头，每天都是鼓足干劲的学习这些编程技术，从最基础的编程基础开始，for 循环、页面布局、多线程、数据库、网络编程、设计模式、开源代码……每阶段都有学不完的技术。当然也不是一直热情高涨，最受打击的应该是在继续学习的路上，对于刚开始一块崭新技术的迷惑，比如多线程和数据库，刚开始接触的时候真的是一脸懵逼，切身体会在那种时候一份基础系统的学习资料有多重要，一份好的技术博客或者技术文档有多重要！ 总感觉自己是幸运的：幸运的在大学快结束的时候找到了自己喜欢的东西；幸运的来到上海在上海海事大学和上海大学秋季招聘会上拿到了几份 offer ；幸运的在这几份 offer 里遇见的现在的公司—卓骥，才有了上边的“这些都让我觉得：当初的选择没错。” 幸运的父母都在上海可以住在一起；幸运的和父母住在一起不必负担房租；幸运的和父母住在一起连生活费都省了。因为这接连的三个幸运才能把钱攒起来一分不剩的花在了自己任性花的地方。而且我一直觉得迈入社会的第一年是我们人生负担最小收入最低的一年，如果说是要轻奢生活不虑积蓄，那这一年应该是最合适的时间了，所以我做了一名合格的月光族，有（了）钱任性所以真的是一分不剩。。。 遗憾1、生活上，以往的宿舍聚餐。 离开学校的前一天晚上宿舍最后一次聚餐，我们拿着班里分得的班费找了一家烧烤狠搓了一顿，胡吃海喝侃天侃地。那天说了好多话，而以往的宿舍聚餐因为酒量原因和吃货基因大家很少喝酒只顾吃吃吃，这应该就是最遗憾的了。只有喝了酒大家才能推心置腹吧，所以那晚喝了很多酒，带着怀念和不舍，口口声声说着我们再聚再聚。曾经你让我不爽我让你不快的事如今都成了加深我们情义的助力。我们吹牛打屁的时候顿顿默默带了一波节奏，人高马大的他竟然落了几滴猫尿，我看到后立马大笑指着他：“卧槽，你竟然…” 然后突然哽咽，同样泪流不止。那天喝的很真心。 小插曲：第二天起床就吐了还带着块块“血色”，肠胃一直不好上次喝酒吐了一夜胆汁，这次竟然吐了血，吓坏了。可是毕业离校不想让室友们担心所以装作无事。此事过了个把月知乎上看到那个笑话才会回忆起，那晚喝过酒回宿舍好像顺便买了个西瓜。哈，哈哈哈哈…… 2、技术上，遇到编程的时间太晚。 在大三初开始接触编程，上学期一直在入门 Java ，因为是刚入门所以进度很慢。看了一学期的 Java 大概熟悉了编程语言基础，对于移动端有 iOS 和 Android 两大阵营，都想学可是显然时间来不及，所以选择了逼格略高且逼格高就是我所爱的 iOS 。即便如此，学习 iOS 的时间也只有大三下学期到大四上学期，15 年大约十月底十一月就开始找工作了。所以大学里学习 iOS 的时间太短，编程生涯开始的太晚。如果可以早一年甚至两年的话至少在毕业时对于应聘这件事会游刃有余的多吧。 计划有了大学技术起步晚的遗憾，现在怎么能不早点做打算。 年初的时候大概有了自己的第一个“五年计划”：两年上海，两年北京，2020 年的时候稳定于杭州。至于届时是买房买车平淡安稳的上班生活还是破釜沉舟不甘平庸的技术创业，就在下一个“五年计划”里决定吧，无论哪种，对这五年来说主要目的就是技术积累。然而在毕业的那段时间还是感觉又落入了类大学迷茫期的循环，接下来的五年除了积累技术还应该往什么方向思考。大学：除了学习学习还能干嘛？毕业：除了技术技术还能干嘛？在接下来的五年能否像大学末期幸运的找到兴趣职业那样也幸运的找到兴趣事业呢？而且既然有了上边的技术遗憾当然是想越早发现越早准备的好。 现在，马上就到年底了心里也大概有了底，虽然不够坚信但至少有了大致的方向。我们都很脆弱当然想尽量避免事业的打击，还好还有一段时间可以慢慢谋取，还好这一点在技术上是有优势的。16 年就要结束了，接下来就是 “1+2”，此处省略三年的时间…… 总要有一些更实际有生活的计划： 旅行：（或）1、三月份去趟黄山，2、五月份骑行青海湖，3、十月份去趟拉萨 读书：1、技术书籍，2、龙应台的书， 3、其他一些小说 技术：1、维护更新 RDER ，2、写一款第三方微博客户端，3、更新技术博客，4、写一款牛逼的工具类 App（如果来得及） 呼～工作量还真不小，时间真的蛮紧张，撸开袖子，干吧！ 相信天空和大海，对于你，全是未来！]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS应用程序语言本地化及应用内语言设置]]></title>
    <url>%2F2016%2F10%2F29%2Fset-language%2F</url>
    <content type="text"><![CDATA[Xcode 新建一个工程的默认语言是英文，所以你在 app 里粘贴复制都是显示的 copy paste，你可以通过在 info.plst 文件里选择 Localization native development region 来设置不同语言。 可是如果你想在软件内选择设置语言，为软件添加多语言选择功能就需要一番折腾了，倒也简单，只不过还是有几个坑的。以下是一篇详细介绍为软件配置多语言选项的博客，走起 ➜ ➜ ➜ 关于 NSBundle在开始正式文章之前你或许应当先搞明白 NSBundle 是什么东西。 Bundle 是一个目录，其中包含了在程序会使用到的资源，包含了如图像、声音、程序中需要用到的文件，甚至是编译好的代码等等。而在实现软件内配置语言的时候就是通过 Bundle 的路径去获取配置文件，根据这个配置文件取出对应的字体渲染到 view 上。 当然，配置程序语言只是 Bundle 的一种用途。还可以用 Bundle 去获取工程中 info.plist 的详细信息，比如：123456789101112131415// 获取版本号：Bundle Short VersionNSString *shortVersion = [[[NSBundle mainBundle] infoDictionary] objectForKey:@"CFBundleShortVersionString"];// 获取版本号：Bundle versionNSString *version = [[[NSBundle mainBundle] infoDictionary] objectForKey:@"CFBundleVersion"];// 获取应用标识：Bundle identifierNSString *bundleIdentifier = [[[NSBundle mainBundle] infoDictionary] objectForKey:@"CFBundleIdentifier"];// 获取应用名称：Bundle display nameNSString *bundleDisplayName = [[[NSBundle mainBundle] infoDictionary] objectForKey:@"CFBundleDisplayName"];// 获取Bundle nameNSString *bundleName = [[[NSBundle mainBundle] infoDictionary] objectForKey:@"CFBundleDisplayName"];// 获取 app 包路径NSString *path = [[NSBundle mainBundle] bundlePath];// 获取 app 资源目录路径NSString *resPath = [[NSBundle mainBundle] resourcePath];... 大概明白 NSBundle 是怎么回事了吧，接下来就正式开始应用程序语言本地化及应用内语言设置。 配置 Project添加语言如下图，点击 PROJECT -&gt; info -&gt; Localizations 这里默认只有 English 点击下方的加号可以添加你想要的语言，比如这里添加的中文 Chinese(Simplifid) 。 注意： zh-Hans 是简体中文， zh-Hant 是繁体中文。 新建 .strings 配置文件1、Command + N 新建 Strings File 文件，命令为 RDLocalizable ，会生成一份 RDLocalizable.strings 文件。 2、选中RDLocalizable.strings 文件，如下图操作，点击 Localize... 按钮，左侧弹框中选择语言。 3、之后右侧会如下图显示，勾选上你想要的语言即可（Base 无用） 4、当勾选两门语言后，会发现RDLocalizable.strings 文件可以展开并存在两个配置文件，一份英文，一份中文。分别在两个文件内输入对应的语言，比如在英文文件里输入：123"收录" = "Collection";"订阅" = "Subscription";"我的" = "Mine"; 中文文件里输入：123"收录" = "收录";"订阅" = "订阅";"我的" = "我的"; 前边对应 键(key) ，后边对各个语言的 值(value)。看后面的 使用方法 就会明白了。 至此，对工程的配置已经完成。接下来要做的就是获取软件语言、设置语言、监听语言改变。。。 创建多语言设置工具类因为该工具类比较简单，直接将代码贴出来吧，后面会介绍一些坑。因为是一个继承于 NSObject 的工具类，都是使用类方法实现功能，以便类名直接调用。 头文件.h12345678910111213141516171819202122232425262728293031323334353637383940//// RDLocalizableController.h// rder//// Created by gonghonglou on 2016/10/29.// Copyright © 2016年 gonghonglou. All rights reserved.//#import &lt;Foundation/Foundation.h&gt;#define RDLanguageKey @"userLanguage"#define RDCHINESE @"zh-Hans"#define RDENGLISH @"en"#define RDNotificationLanguageChanged @"rdLanguageChanged"#define RDLocalizedString(key) [[RDLocalizableController bundle] localizedStringForKey:(key) value:@"" table:@"RDLocalizable"]@interface RDLocalizableController : NSObject/** * 获取当前资源文件 */+ (NSBundle *)bundle;/** * 初始化语言文件 */+ (void)initUserLanguage;/** * 获取应用当前语言 */+ (NSString *)userLanguage;/** * 设置当前语言 */+ (void)setUserlanguage:(NSString *)language;@end 实现文件.m12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//// RDLocalizableController.m// rder//// Created by gonghonglou on 2016/10/29.// Copyright © 2016年 gonghonglou. All rights reserved.//#import "RDLocalizableController.h"static RDLocalizableController *currentLanguage;@implementation RDLocalizableControllerstatic NSBundle *bundle = nil;// 获取当前资源文件+ (NSBundle *)bundle&#123; return bundle;&#125;// 初始化语言文件+ (void)initUserLanguage&#123; NSString *languageString = [[NSUserDefaults standardUserDefaults] valueForKey:RDLanguageKey]; if(languageString.length == 0)&#123; // 获取系统当前语言版本 NSArray *languagesArray = [[NSUserDefaults standardUserDefaults] objectForKey:@"AppleLanguages"]; languageString = languagesArray.firstObject; [[NSUserDefaults standardUserDefaults] setValue:languageString forKey:@"userLanguage"]; [[NSUserDefaults standardUserDefaults] synchronize]; &#125; // 避免缓存会出现 zh-Hans-CN 及其他语言的的情况 if ([[RDLocalizableController chinese] containsObject:languageString]) &#123; languageString = [[RDLocalizableController chinese] firstObject]; // 中文 &#125; else if ([[RDLocalizableController english] containsObject:languageString]) &#123; languageString = [[RDLocalizableController english] firstObject]; // 英文 &#125; else &#123; languageString = [[RDLocalizableController chinese] firstObject]; // 其他默认为中文 &#125; // 获取文件路径 NSString *path = [[NSBundle mainBundle] pathForResource:languageString ofType:@"lproj"]; // 生成bundle bundle = [NSBundle bundleWithPath:path];&#125;// 英文类型数组+ (NSArray *)english &#123; return @[@"en"];&#125;// 中文类型数组+ (NSArray *)chinese&#123; return @[@"zh-Hans", @"zh-Hant"];&#125;// 获取应用当前语言+ (NSString *)userLanguage &#123; NSString *languageString = [[NSUserDefaults standardUserDefaults] valueForKey:RDLanguageKey]; return languageString;&#125;// 设置当前语言+ (void)setUserlanguage:(NSString *)language &#123; if([[self userLanguage] isEqualToString:language]) return; // 改变bundle的值 NSString *path = [[NSBundle mainBundle] pathForResource:language ofType:@"lproj"]; bundle = [NSBundle bundleWithPath:path]; // 持久化 [[NSUserDefaults standardUserDefaults] setValue:language forKey:RDLanguageKey]; [[NSUserDefaults standardUserDefaults] synchronize]; [[NSNotificationCenter defaultCenter] postNotificationName:RDNotificationLanguageChanged object:currentLanguage];&#125;@end 使用方法： 1、在 AppDelegate 的 - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions 方法里初始化该工具类，并监听通知：1234// 语言初始化[RDLocalizableController initUserLanguage];// 监控语言切换[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(languageChange:) name:RDNotificationLanguageChanged object:nil]; 2、记得在 - (void)applicationWillTerminate:(UIApplication *)application方法里删除通知：1[[NSNotificationCenter defaultCenter] removeObserver:self name:RDNotificationLanguageChanged object:nil]; 3、实现通知方法：1234- (void)languageChange:(NSNotification *)note&#123; // 在该方法里实现重新初始化 rootViewController 的行为，并且所有带有文字的页面都要重新渲染 // 比如：[UIApplication sharedApplication].keyWindow.rootViewController = ...;&#125; 4、使用 RDLocalizedString(&lt;#key#&gt;)方法 给所有文字添加本地化语言方法：123label.text = RDLocalizedString(@"收录");[button setTitle:RDLocalizedString(@"订阅") forState:UIControlStateNormal];... 5、更改语言方法：12345// 设置中文[RDLocalizableController setUserlanguage:RDCHINESE];// 设置英文[RDLocalizableController setUserlanguage:RDENGLISH]; 至此，对于应用程序语言本地化及应用内语言设置的功能就已经可以实现了。接下来是对遇到的几个坑的说明。 多语言设置的「坑」关于更改语言后重新初始化页面语言更改后，要重新渲染view，所以应该在更改语言之后回到根目录。不仅页面需要初始化，如果页面数据在 viewModel 里，那么该 viewModel 也应当初始化，因为字体是 RDLocalizedString(&lt;#key#&gt;) 这个方法从 .strings 配置文件里取出来的，更改语言后必须重新取一次。 当然也不是一定要留在根目录，有几种页面友好的解决方案： 1、更改语言功能一般会放在「我的」页面 push 出来的某一级页面，可以初始化 rootViewController 并且将之前 push 出来的几级 viewController 手动添加到 mineViewController.navigationController.viewControllers 这个数组中。这样页面就不会产生太大的错落感。 2、在每一个页面写一个检测语言改变的通知的方法。当接受到通知后就将该页面重新布局一次以更改字体。 PS：在这个问题上，感觉支付宝比微信做的界面跳转友好的多。。。 关于本地化语言的宏定义 RDLocalizedString(&lt;#key#&gt;)系统自带的方法是：NSLocalizedString(&lt;#key#&gt;, &lt;#comment#&gt;)，这也是一份宏定义：12#define NSLocalizedString(key, comment) \ [NSBundle.mainBundle localizedStringForKey:(key) value:@"" table:nil] 能看到它调用的是 NSBundle.mainBundle ，而我们在更改语言的工具类里的 bundle 已经更改了。所以系统的 NSLocalizedString(&lt;#key#&gt;, &lt;#comment#&gt;) 已经失效，必须重写一份宏定义：1#define RDLocalizedString(key) [[RDLocalizableController bundle] localizedStringForKey:(key) value:@"" table:@"RDLocalizable"] 1、必须使用自己的类名来调用类方法 [RDLocalizableController bundle] 以获取自己的 bundle 2、table 后的参数为 .strings 文件的文件名，若你创建的文件名为 Localizable.strings ，则该参数可为 nil ，系统默认按 Localizable.strings 查找。否则必须配置文件名，且只是文件名，不加 .stringd 后缀。 关于初始化语言 [RDLocalizableController initUserLanguage]在 initUserLanguage 方法中有这样一段代码来做判断 1234567if ([[RDLocalizableController chinese] containsObject:languageString]) &#123; languageString = [[RDLocalizableController chinese] firstObject]; // 中文&#125; else if ([[RDLocalizableController english] containsObject:languageString]) &#123; languageString = [[RDLocalizableController english] firstObject]; // 英文&#125; else &#123; languageString = [[RDLocalizableController chinese] firstObject]; // 其他默认为中文&#125; 各位可能会对这个判断比较疑惑，在这之前已经有判断了：先获取用户设置的语言，有则使用用户设置的语言，没有则使用系统语言。 然而因为某些原因用户设置过的语言（如：zh-Hans）会在另一个相同工程运行之后将该语言更改为zh-Hans-CZ；或者用户将系统语言设置为日本语或其他语言。 出现以上情况时 RDLocalizedString(&lt;#key#&gt;) 这个方法从 .strings 配置文件里是去不到对应的字体，就会返回空。后果轻则页面一片空白了，重则直接 crash ，如：1NSArray *array = @[RDLocalizedString(@"收录"), RDLocalizedString(@"订阅"), RDLocalizedString(@"我的")]; // 数组不能存空 就想使用 NSLocalizedString(&lt;#key#&gt;, &lt;#comment#&gt;) 方法1、有一种极端情况，比如：软件需要配置多国语言，很多很多的那一种。。。在 .strings 文件里配置了许多国家的语言。然而在软件内部只提供中文、英文等某几种语言，其他语言根据系统语言自适应。不想在 initUserLanguage 方法里做一大堆的乱七八糟的判断。只要在 initUserLanguage 的判断方法 else 里使用系统语言：123&#125; else &#123; languageString = [[NSUserDefaults standardUserDefaults] objectForKey:@"AppleLanguages"][0]; // 其他默认为系统语言&#125; 2、另一种情况，比如：每次使用 RDLocalizedString(&lt;#key#&gt;) 方法都要做引用 #import &quot;RDLocalizableController.h&quot; 好麻烦。当然你可以把 #import &quot;RDLocalizableController.h&quot; 放到 .pch 文件里，哦，顺便提一下 .pch 文件会拖慢启动时间 3、还有一种情况，比如：就想使用 NSLocalizedString(&lt;#key#&gt;, &lt;#comment#&gt;) 方法，还可以解决以上两种情况 还是有方法使用 NSLocalizedString(&lt;#key#&gt;, &lt;#comment#&gt;) 的。使用 Category 为 NSBundle 类扩展一个设置语言的方法，并且使用 runtime 为 NSBundle 动态添加一个关于 bundle 的属性，重载 NSBundle.mainBundle 的 localizedStringForKey 方法。目的就是将更改的字体传给 NSLocalizedString(&lt;#key#&gt;, &lt;#comment#&gt;) 映射的 localizedStringForKey 方法返回的 bundle ，使得更改的字体应用到系统上。 好吧，show you the code:123456789101112131415161718192021222324252627282930313233#import "NSBundle+RDLanguage.h"#import &lt;objc/runtime.h&gt;static const NSString *RDBundleKey = @"RDLanguageKey";@interface BundleEx : NSBundle@end@implementation BundleEx- (NSString *)localizedStringForKey:(NSString *)key value:(NSString *)value table:(NSString *)tableName &#123; NSBundle *bundle = objc_getAssociatedObject(self, &amp;RDBundleKey); if (bundle) &#123; return [bundle localizedStringForKey:key value:value table:tableName]; &#125; else &#123; return [super localizedStringForKey:key value:value table:tableName]; &#125;&#125;@end@implementation NSBundle (RDLanguage)+ (void)setLanguage:(NSString *)language &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; object_setClass([NSBundle mainBundle], [BundleEx class]); &#125;); id value = language ? [NSBundle bundleWithPath:[[NSBundle mainBundle] pathForResource:language ofType:@"lproj"]] : nil; objc_setAssociatedObject([NSBundle mainBundle], &amp;RDBundleKey, value, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;@end 以上代码是 NSBundle 的 Category。解释一下哈：1、objc_getAssociatedObject 和 objc_setAssociatedObject 是一对 getter、setter 方法，目的是为了给 NSBundle 类动态添加一个属性。2、object_setClass：在 BundleEx 里实现一个 localizedStringForKey 方法，然后将 BundleEx 这个类设置给 [NSBundle mainBundle] 。目的就是相当于重载 [NSBundle mainBundle] 的 localizedStringForKey 方法。 说明：runtime 的具体用法和原理，由于在下才疏学浅就不多做讲解了，免得误人子弟。关于更多 runtime 的知识可以学习 一缕殇流化隐半边冰霜 写的 神经病院Objective-C Runtime入院 系列文章。 再说本篇文章，该类别新增方法的使用：在 RDLocalizableController 类的 + (void)setUserlanguage:(NSString *)language 方法里，本地化存储语言之后，发送通知之前调用如下方法：1[NSBundle setLanguage:language]; 之后，关于 RDLocalizableController 类里边关于 bundle 的操作就可以舍弃了。 注意：使用这种方法要确保你的 .strings 的文件名为 Localizable.strings否则还是要重新设置宏定义：12#define NSLocalizedString(key, comment) \ [NSBundle.mainBundle localizedStringForKey:(key) value:@"" table:@“RDLocalizable”] 这样的话该宏定义会有一个警告，毕竟系统已经定义过了的，而且你还要到处重定义。。。又犯了上面第二种情况的尴尬。 到这里，该篇博客就结尾了，希望能帮助到各位一二祝大家生活愉快，勤勉Coding 后记 小白出手，请多指教。如言有误，还望斧正！ 转载请保留原文地址：http://gonghonglou.com/2016/10/29/setlanguage]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS中关于二维码的识别与生成]]></title>
    <url>%2F2016%2F07%2F24%2FQRCode%2F</url>
    <content type="text"><![CDATA[提起二维码 QR Code 想必大家都不再陌生，“扫一扫加好友”、“扫一扫付款”等已是我们日常生活中司空见惯的情形。 以这篇博客来讲述在iOS中关于二维码的识别与生成，会尽可能周全的将二维码识别与生成相关的操作讲述清楚。 关于二维码生成的原理，感兴趣的话各位可以移驾 二维码的生成细节和原理 以做参考。 注：文中识别与生成二维码的方法同样适用于条形码。 先上几张二维码压压惊…… 识别二维码摄像头扫描二维码iOS7之后苹果推出系统原生API来支持通过扫描获取二维码的功能，较其它 ZBar、ZXing 等第三方库有明显的性能优势。 首先，你需要弄清楚要用到的以下对象分别起到什么作用： 1、 AVCaptureDevice：捕获数据的物理设备，如：摄像机、麦克风。 开关灯属性torchMode就是由它管理的。 2、 AVCaptureSession：会话，管理输入流、输出流之间的数据传递。 3、 AVCaptureDeviceInput：输入流，从物理设备获取数据。 4、 AVCaptureMetadataOutput：输出流，需要设置输出流代理及所在线程，由代理对象处理输出流数据。 需要说明的是： 需要将输出流添加到会话后，才能指定元数据类型，否则会报错。 将输出流设置在主线程中，其代理方法会执行一次。设置在其他线程的话，代理会执行多次且次数不可控制。 可以通过设置AVFoundation的rectOfInterest属性来设定扫描区域，该属性默认取值是CGRectMake(0, 0, 1, 1)即全屏扫描x、y、width、height的取值范围都是0～1，且原点在屏幕右上角，所以和我们正常理解的CGRect相比x和y对调，width和height对调。 如图： 5、 AVCaptureVideoPreviewLayerCALayer：预览图层，显示相机拍摄到的画面。正因为它是CALayer的子类，为了将它添加到屏幕上，我们需要额外添加一个UIView，在这个UIView的layer上添加AVCaptureVideoPreviewLayerCALayer，否则它会覆盖住所有的控件（除非你把所有的控件都在添加这个视图之后添加）。 AVCaptureSession 设置开始与结束扫描 12345// 开始会话[self.captureSession startRunning];// 停止会话[self.captureSession stopRunning];self.captureSession = nil; 获取AVCaptureDevice实例 初始化输入流 初始化输出流 3.1.设置代理及所在线程 3.2设置扫描区域 创建会话 4.1添加输入流 4.2添加输出流 *3.3指定元数据类型 创建预览图层 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 1.获取AVCaptureDevice实例self.captureDevice = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo];// 2.初始化输入流NSError * error;AVCaptureDeviceInput *input = [AVCaptureDeviceInput deviceInputWithDevice:self.captureDevice error:&amp;error];if (!input) &#123; NSLog(@"%@", [error localizedDescription]); return;&#125;// 3.初始化输出流AVCaptureMetadataOutput *captureMetadataOutput = [AVCaptureMetadataOutput new];// 3.1设置代理及所在线程[captureMetadataOutput setMetadataObjectsDelegate:self queue:dispatch_get_main_queue()];// 3.2设置扫描区域[captureMetadataOutput setRectOfInterest:[self scanPlace]];// 4.创建会话self.captureSession = [AVCaptureSession new];// 4.1添加输入流[self.captureSession addInput:input];if ([self.captureSession canAddInput:input]) &#123; [self.captureSession addInput:input];&#125;// 4.2添加输出流if ([self.captureSession canAddOutput:captureMetadataOutput]) &#123; [self.captureSession addOutput:captureMetadataOutput];&#125;// 3.3指定元数据类型captureMetadataOutput.metadataObjectTypes = @[AVMetadataObjectTypeUPCECode, AVMetadataObjectTypeCode39Code, AVMetadataObjectTypeCode39Mod43Code, AVMetadataObjectTypeEAN13Code, AVMetadataObjectTypeEAN8Code, AVMetadataObjectTypeCode93Code, AVMetadataObjectTypeCode128Code, AVMetadataObjectTypePDF417Code, AVMetadataObjectTypeQRCode, // 二维码 AVMetadataObjectTypeAztecCode];// 5创建预览图层self.captureVideoPreviewLayer = [[AVCaptureVideoPreviewLayer alloc] initWithSession:self.captureSession];[self.captureVideoPreviewLayer setVideoGravity:AVLayerVideoGravityResizeAspectFill];[self.captureVideoPreviewLayer setFrame:self.scanView.layer.bounds];[self.scanView.layer addSublayer:self.captureVideoPreviewLayer]; AVCaptureMetadataOutput 的代理方法处理输出流，返回扫描结果 123456789101112#pragma mark - 代理方法处理输出流- (void)captureOutput:(AVCaptureOutput *)captureOutput didOutputMetadataObjects:(NSArray *)metadataObjects fromConnection:(AVCaptureConnection *)connection &#123; if (metadataObjects != nil &amp;&amp; [metadataObjects count] &gt; 0) &#123; AVMetadataMachineReadableCodeObject *metadataObj = [metadataObjects objectAtIndex:0]; NSString *result = metadataObj.stringValue; NSLog(@"result:%@", result); if ([[metadataObj type] isEqualToString:AVMetadataObjectTypeQRCode]) &#123; NSLog(@"二维码"); &#125; // ... [self closeScanQRCode]; &#125;&#125; 开灯 给开关灯按钮调用以下 AVCaptureDevice 方法，轻松实现开灯效果 123456789101112- (void)turnLight &#123; // 判断允许设置 if ([self.device hasTorch]) &#123; [self.device lockForConfiguration:nil]; if (self.device.torchMode == AVCaptureTorchModeOff) &#123; [self.device setTorchMode:AVCaptureTorchModeOn]; // 开灯 &#125; else if (self.device.torchMode == AVCaptureTorchModeOn) &#123; [self.device setTorchMode:AVCaptureTorchModeOff]; // 关灯 &#125; [self.device unlockForConfiguration]; &#125;&#125; 总结下来就是：AVCaptureSession管理从物理设备AVCaptureDevice那里获取的输入流AVCaptureDeviceInput数据通过输出流AVCaptureMetadataOutput显示到预览图层AVCaptureVideoPreviewLayerCALayer上并且由代理方法-(void)captureOutput:(AVCaptureOutput*)captureOutput didOutputMetadataObjects:(NSArray*)metadataObjects fromConnection:(AVCaptureConnection*)connection;处理捕获到的数据。 相册识别二维码 iOS8之后系统提供的识别二维码图片的方法相当简单 123456789// 读取二维码UIImage *sourceImage ＝ ...;CIContext *context = [CIContext contextWithOptions:nil];CIDetector *detector = [CIDetector detectorOfType:CIDetectorTypeQRCode context:context options:@&#123;CIDetectorAccuracy:CIDetectorAccuracyHigh&#125;];CIImage *image = [CIImage imageWithCGImage:sourceImage.CGImage];NSArray *array = [detector featuresInImage:image];CIQRCodeFeature *feature = [array firstObject];NSString *result = feature.messageString;NSLog(@"result:%@", result); UIImagePickerController 打开系统相册，选择图片识别： 1234567- (void)openPhotoLibrary &#123; UIImagePickerController *photoPicker = [UIImagePickerController new]; photoPicker.delegate = self; // 打开的相册类型 photoPicker.sourceType = UIImagePickerControllerSourceTypePhotoLibrary; [self presentViewController:photoPicker animated:YES completion:NULL];&#125; UIImagePickerController 的代理方法识别相册中选中的二维码： 1234567891011121314#pragma mark - UIImagePickerControllerDelegate- (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary *)info &#123; [self dismissViewControllerAnimated:YES completion:^&#123; // 读取二维码 UIImage *sourceImage = [info objectForKey:UIImagePickerControllerOriginalImage]; CIContext *context = [CIContext contextWithOptions:nil]; CIDetector *detector = [CIDetector detectorOfType:CIDetectorTypeQRCode context:context options:@&#123;CIDetectorAccuracy:CIDetectorAccuracyHigh&#125;]; CIImage *image = [CIImage imageWithCGImage:sourceImage.CGImage]; NSArray *array = [detector featuresInImage:image]; CIQRCodeFeature *feature = [array firstObject]; NSString *result = feature.messageString; NSLog(@"result:%@", result); &#125;];&#125; 生成二维码 使用系统提供的CIFilter可以方便简单的生成二维码 生成二维码方法 12345678910111213141516- (UIImage *)generateQRCode:(NSString *)code width:(CGFloat)width height:(CGFloat)height &#123; CIImage *qrcodeImage; NSData *data = [code dataUsingEncoding:NSUTF8StringEncoding allowLossyConversion:false]; CIFilter *filter = [CIFilter filterWithName:@"CIQRCodeGenerator"]; [filter setValue:data forKey:@"inputMessage"]; [filter setValue:@"H" forKey:@"inputCorrectionLevel"]; qrcodeImage = [filter outputImage]; // 消除模糊 CGFloat scaleX = width / qrcodeImage.extent.size.width; // extent 返回图片的frame CGFloat scaleY = height / qrcodeImage.extent.size.height; CIImage *transformedImage = [qrcodeImage imageByApplyingTransform:CGAffineTransformScale(CGAffineTransformIdentity, scaleX, scaleY)]; return [UIImage imageWithCIImage:transformedImage];&#125; 使用 CIFilter 生成带背景色的二维码 12345678910111213141516171819202122- (UIImage *)gaveColor:(NSString *)code width:(CGFloat)width height:(CGFloat)height &#123; NSData *data = [code dataUsingEncoding:NSUTF8StringEncoding allowLossyConversion:false]; CIFilter *filter = [CIFilter filterWithName:@"CIQRCodeGenerator"]; [filter setValue:data forKey:@"inputMessage"]; [filter setValue:@"H" forKey:@"inputCorrectionLevel"]; //上色 CIFilter *colorFilter = [CIFilter filterWithName:@"CIFalseColor" keysAndValues: @"inputImage",filter.outputImage, @"inputColor0",[CIColor colorWithCGColor:[UIColor purpleColor].CGColor], // 前景色 @"inputColor1",[CIColor colorWithCGColor:[UIColor cyanColor].CGColor], // 背景色 nil]; CIImage *qrcodeImage = colorFilter.outputImage; // 消除模糊 CGFloat scaleX = width / qrcodeImage.extent.size.width; // extent 返回图片的frame CGFloat scaleY = height / qrcodeImage.extent.size.height; CIImage *transformedImage = [qrcodeImage imageByApplyingTransform:CGAffineTransformScale(CGAffineTransformIdentity, scaleX, scaleY)]; return [UIImage imageWithCIImage:transformedImage];&#125; 通过遍历图片的像素给二维码个性化上色 这里需要指出的是，如果你在下边方法中传入的 image 是通过 CIFilter 方法直接生成的，那么该方法是没法工作的。同理，下一节中保存图片时仍然不能用 CIFilter 方法直接生成的 image，而采用 CGContextRef 获取图片。（参见下一节：保存二维码） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 颜色变化void ProviderReleaseData (void *info, const void *data, size_t size) &#123; free((void *)data);&#125;- (UIImage *)imageBlackToTransparent:(UIImage *)image &#123; // 分配内存 const int imageWidth = image.size.width; const int imageHeight = image.size.height; size_t bytesPerRow = imageWidth * 4; uint32_t *rgbImageBuf = (uint32_t *)malloc(bytesPerRow * imageHeight); // 创建context CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB(); CGContextRef context = CGBitmapContextCreate(rgbImageBuf, imageWidth, imageHeight, 8, bytesPerRow, colorSpace,kCGBitmapByteOrder32Little | kCGImageAlphaNoneSkipLast); CGContextDrawImage(context, CGRectMake(0, 0, imageWidth, imageHeight), image.CGImage); // 遍历像素 int pixelNum = imageWidth * imageHeight; uint32_t *pCurPtr = rgbImageBuf; for (int i = 0; i &lt; pixelNum; i++, pCurPtr++) &#123; if ((*pCurPtr &amp; 0xFFFFFF00) &lt; 0x99999900) &#123; // 改变下面的代码，将图片转成想要的颜色 uint8_t *ptr = (uint8_t *)pCurPtr; if (i&lt;pixelNum/2) &#123; ptr[3] = 1; //0~255 ptr[2] = 200; ptr[1] = 200; &#125; else &#123; ptr[3] = 200; //0~255 ptr[2] = 1; ptr[1] = 200; &#125; &#125; else &#123; // 白色 255,255,255 uint8_t *ptr = (uint8_t *)pCurPtr; ptr[0] = 0; &#125; &#125; // 将内存转成image CGDataProviderRef dataProvider = CGDataProviderCreateWithData(NULL, rgbImageBuf, bytesPerRow * imageHeight,ProviderReleaseData); CGImageRef imageRef = CGImageCreate(imageWidth, imageHeight, 8, 32, bytesPerRow, colorSpace,kCGImageAlphaLast | kCGBitmapByteOrder32Little, dataProvider, NULL, true, kCGRenderingIntentDefault); CGDataProviderRelease(dataProvider); UIImage *resultUIImage = [UIImage imageWithCGImage:imageRef]; // 释放 CGImageRelease(imageRef); CGContextRelease(context); CGColorSpaceRelease(colorSpace); return resultUIImage;&#125; 生成条码图片 123456789101112131415- (UIImage *)generateBarCode:(NSString *)code width:(CGFloat)width height:(CGFloat)height &#123; CIImage *barcodeImage; NSData *data = [code dataUsingEncoding:NSISOLatin1StringEncoding allowLossyConversion:false]; CIFilter *filter = [CIFilter filterWithName:@"CICode128BarcodeGenerator"]; [filter setValue:data forKey:@"inputMessage"]; barcodeImage = [filter outputImage]; // 消除模糊 CGFloat scaleX = width / barcodeImage.extent.size.width; // extent 返回图片的frame CGFloat scaleY = height / barcodeImage.extent.size.height; CIImage *transformedImage = [barcodeImage imageByApplyingTransform:CGAffineTransformScale(CGAffineTransformIdentity, scaleX, scaleY)]; return [UIImage imageWithCIImage:transformedImage];&#125; 保存二维码12345678910111213// 开启位图上下文UIGraphicsBeginImageContextWithOptions(self.imageView.bounds.size, NO, 0);// 获取绘图上下文CGContextRef context = UIGraphicsGetCurrentContext();// 将图片渲染的上下文中[self.imageView.layer renderInContext:context];// 获取上下文中的图片UIImage *image = UIGraphicsGetImageFromCurrentImageContext();// 关闭位图上下文UIGraphicsEndImageContext();// 保存图片UIImageWriteToSavedPhotosAlbum(image, self, @selector(image:didFinishSavingWithError:contextInfo:), nil); UIImageWriteToSavedPhotosAlbum 方法的指定回调，监测保存是否成功 123456789#pragma mark - 指定回调方法- (void)image:(UIImage *)image didFinishSavingWithError:(NSError *)error contextInfo:(void *)contextInfo &#123; NSString *string; if(!error)&#123; NSLog(@"save success"); &#125;else&#123; NSLog(@"save failed"); &#125; &#125; 看一哈效果图 ok，就这些吧。Demo地址：https://github.com/gonghonglou/QRCodeDemo 写到这里估计涉及了二维码操作的大部分内容，期望对诸君有所帮助。 祝大家敲码愉快！ 后记 小白出手，请多指教。如言有误，还望斧正！ 转载请保留原文地址：http://gonghonglou.com/2016/07/24/QRCode]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[丽江之行]]></title>
    <url>%2F2016%2F05%2F19%2Flijiang%2F</url>
    <content type="text"><![CDATA[本来就打算一场毕业旅行啊，只是因为没有找到小伙伴同行所以迟迟未定。某日夜，Yu小Rong同学突出奇想打工换宿邀游丽江。一拍而和！ 最初的想法是打工换宿二十天左右，然而丽江客栈招义工大都要女孩子啊。搞不懂看看客栈家门而已喽，身强力壮的小伙子就这么受歧视吗。。。 所以Yu小Rong同学顺利找到一家暖暖的客栈做义工，而我…放弃吗？NO！苦寻义工无果之后果断选择住宿青旅，也算穷游丽江啦！ 有意思的是在某团上订房间时某青旅有三种房间：混住房间、男生房间、女生房间，价格相同。不明白该青旅是报以什么样的想法加入了混住房间的呢（坏笑）当我把这件事告知Yu小Rong同学并得知我订的是男生房间而非混住房间时竟然吐槽我：注孤生！额，好像错过了什么，活该单身狗啊哈哈哈 12号－－出发丽江十点出门从浦东奔赴上海虹桥，十二点动车开往杭州，下午两点机场大巴从杭州东站开往萧山机场。六点四十起飞，时间还是挺充足的！ 萧山机场 三小时后三义机场和某个傻傻女孩 一翻奔波，安顿了Yu小Rong同学在客栈，然后赶到青旅已是十二点多。青旅虽说是六张床却是我一人住还是棒棒哒！可能现在是旅游淡季的缘故吧。 13号－－束河古镇今天是休闲的一天。而且感觉丽江是一个慢节奏的古镇，好多人来旅游度假，也有很多人来旅行休憩。相比上海的快节奏生活突然到这里还是有些稍稍不适应的，是那种没有从心底完全放松的感觉。不过好不容易来这一趟还是非常享受这里惬意、舒适、休闲的慢节奏生活的。想想有半月多的这种旅行生活还是蛮激动的😄 早晨起来才看清住的院子的真面目，不错哦。 上午就悠闲地待在小伙伴在的客栈里，大大的院子。 午饭后漫步于束河古镇的各条街道里，房屋大多都是木质的 好多手鼓店，而且都放着那首由 最美丽江手鼓女孩 火起来的欢快的《我的小宝贝》 回青旅休息的路上路过一家叫喜鹊的小酒吧，好像很热闹的样子，就到上边坐了一会。深夜，点一杯饮料听几首歌…… 14号－－拉市海在纳西族中，“拉”为荒坝，“市”为新。“拉市”意为新的荒坝。拉市海在当地人口中也称为老市海。上午十点半包车前往拉市海马场，这边真的有好多马场，会有很多游客来骑马。这里的马个头比较矮，不过据马夫讲这里的马脚力特别好，擅负重。 茶马古道上捕获软妹子一只，这么美好想上前搭讪呀😏 中午到拉市海海上会所吃过午饭后就开始划船了嘛。可惜今天阴天，不然就能看到拉市海清澈美丽的湖面上倒映着蔚蓝的天空和天空里洁白的棉花糖 仗桨天涯！ 美丽湖畔 15号－－雨一整天都在下雨，不知是因为还没适应丽江的慢节奏还是因为一个人的孤独，今天清晰的感觉到对这里 我没有归属感。美丽的丽江。 －: I’m sorry.－: For what?－:－: For this.You’re so beautiful,i can’t control myself. 16号－－丽江古城万幸今天没下雨，可以去古城逛一逛。来丽江已有几天了，今天才去古城玩了。尤其想去看看大冰的小屋。对于大冰，相比读者粉丝我想我更是《阳光快车道》的观众，那是儿时的记忆，每周六的精彩节目，陪伴大冰在《阳光快车道》里从外景主持人到节目扛把子😄 丽江古城 晚上回青旅路过没有名字的手鼓店，美美的老板娘 暖暖的土家族妹子。待了好长时间，手鼓没打几下倒是聊了好久，基本都是老板娘在讲：讲来丽江前做装修设计时的嗨翻生活；讲妈妈没有文采却有道理的生意之道；讲算是“前男友”的刻骨经历；讲快要结婚的男朋友的习性和她们之间相识经历生活小事还有老板娘爱吃醋的小性子。燕姐，一个有故事的手鼓老板娘，不由得让人感觉亲近。下文有照片哦～ 17号－－再游古城今天是个好天气，怎么舍得不出去。在丽江的这几天晴朗的天空就是最稀有美丽的风景。 专门到大冰的小屋里去坐了坐，一瓶风花雪月，一下午。小屋里都是来自五湖四海的朋友，而且大都是女孩子呢。驻唱歌手问大家想听什么歌，大家点了一圈，他只答：不会、没听过。他说不点歌的，只是那么随口问问233，想起什么唱什么。他想起了甜蜜蜜，大家鼓掌期待那首经典老歌，只是第二句便唱得小屋里的女孩们红透了脸，这个歌手好污😄大多都是流浪歌手的民谣之类的歌曲，也好多他自己的原创歌曲。 一把吉他弹起，旁边手鼓伴奏，轻声慢语，辽亢高歌。 丽江古城很大，昨天只逛了一部份而已。今天去的时候发现好多手鼓店里的女孩都贴别漂亮啊，所以忍不住挨个拍下照片，打算做一合辑，就叫 最美丽江手鼓女孩 18号－－束河鼓缘原本是打算在这里待二十天左右的，奈何天天下雨还特别冷，加之Yu小Rong同学男票不来了，所以打算提前回去喽。 因为好多地方没去，倒是剩下了许多费用，看到束河街道上好多手鼓店，买个手鼓玩玩也是极好的。其实已经在燕姐那看了好几天了，大概有了个相中的手鼓，在今天买定的。 漂亮的老板娘－－燕姐： 19号－－离开你时才爱上你今天就要滚回上海了，恰好就在今天才是来丽江这么多天天气最好的一天。 坐在机场大巴上，望着头顶上的广袤的蔚蓝的天空和那些大块大块的棉花糖简直美哭了远方的雪山美的心都要化了来丽江这么久从没像这一刻觉得丽江原来可以这么美。可惜了了手机并不能拍出那样的美景。 美丽的天空，美的都不舍得离开了。 当离开你时，才发现爱上了你。－－－－丽江。 最后附束河傍晚天空图一张 最后的最后分享阳光下的小花一组：(拍摄者：Yu小Rong) 后 记 : 未 经 允 许 请 勿 转 载 ! ! !]]></content>
      <categories>
        <category>Journey</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[记环崇明岛骑行]]></title>
    <url>%2F2016%2F05%2F10%2Fchongming-cycling%2F</url>
    <content type="text"><![CDATA[事件：环崇明岛骑行人物：博主、博主的小伙伴时间：五一小假地点：崇明岛正文：现在发是不有点晚了？ 闭嘴！ 列位权当是篇环崇明岛骑行的攻略来看也未尝不可。 博主的车子，算是一款入门级的山地车－－捷安特 ATX 850，油压碟刹还是蛮爽的😄 30号早上约八点半左右从浦东出发至石洞口码头，45km/2h。坐十一点的轮渡（每小时一航班）到崇明岛南门码头，拍了几张照吃过午饭大概有一点钟正式开始了环崇明岛的骑行。 直接上陈海公路，一条宽阔的省道。 不过骑起来并不舒服，因为路特别宽所以不挡风，骑行中稍微有些风都会明显感觉到阻力，且经常有上坡。大约一直在22km/h～25km/h之间的速度巡航。 其实陈海公路相当长一段距离都是不允许非机动车行驶的。当然可以选择团城公路来走，只不过团成公路车辆要多一些难免提不起速度来。 距离南门港大概有三四十公里的地方到了堡镇，休息了半个小时，再上车的时候。。。那个屁股。。。那个疼。。。。 所以说骑行最重要的是坚强的屁股啊！！！ 在这条路上出了个小状况，有一段路小伙伴在前面破风，我跟的比较近而且没有太关心前方路况，小伙伴的车子突然躲过一辆停在路边的三轮车时我没来得急反应一车撞翻过去。。。不过还好只是一些擦伤不算太严重🤕️ 只是膝盖的碰伤导致那个下午剩下的路程骑起来比较吃力。所以要告诫骑友们骑行中尽量保持精力集中，注意前方路况尤其是在有伙伴在前破风时。 五点钟左右抵达陈家镇，因为到的略早一点所以很快就找到了旅馆。提醒骑友们留宿的话尽量到镇中心、县中心且稍早一点找宾馆，节假日房源还是挺紧张的。 1号早晨八点左右吃过早饭赶往东滩湿地，路上又到三个同行的骑友，其中一个还是骑过川藏，环过海南岛的前辈呢。 十几公里的路程，从陈家镇半小时就能到东滩。拍了几张照： 小湖边的座驾 天空下的兄弟俩 最遗憾的便是我们绕了一大圈的路就为了去海边一看，结果到了海边大坝的地方却被野生自然保护区的门卫拦住了，距离海边不过几百米。。。大坝还挡住了我们远眺的视线。。。 继续环岛的路程，从东滩赶往北沿公路，剩下的便是一直沿着北沿公路骑直到陈海公路回南门港了。因为天气预报说2号早上有雨，所以我们决定直接骑到南门港留宿，1号一天便骑了140公里！ 北沿公路骑起来还是相当爽的，上午大概在25km/h～30km/h巡航，下午因为要赶到南门港加上北沿公路路况相当好所以一直在35km/h左右巡航，简直酸爽！ 不过当拐到陈海公路后因为逆风、上坡再加上已经连续骑了一百多公里，所以这段路就苦逼了。。。 这是我们环岛的轨迹： 环岛总路线：从南门港沿陈海公路一路向东南方向到陈家镇，住一晚第二天到都东滩狂了一圈，然后沿北沿公路向西北方向拐到陈海公路，再沿陈海公路到南门港。 2号早上坐十点半的轮渡回上海，再经约45km/2h的路程到家。 五一环崇明岛骑行，第一次远途骑行正式结束，感觉良好！ 后记什么，你说这当一篇攻略来看的话也太逊了？作为一名码农出身的骑行手，不能忍你！ 这里有一份.gpx文件 👉点击下载记录了环崇明岛的骑行轨迹，将它导入到支持gpx格式的软件里就可以了，大家喜欢用什么软件自行Google吧～ 转载请保留原文地址：http://gonghonglou.com/2016/05/10/ChongmingCycling]]></content>
      <categories>
        <category>Journey</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mac上搭建Apache Tomcat ＋ MySQL]]></title>
    <url>%2F2016%2F04%2F01%2Fbuild-tomcat%2F</url>
    <content type="text"><![CDATA[因连接公司项目的测试服务器各种不便所以搭了个本地服务器Apache Tomcat，数据库用的MySQL。写下过程一来总结，二来分享，希望能帮到诸位一二，来介绍需要下载用到的工具吧。 Java环境点击下载：jdk-7u79-macosx-x64.dmg 下载之后一路点击安装即可 MySQL数据库点击下载：mysql-5.6.29-osx10.8-x86_64 下载之后同样一路点击安装即可，默认的安装路径为 /usr/local/mysql-5.6.29-osx10.8-x86_64 此时，在系统偏好设置的最下方如下图所示： 点击MySQL，然后点击 Start MySQL Server 开启数据库服务 /Users/user/Desktop/BuildTomcat:mysql.png 阿帕奇服务器点击下载：apache-tomcat-7.0.68.zip 下载解压后放到任一目录中，我选择的是MySQL的默认安装目录下 /usr/local/ 终端 cd 到阿帕奇服务器所在目录的 bin 目录下，执行如下命令： $ ./startup.sh // 开启服务器/Users/user/Desktop/mysql.png $ ./shutdown.sh // 关闭服务器 新下载的tomcat在启动时会报错： ./startup.sh: Permission denied 这是因为权限问题，执行如下命令即可解决： $ chmod u+x *.sh //表示对当前目录下的*.sh文件的所有者增加可执行权限 再次执行开启服务器命令即可。成功开启服务器后，浏览器打开 http://localhost:8080 出现如下界面表示开启成功： 如上图点击Manager App登录需要账号密码，点击取消会有解释。即打开/usr/local/apache-tomcat-7.0.68/conf目录下的tomcat-users.xml文件，在下方添加配置用户名密码如： &lt;role rolename=&quot;manager-gui&quot;/&gt; &lt;user username=&quot;tomcat_name&quot; password=&quot;tomcat_password&quot; roles=&quot;manager-gui&quot;/&gt; Sequel Pro点击下载mysql的图形化工具：sequel-pro-1.1.1.dmg 安装成功后打开，设置如下： Name随意，MySQL初始用户名为root 密码为空，因为初始并没有数据库所以Database也为空。 点击Connect进入后 1：左上角选择Add Database...，填入一个名字如troy，点击add 2：Sequel Pro菜单栏选择Database–&gt;User Accounts...,给 root 用户添加用户名密码，点击Apply 这样在下次登录时就要把Password和Database填上再连接 添加数据将自己的.sql文件用Sequel Pro打开并运行，这样在数据库中就有了数据 将自己的.war的jar包添加到/usr/local/apache-tomcat-7.0.68/webapps目录下，这样就有了执行程序 终端 cd 到阿帕奇服务器所在目录的 bin 目录下，开启服务器可执行如下任一命令： $ ./startup.sh // 单纯开启服务器 $ ./catalina.sh run // 开启服务器，控制台可打印服务器数据 到这里本地服务器就开启了 执行如下命令，查看服务器在局域网中的地址： $ ifconfig 这样你的手机等设备也可以连接到本地服务器了 总结一下 jdk-7u79-macosx-x64.dmg java环境 mysql-5.6.29-osx10.9-x86_64.dmg mysql数据库 apache-tomcat-7.0.68.zip 阿帕奇服务器 sequel-pro-1.1.1.dmg mysql的图形化工具 troy_2016-03-25.sql sql语句，放在 Sequel Pro中执行，生成数据） rest.war 运行程序，放在 apache-tomcat-7.0.68/webapps 目录下 开启服务器 愉快的玩耍 后记转载请保留原文地址：http://gonghonglou.com/2016/04/01/BuildTomcat]]></content>
      <categories>
        <category>Technology</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[解决OS X 10.11之后CocoaPods的升级问题]]></title>
    <url>%2F2016%2F04%2F01%2Fupdate-pods-que%2F</url>
    <content type="text"><![CDATA[问题描述：OS X 10.11之后升级CocoaPods，执行命令： $ sudo gem update cocoapods // 更新至最新版 $ sudo gem update cocoapods --pre // 或者 更新至测试版 报如下错误： ERROR: While executing gem ... (Errno::EPERM) Operation not permitted - /usr/bin/pod 解决方案一：使用如下命令更新： $ sudo gem install -n /usr/local/bin cocoapods // 更新至最新版 $ sudo gem install -n /usr/local/bin cocoapods --pre // 或者 更新至预览版 这种解决方法最开始的sudo gem update cocoapods 和 sudo gem update cocoapods --pre升级命令是不能用的，若想一切恢复正常请尝试解决方案二。 解决方案二：推倒重来。。。安装Homebrew ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 安装Ruby： brew install ruby 升级CocoaPods，执行命令： $ sudo gem install cocoapods // 更新至最新版 $ sudo gem install cocoapods --pre // 或者 更新至测试版 此后，一切OK～ 后记 上一篇文章关于CocoaPods的详细介绍：iOS的库依赖管理工具CocoaPods 转载请保留原文地址：http://gonghonglou.com/2016/04/01/UpdatePodsQue]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS的库依赖管理工具CocoaPods]]></title>
    <url>%2F2016%2F04%2F01%2FCocoaPods%2F</url>
    <content type="text"><![CDATA[工欲善其事，必先利其器！在iOS开发中 CocoaPods 作为库依赖管理工具就是一把利器。 有了CocoaPods你再也不需要手动将需要的第三方库拖进你的工程、添加第三方库所依赖的framework、设置如-fno-objc-arc等编译参数、手动管理这些库的更新，当某个第三方库有依赖其他的库还要继续拖、拖、拖…… 我们只需要将所需要的第三方库声明到一个名为Podfile文件中，然后执行Pod install命令就OK了，CocoaPods就会自动去下载我们所需要库，并为我的工程设置好相应的系统依赖和编译参数。 只能说，好用到哭～ 安装CocoaPodsCocoaPods依赖于Ruby环境，刚好Mac下自带Ruby，使用Ruby的gem命令即可安装CocoaPods。为防止因gem太老而引发问题，建议执行如下命令先更新gem： $ sudo gem update --system 执行如下命令安装CocoaPods： $ sudo gem install cocoapods 如果执行上述命令后没有反应，那是因为Ruby的软件源 https://rubygems.org 使用的是亚马逊的云服务而被墙了（GFW的伟大。。。）可以用淘宝的Ruby镜像来访问cocoapods，依次执行如下命令将官方的Ruby源替换成国内淘宝的源 # $ gem sources --remove https://rubygems.org/ # $ gem sources -a https://ruby.taobao.org/ 执行如下命令验证Ruby镜像的确是taobao的： # $ gem sources -l 出现如下文字才说明上面的命令是执行成功的： # *** CURRENT SOURCES *** # # https://ruby.taobao.org/ 此时，再次执行gem命令安装CocoaPods： $ sudo gem install cocoapods $ pod setup 稍等片刻 即可安装成功。 注： pod setup 是Cocoapods将它的信息下载到 ~/.cocoapods/repos 目录下。即使在安装时不执行此命令，在初次执行 pod install 命令时，系统也会自动执行 pod setup ——10.27更新 以下————————————————ruby.taobao.org 停止更新了，使用 cocoapods 的同学，请更新到 ruby china 的源。更新方法：使用如下命令查看镜像源： $ gem sources -l 更改镜像源： $ gem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/ or $ gem sources --add https://gems.ruby-china.org/ --remove https://ruby.taobao.org/ ——10.27更新 以上————————————————升级CocoaPods升级CocoaPods非常简单，使用Ruby的gem命令： $ sudo gem update cocoapods // 更新至最新版 or $ sudo gem update cocoapods --pre // 更新至预览版 当然执行如下命令也可以更新： $ sudo gem install cocoapods // 更新至最新版 or $ sudo gem install cocoapods --pre // 更新至预览版 注：OS X 10.11之后升级CocoaPods会有问题。解决方案参见下一篇博客：解决OS X 10.11之后CocoaPods的升级问题 降级CocoaPods有时我们需要降低CocoaPods版本来解决某些第三方库的兼容问题，例如RestKit不兼容CocoaPods的0.39.0版本，降级到0.38.2就OK了。 移除RubyGems中的Cocoapods程序包查看gems中本地程序包，执行如下命令： $ gem list 输出如下： 123456789101112131415161718192021222324252627282930313233343536*** LOCAL GEMS ***activesupport (4.2.5.2) bigdecimal (1.2.8) claide (1.0.0.beta.1, 0.9.1) cocoapods (1.0.0.beta.4, 0.39.0) cocoapods-core (1.0.0.beta.4, 0.39.0) cocoapods-deintegrate (1.0.0.beta.1) cocoapods-downloader (1.0.0.beta.1, 0.9.3) cocoapods-plugins (1.0.0.beta.1, 0.4.2) cocoapods-search (1.0.0.beta.1, 0.1.0) cocoapods-stats (1.0.0.beta.3, 0.6.2) cocoapods-trunk (1.0.0.beta.2, 0.6.4) cocoapods-try (1.0.0.beta.2, 0.5.1) colored (1.2) did_you_mean (1.0.0) escape (0.0.4) fourflusher (0.3.0) fuzzy_match (2.0.4) i18n (0.7.0) io-console (0.4.5) json (1.8.3) minitest (5.8.3) molinillo (0.4.4) nap (1.1.0) net-telnet (0.1.1) netrc (0.7.8) power_assert (0.2.6) psych (2.0.17) rake (10.4.2) rdoc (4.2.1) rubygems-update (2.6.1) test-unit (3.1.5) thread_safe (0.3.5) tzinfo (1.2.2) xcodeproj (1.0.0.beta.3, 0.28.2) 其中包含的CocoaPods版本： cocoapods (1.0.0.beta.4, 0.39.0) 移除指定版本cocoapods如1.0.0.beta.4，执行如下命令： $ sudo gem uninstall cocoapods -v 1.0.0.beta.4 成功删除则输出： Successfully uninstalled cocoapods-1.0.0.beta.4 还有一个0.39.0版本，移除程序包，执行如下命令： $ sudo gem uninstall cocoapods -v 0.39.0 当移除最后一个版本时，询问： Remove executables: pod, sandbox-pod in addition to the gem? [Yn] 按下回车键删除pod。查看CocoaPods组件的安装目录，执行命令$ which pod所得目录下的pod文件随即删除。 安装指定版本的Cocoapods程序包安装指定版本的CocoaPods 如0.39.0，执行如下命令： $ sudo gem install cocoapods -v 0.39.0 注：若不指定版本，即命令如sudo gem install cocoapods则默认安装最新版。 安装成功后，执行命令查看版本号： $ pod --version 输出： 0.39.0 使用CocoaPods搜索第三方库为判断某第三方库（如AFNetworking）是否支持CocoaPods，执行如下命令来搜索： $ pod search AFNetworking 若如下图所示，则可用CocoaPods管理AFNetworking 创建Podfile的文件CocoaPods就可以根据Podfile文件里的内容来帮你下载你所需要的库。点击前往CocoaPods官方对Podfile文件的介绍。终端cd到你的项目所在目录下，创建Podfile文件： $ vim Podfile 按下i键进入输入状态，在Podfile文件里输入以下文字： platform :ios, &apos;8.0&apos; target &apos;Your_App_Name&apos; do pod &apos;AFNetworking&apos;, &apos;~&gt; 3.0&apos; end 按下esc键退出输入。然后保存退出，命令是:wq。你当然可以使用vim之外的编辑软件来编辑Podfile文件。 注：cocoapods-1.0.0.beta版本后规定Podfile文件必须如上所示格式（加上target） 当然，采用创建Podfile文件的另一种方式，终端cd到你的项目所在目录下执行命令 pod init 会自动生成格式，自己试一下你会喜欢的～ 终端cd到你的项目所在目录下执行如下命令来利用CocoPods下载第三方库： $ pod install 如下图所示则下载成功： 提示：[!] Please close any current Xcode sessions and use Your_App_Name.xcworkspace for this project from now on. 打开Your_App_Name.xcworkspace 工程之后会看到 Pods 文件，AFNetwoking已经成功导入项目了。 你或许应当点击前往CocoaPods官网查看对pod install vs. pod update的介绍。 注：当你 clone 别人的项目到本地后也需要终端cd到项目所在目录下执行命令 $ pod install 关于Podfile.lock的文件执行pod install之后，CocoaPods会生成一个名为Podfile.lock的文件。并锁定当前各依赖库的版本，之后如果多次执行pod install或者团队中的其它人check下来这份包含Podfile.lock文件的工程后再执行pod install命令时，获取下来的Pods依赖库的版本就和最开始用户获取到的版本一致。如果没有Podfile.lock文件，执行pod install命令会获取第三方库的最新版本，这就有可能造成同一个团队使用的依赖库版本不一致，这对团队协作的危害无疑是灾难性的！在这种情况下，如果团队想使用当前最新版本的依赖库，有两种方案可修改Podfile.lock的纪录： 更改Podfile中各依赖库的版本 执行pod update命令 鉴于Podfile.lock文件对团队协作如此重要，我们应该将它添加到版本控制里。 点击前往CocoaPods官网查看对Podfile.lock的介绍。 补充：有时执行pod update命令会特别慢，可以尝试使用如下命令： $ pod update --verbose --no-repo-update pod install命令同理： $ pod install --verbose --no-repo-update 发布自己的开源框架到CocoaPods你需要如下图创建一个Framework来打造你自己的开源框架 发布自己的开源框架到CocoaPods同样需要一个类似Podfile的文件来告诉CocoaPods我们开源库的名称、版本、作者、描述、地址、所需的framework、依赖库等，这个文件叫Your_Framework_Name.podspec，开始创建这个文件 终端cd到工程目录下，执行如下命令： $ pod spec create Your_Framework_Name 这样在你的工程目录下会生成一个Your_Framework_Name.podspec文件，大概内容为： 1234567891011121314Pod::Spec.new do |s| s.name = "Your_Framework_Name" s.version = "0.0.2" s.summary = "My framework" s.description = &lt;&lt;-DESC It's my framework. DESC s.ios.deployment_target = "8.0" s.source = &#123; :git =&gt; "https://github.com/gonghonglou/Your_Framework_Name.git", :tag =&gt; s.version &#125; s.source_files = "Class/*.&#123;h,m&#125;" s.public_header_files = ["Your_Framework_Name/Your_Framework_Name.h"] end 给框架打上 tag $ git tag 1.0.2 $ git push origin --tags 检查 podspec 语法和项目是否正常编译，执行如下命令： $ pod spec lint Your_Framework_Name.podspec 确保没有任何 error 和 warning ，然后推送 podspec 到 CocoaPods 的主仓库就可以了 $ pod trunk push Your_Framework_Name.podspec // 提交到 CocoaPods 中心仓库 后记 小白出手，请多指教。如言有误，还望斧正！ 转载请保留原文地址：http://gonghonglou.com/2016/04/01/CocoaPods 参考链接 Using CocoaPods CocoaPods安装和使用教程 用CocoaPods做iOS程序的依赖管理 如何打造一个让人愉快的框架]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[初识ReactiveCocoa]]></title>
    <url>%2F2016%2F03%2F17%2Fmeet-ReactiveCocoa%2F</url>
    <content type="text"><![CDATA[ReactiveCocoa 是一个Objective-C 框架，受 Functional Reactive Programming的启发。它提供了一系列用来组合和转换值流的API。 如果你早已熟悉了函数响应式编程或者知道ReactiveCocoa的基本前提，看看Documentation这个文件夹里的framework overview等文件更深一步来了解它是怎样在实践中工作的。 介绍ReactiveCocoa受functional reactive programming的启发。在那些能被替换和修改的地方，RAC提供信号(由RACSignal代表)来捕获当前和将来的值而不是使用可变的变量。 通过链接，组合，和反馈的信号，软件可以不需要写那些持续观察和更新value的代码。 例如，一个文本框能够根据它的改变被绑定到最后一次的值，而不是使用额外的代码每秒去监控时钟和更新文本框。这点跟KVO很像，不过是使用了block，而非-observeValueForKeyPath:ofObject:change:context: 信号也可以进行异步操作，就像futures and promises。这极大的简化了异步软件中网络连接的代码。 RAC的重大优势之一就是它提供信号(signal)这种方式来统一的处理所有异步的行为，包括代理方法、block 回调、target-action 机制、通知和KVO。 这里是简单的例子： 1234567// 当self.username改变时，打印新的名字到控制台//// RACObserve(self, username)创建一个新的RACSignal，当前self.username的值发生改变时，发送新值给newName// -subscribeNext: 当信号发送值时将触发block[RACObserve(self, username) subscribeNext:^(NSString *newName) &#123; NSLog(@"%@", newName);&#125;]; 与KVO 通知不同的是信号能够进行统一的链式操作： 12345678910// 只有当名字的开头为"j"时才打印//// -filter 只有当block返回YES时才会创建一个新的RACSignal发送一个新值[[RACObserve(self, username) filter:^(NSString *newName) &#123; return [newName hasPrefix:@"j"]; &#125;] subscribeNext:^(NSString *newName) &#123; NSLog(@"%@", newName); &#125;]; 信号也能被用来派生状态。在响应新值中RAC代替观察属性和设置其他的属性，能够在信号和运行周期内传达属性： 1234567891011// 当self.password 和 self.passwordConfirmation相同时创建一个单向的binding使得self.createEnabled为true//// RAC() 是一个宏指令使得binding看起来nicer// // +combineLatest:reduce: 建一个信号数组// 当任一个信号的最后一个值发生改变时触发这个block，返回一个新的RACSignal，将block返回的值作为values发送出去RAC(self, createEnabled) = [RACSignal combineLatest:@[ RACObserve(self, password), RACObserve(self, passwordConfirmation) ] reduce:^(NSString *password, NSString *passwordConfirm) &#123; return @([passwordConfirm isEqualToString:password]); &#125;]; 信号不仅是在KVO上，还能在建立在随着时间而改变的值流上。例如，它们可以代表按钮点击： 123456789// 当按钮被点击时打印信息//// RACCommand创建信号去表示UI行为。例如，每一个信号可以表示一个按钮的点击、与它相关联的附加工作//// -rac_command是封装的NSButton方法. 当按钮被点击时触发该命令self.button.rac_command = [[RACCommand alloc] initWithSignalBlock:^(id _) &#123; NSLog(@"button was pressed!"); return [RACSignal empty];&#125;]; 或者是异步网络操作： 123456789101112131415161718// 连接"Log in"按钮给网络登录//// 当登录命令执行时运行block，开始登录进度self.loginCommand = [[RACCommand alloc] initWithSignalBlock:^(id sender) &#123; // 假设当网络请求完成时 -logIn 方法返回一个信号发送一个value return [client logIn];&#125;];// -executionSignals 每次执行该命令时，这个方法返回一个信号，包括以前的block返回的信号[self.loginCommand.executionSignals subscribeNext:^(RACSignal *loginSignal) &#123; // 成功登录时打印信息 [loginSignal subscribeCompleted:^&#123; NSLog(@"Logged in successfully!"); &#125;];&#125;];// 按钮被点击时执行登录命令self.loginButton.rac_command = self.loginCommand; 信号也可以代表定时器，其他的UI事件，或者别的什么随时间而改变的事件。 在异步操作方面，通过链接和转换信号可以建立更复杂的行为。在一组完整的操作之后更简单的来执行工作： 12345678910// 执行2个网络操作，当它们都完成时打印信息到控制台//// +merge: 当数组里的所有信号完成时，返回一个新的RACSignal//// -subscribeCompleted: 当信号完成时将执行这个block[[RACSignal merge:@[ [client fetchUserRepos], [client fetchOrgRepos] ]] subscribeCompleted:^&#123; NSLog(@"They're both done!"); &#125;]; 信号可以被链接到顺序执行异步操作，而不是使用一堆block回调。通常这样简单的来使用futures and promises： 123456789101112131415161718192021// 用户登录，下载缓存信息，获取服务器信息。都完成后将信息打印到控制台//// 假设登录之后 -logInUser 方法返回一个信号//// -flattenMap: 当信号发送一个value时触发这个block// 并且返回一个新的RACSignal来整合从block返回的所有的信号到一个单一信号中[[[[client logInUser] flattenMap:^(User *user) &#123; // 下载缓存信息，给用户返回一个信号 return [client loadCachedMessagesForUser:user]; &#125;] flattenMap:^(NSArray *messages) &#123; // Return a signal that fetches any remaining messages. return [client fetchMessagesAfterMessage:messages.lastObject]; &#125;] subscribeNext:^(NSArray *newMessages) &#123; NSLog(@"New messages: %@", newMessages); &#125; completed:^&#123; NSLog(@"Fetched all messages."); &#125;]; RAC甚至可以简单的建立在一个异步操作的结果上： 1234567891011121314151617// 创建一个单向的binding，让 self.imageView.image 来放置下载下来的user的头像//// 假设 -fetchUserWithUsername: 方法返回一个信号发送给user//// -deliverOn: 创建新的信号在其他的队列中进行他们的工作// 在这个例子中，此方法被用来将工作转移到后台队列和回到主线程//// -map: 每个user调用这个block，获取并且返回一个新的RACSignal，并且将从block返回的值发送出去RAC(self.imageView, image) = [[[[client fetchUserWithUsername:@"joshaber"] deliverOn:[RACScheduler scheduler]] map:^(User *user) &#123; // 下载头像 (在后台队列中进行). return [[NSImage alloc] initWithContentsOfURL:user.avatarURL]; &#125;] // 此时这个任务将在主线程中执行 deliverOn:RACScheduler.mainThreadScheduler]; 这是一些使用RAC的示范操作，但是它并不能说明RAC为什么如此强大。更多示例代码参见C-41 或 GroceryList,这些是使用ReactiveCocoa编写的iOS APP。在这个文件夹Documentation中可以查到更多的关于RAC的信息。 使用ReactiveCocoa乍一看ReactiveCocoa是非常抽象的，很难理解该怎样将它应用到具体的问题上。 这有一些示例来展示RAC的优势 处理异步或事件驱动的数据源许多Cocoa编程的重点是对用户事件的反应或应用状态的变化。处理这些事件的代码很快变得非常复杂的就像意大利面一样，伴随着许多回调函数和状态变量处理顺序的问题。 表面上看起来模式不同，比如UI回调，网络响应和KVO通知，实际上有很多共同之处。RACSignal统一了所有的这些不同的API，使他们可以组合在一起，并以同样的方式操纵。 例如这样的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546static void *ObservationContext = &amp;ObservationContext;- (void)viewDidLoad &#123; [super viewDidLoad]; [LoginManager.sharedManager addObserver:self forKeyPath:@"loggingIn" options:NSKeyValueObservingOptionInitial context:&amp;ObservationContext]; [NSNotificationCenter.defaultCenter addObserver:self selector:@selector(loggedOut:) name:UserDidLogOutNotification object:LoginManager.sharedManager]; [self.usernameTextField addTarget:self action:@selector(updateLogInButton) forControlEvents:UIControlEventEditingChanged]; [self.passwordTextField addTarget:self action:@selector(updateLogInButton) forControlEvents:UIControlEventEditingChanged]; [self.logInButton addTarget:self action:@selector(logInPressed:) forControlEvents:UIControlEventTouchUpInside];&#125;- (void)dealloc &#123; [LoginManager.sharedManager removeObserver:self forKeyPath:@"loggingIn" context:ObservationContext]; [NSNotificationCenter.defaultCenter removeObserver:self];&#125;- (void)updateLogInButton &#123; BOOL textFieldsNonEmpty = self.usernameTextField.text.length &gt; 0 &amp;&amp; self.passwordTextField.text.length &gt; 0; BOOL readyToLogIn = !LoginManager.sharedManager.isLoggingIn &amp;&amp; !self.loggedIn; self.logInButton.enabled = textFieldsNonEmpty &amp;&amp; readyToLogIn;&#125;- (IBAction)logInPressed:(UIButton *)sender &#123; [[LoginManager sharedManager] logInWithUsername:self.usernameTextField.text password:self.passwordTextField.text success:^&#123; self.loggedIn = YES; &#125; failure:^(NSError *error) &#123; [self presentError:error]; &#125;];&#125;- (void)loggedOut:(NSNotification *)notification &#123; self.loggedIn = NO;&#125;- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context &#123; if (context == ObservationContext) &#123; [self updateLogInButton]; &#125; else &#123; [super observeValueForKeyPath:keyPath ofObject:object change:change context:context]; &#125;&#125; … 可以用RAC这样的表示： 1234567891011121314151617181920212223242526272829303132333435- (void)viewDidLoad &#123; [super viewDidLoad]; @weakify(self); RAC(self.logInButton, enabled) = [RACSignal combineLatest:@[ self.usernameTextField.rac_textSignal, self.passwordTextField.rac_textSignal, RACObserve(LoginManager.sharedManager, loggingIn), RACObserve(self, loggedIn) ] reduce:^(NSString *username, NSString *password, NSNumber *loggingIn, NSNumber *loggedIn) &#123; return @(username.length &gt; 0 &amp;&amp; password.length &gt; 0 &amp;&amp; !loggingIn.boolValue &amp;&amp; !loggedIn.boolValue); &#125;]; [[self.logInButton rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(UIButton *sender) &#123; @strongify(self); RACSignal *loginSignal = [LoginManager.sharedManager logInWithUsername:self.usernameTextField.text password:self.passwordTextField.text]; [loginSignal subscribeError:^(NSError *error) &#123; @strongify(self); [self presentError:error]; &#125; completed:^&#123; @strongify(self); self.loggedIn = YES; &#125;]; &#125;]; RAC(self, loggedIn) = [[NSNotificationCenter.defaultCenter rac_addObserverForName:UserDidLogOutNotification object:nil] mapReplace:@NO];&#125; 链接依赖操作依赖在网络请求中是常见的，在下一个请求建立之前，需要完成当前对服务器的请求，比如： 12345678910111213[client logInWithSuccess:^&#123; [client loadCachedMessagesWithSuccess:^(NSArray *messages) &#123; [client fetchMessagesAfterMessage:messages.lastObject success:^(NSArray *nextMessages) &#123; NSLog(@"Fetched all messages."); &#125; failure:^(NSError *error) &#123; [self presentError:error]; &#125;]; &#125; failure:^(NSError *error) &#123; [self presentError:error]; &#125;];&#125; failure:^(NSError *error) &#123; [self presentError:error];&#125;]; 在ReactiveCocoa中可以这样简单的实现： 123456789101112[[[[client logIn] then:^&#123; return [client loadCachedMessages]; &#125;] flattenMap:^(NSArray *messages) &#123; return [client fetchMessagesAfterMessage:messages.lastObject]; &#125;] subscribeError:^(NSError *error) &#123; [self presentError:error]; &#125; completed:^&#123; NSLog(@"Fetched all messages."); &#125;]; 并行独立工作与独立的数据集合并行工作，然后将它们合并成一个non-trivial函数到Cocoa，并经常涉及大量的同步： 123456789101112131415161718192021222324252627__block NSArray *databaseObjects;__block NSArray *fileContents; NSOperationQueue *backgroundQueue = [[NSOperationQueue alloc] init];NSBlockOperation *databaseOperation = [NSBlockOperation blockOperationWithBlock:^&#123; databaseObjects = [databaseClient fetchObjectsMatchingPredicate:predicate];&#125;];NSBlockOperation *filesOperation = [NSBlockOperation blockOperationWithBlock:^&#123; NSMutableArray *filesInProgress = [NSMutableArray array]; for (NSString *path in files) &#123; [filesInProgress addObject:[NSData dataWithContentsOfFile:path]]; &#125; fileContents = [filesInProgress copy];&#125;]; NSBlockOperation *finishOperation = [NSBlockOperation blockOperationWithBlock:^&#123; [self finishProcessingDatabaseObjects:databaseObjects fileContents:fileContents]; NSLog(@"Done processing");&#125;]; [finishOperation addDependency:databaseOperation];[finishOperation addDependency:filesOperation];[backgroundQueue addOperation:databaseOperation];[backgroundQueue addOperation:filesOperation];[backgroundQueue addOperation:finishOperation]; 上面的代码可以用简单的合成信号来清理和优化： 1234567891011121314151617181920212223RACSignal *databaseSignal = [[databaseClient fetchObjectsMatchingPredicate:predicate] subscribeOn:[RACScheduler scheduler]];RACSignal *fileSignal = [RACSignal startEagerlyWithScheduler:[RACScheduler scheduler] block:^(id&lt;RACSubscriber&gt; subscriber) &#123; NSMutableArray *filesInProgress = [NSMutableArray array]; for (NSString *path in files) &#123; [filesInProgress addObject:[NSData dataWithContentsOfFile:path]]; &#125; [subscriber sendNext:[filesInProgress copy]]; [subscriber sendCompleted];&#125;];[[RACSignal combineLatest:@[ databaseSignal, fileSignal ] reduce:^ id (NSArray *databaseObjects, NSArray *fileContents) &#123; [self finishProcessingDatabaseObjects:databaseObjects fileContents:fileContents]; return nil; &#125;] subscribeCompleted:^&#123; NSLog(@"Done processing"); &#125;]; 简化collection转换高阶函数比如 map, filter, fold/reduce在Foundation中是非常缺少的，导致循环中的代码像这样： 123456789NSMutableArray *results = [NSMutableArray array];for (NSString *str in strings) &#123; if (str.length &lt; 2) &#123; continue; &#125; NSString *newString = [str stringByAppendingString:@"foobar"]; [results addObject:newString];&#125; RACSequence允许所有Cocoa collection在统一的和声明的方式下被操作： 1234567RACSequence *results = [[strings.rac_sequence filter:^ BOOL (NSString *str) &#123; return str.length &gt;= 2; &#125;] map:^(NSString *str) &#123; return [str stringByAppendingString:@"foobar"]; &#125;]; 后记 以上文章摘译自ReactiveCocoa的Objective-C官方文档ReactiveCocoa Documentation 以上内容介绍了RAC的基本用法，仅限于使用，所以墙裂建议仔细学习下节的参考链接，了解RAC原理及高阶用法。 小白出手，请多指教。如言有误，还望斧正！ 转载请保留原文地址：http://gonghonglou.com/2016/03/17/MeetingReactiveCocoa 参考链接 ReactiveCocoa的Objective-C官方文档ReactiveCocoa Documentation 雷纯锋的ReactiveCocoa v2.5 源码解析之架构总览 吖了个峥的最快让你上手ReactiveCocoa之基础篇 和 最快让你上手ReactiveCocoa之进阶篇 李忠的ReactiveCocoa与Functional Reactive Programming 唐巧的ReactiveCocoa 讨论会]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS开发tips之日期与星期的对应]]></title>
    <url>%2F2016%2F03%2F03%2Fdate-week%2F</url>
    <content type="text"><![CDATA[前言前段时间练手模拟校园app写了个Demo，其中在写课程表的界面时，加上了当前日期，为了让日期与星期对应也是前后折腾了好几次，主要还是对日期的情况思考的不够全面吧（比如判断每月天数和月初月末的交替），不过最终还是完成需求。最后意外发现简便方法，写下来分享。 对校园app的Demo有兴趣的话，请移驾GitHub: QLU-BlogDemo 正文首先看一下模样吧（如图中红框所示）最基本的：获取当前日期的方法 12345678910111213141516171819// 获取当前时间NSDate *senddate = [NSDate date];NSDateFormatter *dateformatter = [[NSDateFormatter alloc] init];[dateformatter setDateFormat:@"yyy"];NSString *yearString = [dateformatter stringFromDate:senddate];[dateformatter setDateFormat:@"MM"];NSString *monthString = [dateformatter stringFromDate:senddate];[dateformatter setDateFormat:@"dd"];NSString *dayString = [dateformatter stringFromDate:senddate];[dateformatter setDateFormat:@"EEE"]; NSString *weekString = [dateformatter stringFromDate:senddate];NSLog(@"-%@",weekString);int year = [yearString intValue];NSLog(@"-%d", year);int month = [monthString intValue];NSLog(@"--%d", month);int day = [dayString intValue];NSLog(@"---%d", day); 看打印结果：然后就是把获取到的日期放到对应星期上去了,需要格外注意的要判断的几点： 不同月的天数 月底时，显示下个月月初的日期 月初时，显示上个月月底的日期 首先获取不同月的天数,并抽离成类方法方便后边调用 123456789101112131415// 获取某年某月总共多少天 + (int)getDaysInMonth:(int)year month:(int)imonth &#123; // imonth == 0的情况是应对在CourseViewController里month-1的情况 if((imonth == 0)||(imonth == 1)||(imonth == 3)||(imonth == 5)||(imonth == 7)||(imonth == 8)||(imonth == 10)||(imonth == 12)) return 31; if((imonth == 4)||(imonth == 6)||(imonth == 9)||(imonth == 11)) return 30; if((year%4 == 1)||(year%4 == 2)||(year%4 == 3)) return 28; if(year%400 == 0) return 29; if(year%100 == 0) return 28; return 29; &#125; 放置label的方法，在label上写下日期 123456789// 添加日期- (void)setDateLabel:(CGRect)rect number:(NSString *)number&#123; UILabel *label = [[UILabel alloc] initWithFrame:rect]; label.textColor = [UIColor colorWithRed:100.0/255 green: 73.0/255 blue:250.0/255 alpha:1]; label.textAlignment = NSTextAlignmentCenter; label.text = number; label.font = [UIFont systemFontOfSize:14]; [self.view addSubview:label];&#125; 开始判断。拿到周一是几号后面的日数递增就OK了，注意月末月初交替的特殊情况（看机智如我，走起) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 判断当前天是周几，从而计算出当周的周一是几号（负数表示上个月月末）if ([weekString isEqual: @"周一"]) &#123; day = day - 1; // 因为下面有 day++;&#125; else if ([weekString isEqual:@"周二"]) &#123; day = day - 2;&#125; else if ([weekString isEqual:@"周三"]) &#123; day = day - 3;&#125; else if ([weekString isEqual:@"周四"]) &#123; day = day - 4;&#125; else if ([weekString isEqual:@"周五"]) &#123; day = day - 5;&#125; else if ([weekString isEqual:@"周六"]) &#123; day = day - 6;&#125; else if ([weekString isEqual:@"周日"]) &#123; day = day - 7;&#125; if (day&lt;0) &#123; // 月初时显示上个月月末的日期 for (int i = 0; i &lt; 7; i++) &#123; // 上个月末往后的月初数字 int days = [GetDays getDaysInMonth:year month:month-1]; day++; if (day &gt; days) &#123; day = 0; day++; &#125; // 月初之前的月末数字 switch (day) &#123; case 0: day = days; break; case -1: day = days-1; break; case -2: day = days-2; break; case -3: day = days-3; break; case -4: day = days-4; break; case -5: day = days-5; break; default: break; &#125; [self setDateLabel:CGRectMake(i*((self.view.frame.size.width-33.5)/7+0.5)+30.5, kTopY, (self.view.frame.size.width-33.5)/7, 15) number:[NSString stringWithFormat:@"%d", day]]; &#125;&#125; else &#123; // 月末 for (int i = 0; i &lt; 7; i++) &#123; int days = [GetDays getDaysInMonth:year month:month]; day++; if (day &gt; days) &#123; day = 0; day++; &#125; [self setDateLabel:CGRectMake(i*((self.view.frame.size.width-33.5)/7+0.5)+30.5, kTopY, (self.view.frame.size.width-33.5)/7, 15) number:[NSString stringWithFormat:@"%d", day]]; &#125;&#125; 劳心劳力，大功告成。接下来小L要告诉大家，上边的判断看看就好了（哭吧）我们还有so so so easy的方法（嘿） 方法推荐：获取几年几月几日后的日期,并抽离成类方法方便后边调用 1234567891011121314151617181920/** * 获取几年几月几日后的日期，0表示当天，负数表示之前 * 这里只要取到日就好了，年月置0，表示当年当月 */+ (int)getOneDay:(int)day &#123; int year = 0, month = 0; NSCalendar *calendar = [[NSCalendar alloc] initWithCalendarIdentifier:NSCalendarIdentifierGregorian]; NSDateComponents *comps = nil; comps = [calendar components:NSCalendarUnitYear|NSCalendarUnitMonth|NSCalendarUnitDay fromDate:[NSDate date]]; NSDateComponents *adcomps = [[NSDateComponents alloc] init]; [adcomps setYear:year]; [adcomps setMonth:month]; [adcomps setDay:day]; NSDate *newdate = [calendar dateByAddingComponents:adcomps toDate:[NSDate date] options:0]; NSDateFormatter *formatter = [[NSDateFormatter alloc] init]; [formatter setDateFormat:@"dd"]; NSString * dayString = [formatter stringFromDate:newdate]; return [dayString intValue];&#125; 重点来了： 123456789101112131415161718192021// 判断当前天是周几，从而计算出当周的周一是几号（负数表示上个月月末）if ([weekString isEqual: @"周一"]) &#123; day = 0; // 因为下面有 day++;&#125; else if ([weekString isEqual:@"周二"]) &#123; day = -1;&#125; else if ([weekString isEqual:@"周三"]) &#123; day = -2;&#125; else if ([weekString isEqual:@"周四"]) &#123; day = -3;&#125; else if ([weekString isEqual:@"周五"]) &#123; day = -4;&#125; else if ([weekString isEqual:@"周六"]) &#123; day = -5;&#125; else if ([weekString isEqual:@"周日"]) &#123; day = -6;&#125;// 放置日期for (int i = 0; i &lt; 7; i++) &#123; [self setDateLabel:CGRectMake(i*((self.view.frame.size.width-33.5)/7+0.5)+30.5, kTopY, (self.view.frame.size.width-33.5)/7, 15) number:[NSString stringWithFormat:@"%d", [GetOneDay getOneDay:day++]]];&#125; 如此才是万事大吉！比上边的判断简单了许多，不过上边的判断也是一种思路，所以记录下来，给大家一个借鉴！ 后记小白出手，请多指教。如言有误，还望斧正！ 转载请保留原文地址：http://gonghonglou.com/2016/03/03/dateandweek 迁移文章 首发于2015-10-13]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[由丢失一部iPhone6引发的祸端]]></title>
    <url>%2F2016%2F03%2F03%2Fprotect-apple-id%2F</url>
    <content type="text"><![CDATA[前言：刚从售后拿到Mac 回学校的公交车上。记录下这悲惨的经历告诫各位果友篇幅略长，怕有些读者看不下去遂将告诫先写在前面： 为保护手机，在iPhone设置–iCloud里有查找我的iPhone功能，确保开启（默认开启）万一不幸手机丢失，尽快登录iCloud官网或在查找我的iPhone app里将iPhone设为丢失模式或锁定iPhone，为保护隐私可选抹掉iPhone（会删除iPhone里的所有数据，不可逆） Mac和iPad一样如此 手机在丢失模式下，锁屏界面会显示你设置的一个联系号码。若是好心人送还手机自然大喜。但也要提防钓鱼网站，伪造Apple身份给你发短信或邮件，骗取iCloud密码（lz已上当羞耻哭晕在厕所） 万一不幸iCloud密码泄漏，请及时修改Apple ID的验证问题和Apple ID的密码。切勿以为只改密码万事大吉，盗取你的密码就能获取你的验证问题的答案，有了验证问题答案就能查看你更改的密码（怕）并且可以远程操作（锁定、抹掉…）你的设备（lz已受害二次哭晕在厕所） 为防万一，建议在iCloud的管理我的Apple ID里开启两步验证，此后要操作远程命令就需要短信验证码再加上密码或验证问题。（开启两步验证会给你一份字母加数字的密钥，很重要，是你丢失密码或手机卡后的唯一凭证，切记保存好） 那么故事是这样的：事情发生在15年10月8号，却并非起始于这个日期。8号上午如往常一样打开Mac准备码字，联网之后弹出一个提示iCloud什么的对话框，点了确定Mac就重启了，重启之后竟出现这样的界面：这是什么鬼？刚开始四个方框上提示：输入锁定此系统的PIN码来解锁。what？PIN码？我没有啊，崩溃！百度一些提示说按住option键重新开机。然后出现了一个锁头（这就是固件锁）并没有什么卵用，遂拨打4006-272273（苹果技术支持热线）寻助AppleCare，一系列问答之后大概明白了应该是iCloud密码泄漏，Mac被远程恶意锁定。客服询问我的Apple ID是和别人共用还是怎样泄漏过，才回想起7月份失窃一部iPhone6（新机、心痛） 这就是故事的起点：失窃iPhone后随即登录iCloud将iPhone6设为丢失模式（这时可留下一个联系方式显示在手机解锁屏幕上）几天后收到一条短信（来自香港号码）以苹果的身份，大体意思说 您的iPhone在苹果售后申请换机，因凭证信息不符被Apple售后截下，若情况符实请登录 iCloud网站（一段网址）申请扣机，确认信息后Apple会联系警察交还手机。。。。。 一开始没注意是因为对于找回手机已经不抱希望了（尽管我还没有锁定iPhone，汗）后来看到可申请扣机（其实一开始是短信太长没看懂，笑）因为失窃后已报警，又看到希望的我内心是鸡冻的。然后就上网登录”iCoud.com”(和平常登录时的iCloud界面一个模样)熟练输入帐号密码，登录之后找半天并没有找回iPhone啊，遂电话Apple客服被惨痛告知：这是钓鱼网站骗取Apple ID密码的常见手法。赶紧到iCloud官网查看我的设备，已不见iPhone6的踪影（哭）这里要说客服态度很好，在我传达了收到的短信后，他们首先关注的是我是否已输入了登录密码。 如此看来便是那时候泄漏的iCloud密码了。之后一直没有改密码（汗）而可恶的盗窃者在盗取我的iCloud密码后竟默默蛰伏至今我在6号晚12点左右因为6s的某原因在手机上修改了iCloud密码，在Mac被锁后发现一份iCloud邮件提示我的Mac在7号下午八点多的时候被锁定。以此推断应该是我改密码的行为触动了盗窃者所以远程锁定了我的Mac，之前我以为改密码在Mac被锁之前账号应该是安全的，后来才知并非如此（如前言所述）前后打了四五次400，有一次为查看Apple ID的动态要转接Apple的最高级别安全部门，转接等待一个半小时没接通（汗）不过客服们的态度都特别热情，这点很欣慰！只是她们貌似对PIN码什么的也说不太清，大概认定为被人远程恶意锁定了。 解决方案：到售后解锁，赶到市里，售后态度也很好，只是他们也说不清楚PIN码什么的，今天取Mac时一位技术大哥总算给讲明白怎么回事，解释如下：1）在查找我的iPhone里锁定我的iPhone或iPad可通过密码解锁，若忘记密码可向苹果申请解锁（需要设备的购买凭证，必须要且有效）2）但是，锁定Mac时会输入一个密码，这个密码就是上面提到的PIN码 输入PIN码可以进入系统但是不能进行更改硬盘操作 若是忘记PIN码或者是被恶意锁定的，按组合键Command+Option+P+R可以清空PIN码然后进入系统但仍然不能进行更改硬盘操作。 开机时按住option键进入磁盘分区时就会出现固件锁，在这里输入PIN码也可以进入系统仍然不能进行更改硬盘操作。怎样才能解开固件锁，只有去售后了，他们向Apple提供固件锁的信息，Apple做一个解密包发回来解锁，济南售后花费300大洋，倒是不贵可是心痛（哭） 为保安全，你也可以为你的Mac加上固件锁，自行百度（甚用，忘了心情就不好了。。。） 最后不幸中的万幸是，盗窃者或许先点的锁定Mac这一不可逆的过程导致抹掉Mac不可用，又或者其他的网络连接什么的原因总之我的硬盘资料没有被抹。技术大哥说之前解掉的几个固件锁打开后数据都是被抹掉的，连系统都没了（庆幸）发现资料还在时心情是无法用语言表达的，就用微博上一帅哥的表情来表达吧 再次告诫广大果友： 在保护好自己apple设备的同时更要保护好自己的Apple ID密码，最好开启两步验证。 对于重要文件及时做好备份，Apple的锁做的很强大，极好的保护了我们的设备和数据，可是一旦泄露iCloud密码伤害也会很致命 对于备份，Mac上有Time Machine备份工具甚是好用，听起来（嘿）也是售后的技术大哥告知的，感谢AppleCare和Apple售后的好态度。 后记转载请保留原文地址：http://gonghonglou.com/2016/03/03/protectappleid 迁移文章 首发于2015-10-10]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mac上搭建基于GitHub的Hexo博客]]></title>
    <url>%2F2016%2F02%2F03%2Ffirstblog%2F</url>
    <content type="text"><![CDATA[这是一篇详细文章来讲述用Mac搭建Hexo博客于Github上的完整历程， 也是踩了无数的坑搭起来的，现在写下些经验来分享，希望能帮大家少踩些坑。 曾买过一款阿里的云虚拟主机，后来才发现不能自己装软件只能上传网站程序，除非另买ECS，对于第一个月的实习工资还没拿到手的我想想还是算了，先用Wordpress搭起来玩玩吧。然而在上传网站程序中几次失败，本就觉得没劲，遂一怒转向Github。好了，废话少说，开始吧。 环境配置Hexo官网上本就有对Hexo安装及使用的详细介绍，墙裂推荐。这里来讲述自己安装的亲身步骤，或有区别。 1.Node.js用来生成静态页面。移步Node.js官网，下载v5.5.0 Stable 一路安装即可。 2.Git用来将本地Hexo内容提交到Github上。Xcode自带Git，这里不再赘述。如果没有Xcode可以参考Hexo官网上的安装方法。 安装Hexo当Node.js和Git都安装好后就可以正式安装Hexo了，终端执行如下命令：1$ sudo npm install -g hexo 输入管理员密码（Mac登录密码）即开始安装 (sudo:linux系统管理指令 -g:全局安装) 注意坑一：Hexo官网上的安装命令是$ npm install -g hexo-cli，安装时不要忘记前面加上sudo，否则会因为权限问题报错。 初始化终端cd到一个你选定的目录，执行hexo init命令： 1$ hexo init blog blog是你建立的文件夹名称。cd到blog文件夹下，执行如下命令，安装npm：1$ npm install 执行如下命令，开启hexo服务器：1$ hexo s 此时，浏览器中打开网址http://localhost:4000，能看到如下页面： 本地设置好后，接下来开始关联Github。 关联Github1.创建仓库登录你的Github帐号，新建仓库，名为用户名.github.io固定写法，如gonghonglou.github.io即下图中1所示： 本地的blog文件夹下内容为：1234567_config.yml db.json node_modules package.jsonscaffoldssourcethemes 终端cd到blog文件夹下，vim打开_config.yml，命令如下：1$ vim _config.yml 打开后往下滑到最后，修改成下边的样子：1234deploy: type: git repository: https://github.com/gonghonglou/gonghonglou.github.io.git branch: master 你需要将repository后gonghonglou换成你自己的用户名，地址在上图2位置获取。hexo 3.1.1版本后type:值为git。 注意坑二：在配置所有的_config.yml文件时（包括theme中的），在所有的冒号:后边都要加一个空格，否则执行hexo命令会报错，切记 切记 在blog文件夹目录下执行生成静态页面命令：1$ hexo generate 或者：hexo g 此时若出现如下报错： ERROR Local hexo not found in ~/blog ERROR Try runing: 'npm install hexo --save' 则执行命令： npm install hexo --save 若无报错，自行忽略此步骤。 再执行配置命令：1$ hexo deploy 或者：hexo d 注意坑三：若执行命令hexo deploy仍然报错：无法连接git或找不到git，则执行如下命令来安装hexo-deployer-git： $ npm install hexo-deployer-git --save 再次执行hexo generate和hexo deploy命令。 若你未关联Github，则执行hexo deploy命令时终端会提示你输入Github的用户名和密码，即12Username for 'https://github.com':Password for 'https://github.com': hexo deploy命令执行成功后，浏览器中打开网址http://gonghonglou.github.io（将gonghonglou换成你的用户名）能看到和打开http://localhost:4000时一样的页面。 为避免每次输入Github用户名和密码的麻烦，可参照第二节方法 2.添加ssh key到Github1.1.检查SSH keys是否存在Github执行如下命令，检查SSH keys是否存在。如果有文件id_rsa.pub或id_dsa.pub，则直接进入步骤1.3将SSH key添加到Github中，否则进入下一步生成SSH key。1$ ls -al ~/.ssh 1.2.生成新的ssh key执行如下命令生成public/private rsa key pair，注意将your_email@example.com换成你自己注册Github的邮箱地址。1$ ssh-keygen -t rsa -C "your_email@example.com" 默认会在相应路径下（~/.ssh/id_rsa.pub）生成id_rsa和id_rsa.pub两个文件。 1.3.将ssh key添加到Github中Find前往文件夹~/.ssh/id_rsa.pub打开id_rsa.pub文件，里面的信息即为SSH key，将这些信息复制到Github的Add SSH key页面即可。 进入Github –&gt; Settings –&gt; SSH keys –&gt; add SSH key: Title里任意添一个标题，将复制的内容粘贴到Key里，点击下方Add key绿色按钮即可。 3.发布文章终端cd到blog文件夹下，执行如下命令新建文章：1$ hexo new "postName" 名为postName.md的文件会建在目录/blog/source/_posts下，postName是文件名，为方便链接不建议掺杂汉字。你当然可以用vim来编辑文章。我在用Mou编辑器，支持预览，虽然其预览主题并非我喜欢，如果你有好用的markdown编辑器请推荐给我，感激不尽！ 文章编辑完成后，终端cd到blog文件夹下，执行如下命令来发布：123hexo generate //生成静态页面hexo deploy //将文章部署到Github 至此，Mac上搭建基于Github的Hexo博客就完成了。下面的内容是介绍安装theme和绑定个人域名，如果有兴趣且还有耐心的话，请继续吧。 安装theme你可以到Hexo官网主题页去搜寻自己喜欢的theme。这里以hexo-theme-next为例 终端cd到 blog 目录下执行如下命令：1$ git clone https://github.com/iissnan/hexo-theme-next themes/next 将blog目录下_config.yml里theme的名称landscape修改为next 终端cd到blog目录下执行如下命令(每次部署文章的步骤)：12345$ hexo clean //清除缓存文件 (db.json) 和已生成的静态文件 (public)$ hexo g //生成缓存和静态文件$ hexo d //重新部署到服务器 至于更改theme内容比如名称、描述、头像等去修改blog/_config.yml文件和blog/themes/next/_config.yml文件中对应的属性名称即可， 不要忘记冒号:后加空格。 NexT 使用文档里有极详细的介绍。 绑定个人域名现在使用的域名是Github提供的二级域名，也可以绑定为自己的个性域名。购买域名，可以到GoDaddy官网，网友亲切称呼为：狗爹，也可以到阿里万网购买。我是在万网买的，可直接在其网站做域名解析。 1.Github端在/blog/themes/next/source目录下新建文件名为：CNAME文件，注意没有后缀名！直接将自己的域名如：gonghonglou.com写入。 终端cd到blog目录下执行如下命令重新部署：12345$ hexo clean$ hexo g$ hexo d 注意坑四：网上许多都是说在Github上直接新建CNAME文件，如果这样的话，在你下一次执行hexo d部署命令后CNAME文件就消失了，因为本地没有此文件嘛。 2.域名解析如果将域名指向一个域名，实现与被指向域名相同的访问效果，需要增加CNAME记录。登录万网，在你购买的域名后边点击：解析 –&gt; 添加解析 记录类型：CNAME 主机记录：将域名解析为example.com（不带www），填写@或者不填写 记录值：gonghonglou.github.io. (不要忘记最后的.，gonghonglou改为你自己的用户名)，点击保存即可，如下图： 此时，点击访问http://gonghonglou.com和访问http://gonghonglou.github.io效果一致。 大功告成！ ——11.10更新 以下————————————————1、解决 deploy 后博客空白问题昨晚更新了一下 blog 做了个部署，结果blog就挂了，打开 gonghonglou.com 页面显示一片空白。然而 hexo s 开启本地服务器 localhost:4000 访问是没问题的。上网查了一下，原来是 GitHub Pages 禁止了 source/vendors 目录的访问。Github 在 11 月 3 日更新了版本。其中包括升级了 Jekyll 到 3.3。Jekyll 为了加快构建速度，忽略 vendor 和 node_modules 文件夹。所以部署到 GitHub 后，识别不到本地下的的这个文件夹 blog/themes/next/source/vendor，你只需要给这个文件夹换个名字再重新部署一次就 OK 了。nexT 在 GitHub 上的 isusses 已经给出了解决方案：#1214 还有另一种解决方案就是升级 nexT 主题，cd 到 blog/themes/next/ 下执行命令 git pull 更新。然而，有可能升级后多说评论等第三方工具会失效，慎用。 2、将个人博客同时部署到 GitHub 和 Coding1、首先到 Coding 上注册并开一个项目，项目名称和用户个性后缀相同（方便二级域名访问博客），拿到项目的 https 地址 2、打开本地 blog 目录下的 _config.yml 文件，修改如下123456deploy: type: git repository: github: https://github.com/gonghonglou/gonghonglou.github.io.git coding: https://git.coding.net/gonghonglou/gonghonglou.git branch: master 3、cd 到本地 blog/source 目录下执行如下命令新建 Staticfile 文件1$ touch Staticfile #名字必须是Staticfile 原因是 coding.net 需要以这个文件来作为静态文件部署的标志，就是说看到这个 Staticfile 就知道按照静态文件来发布。 4、执行发布命令 hexo g 、 hexo d 5、个人域名添加两条 CNAME 解析。将 gonghonglou.github.io. 解析为 [海外] ，将 gonghonglou.coding.me. 解析为 [默认] 这样就是为了从国内访问 gonghonglou.com 就是访问 Coding 上的博客项目，从国外访问 gonghonglou.com 就是访问 GitHub 上的博客项目。 6、到 Coding 上的博客项目主页，点击 Pages服务 输入部署分支 master 立即开启 这样就可以访问自己在 Coding 上的个人博客了 gonghonglou.coding.me/gonghonglou 如果像这样你的用户后缀名与博客项目名称相同你还可以省略项目名称直接访问 gonghonglou.coding.me 7、添加域名绑定，输入个人域名就 OK 了，可能需要耐心等待几分钟，这样在国内访问自己的博客就快得多了。 试了一下在国内访问 gonghonglou.com 拦不住 要飞起来了😂 ——11.10更新 以上————————————————后记以上便是我搭建与佳期的个人博客(gonghonglou.com)的全过程，希望对大家有所帮助，欢迎吐槽～ 转载请保留原文地址：http://gonghonglou.com/2016/02/03/firstblog 参考链接 Hexo官网 HEXO 如何生成SSH key]]></content>
      <categories>
        <category>Technology</category>
      </categories>
  </entry>
</search>