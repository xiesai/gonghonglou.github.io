<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[从 SafeKit 看异常保护及 Method Swizzling 使用分析]]></title>
    <url>%2F2017%2F09%2F07%2Fanalyse-safekit%2F</url>
    <content type="text"><![CDATA[因为 SafeKit 的异常保护的原理是在 category 替换系统方法，只需在工程中引用 SafeKit 即可避免 NSArray 数组越界等引发的 crash，并不需要额外操作。所以日常开发中渐渐的并不会怎么在意到 SafeKit 的存在。 最近公司有一份项目需要重构，完全重写的那种，从新建一份空工程开始。之前并没有在意 SafeKit 的存在，所以在最开始并没有在工程中引入 SafeKit，直到一次痛苦的 debug 发现 crash 发生在这样的地方：1234// cacheId 为 NSNmber 类型if ([obj1.cacheId isEqualToNumber:obj2.cacheId]) &#123; // ...&#125; 报错信息：1*** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[__NSCFNumber compare:]: nil argument' 因为在执行 NSNmber 的 isEqualToNumber: 方法时并没有判断 obj2.cacheId 是否为 nil，苹果的API也没有对异常保护，所以当 obj2.cacheId 为 nil 时便会 crash。然后才想起 SafeKit 而且以这种写法 Xcode 也不会给出警告，所以在 coding 时很容易忽略为 nil 的情况。 SafeKit 源码SafeKit 的源码非常少，原理非常简单，就是将 NSNumber, NSArray, NSMutableArray, NSDictionary, NSMutableArray, NSString, NSMutableString 中会因越界、为 nil 等情况发生 crash 的方法替换为自己的方法，在自己的方法中加判断，如果越界、为 nil等 直接 return，否则继续执行。 例如NSArray1234567891011121314151617181920212223242526272829303132333435363738394041#import "NSArray+SafeKit.h"#import "NSObject+swizzle.h"@implementation NSArray (SafeKit)- (instancetype)initWithObjects_safe:(id *)objects count:(NSUInteger)cnt &#123; NSUInteger newCnt = 0; for (NSUInteger i = 0; i &lt; cnt; i++) &#123; if (!objects[i]) &#123; break; &#125; newCnt++; &#125; self = [self initWithObjects_safe:objects count:newCnt]; return self;&#125;- (id)safe_objectAtIndex:(NSUInteger)index &#123; if (index &gt;= [self count]) &#123; return nil; &#125; return [self safe_objectAtIndex:index];&#125;- (NSArray *)safe_arrayByAddingObject:(id)anObject &#123; if (!anObject) &#123; return self; &#125; return [self safe_arrayByAddingObject:anObject];&#125;+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; [self safe_swizzleMethod:@selector(initWithObjects_safe:count:) tarClass:@"__NSPlaceholderArray" tarSel:@selector(initWithObjects:count:)]; [self safe_swizzleMethod:@selector(safe_objectAtIndex:) tarClass:@"__NSArrayI" tarSel:@selector(objectAtIndex:)]; [self safe_swizzleMethod:@selector(safe_arrayByAddingObject:) tarClass:@"__NSArrayI" tarSel:@selector(arrayByAddingObject:)]; &#125;);&#125;@end 以 safe_arrayByAddingObject: 替换 arrayByAddingObject: 方法，当 anObject 不存在则直接返回self以 safe_objectAtIndex: 替换 objectAtIndex: 方法，当数组越界时直接返回 nil 注意，在 class_getInstanceMethod 方法中，要先知道类对应的真实的类名才行，例如 NSArray 其实在 Runtime 中对应着 __NSArrayI： 类 Runtime 中对应 NSNumber __NSCFNumber NSArray __NSArrayI NSMutableArray __NSArrayM NSDictionary __NSDictionaryI NSMutableDictionary __NSDictionaryM NSString __NSCFString NSString __NSCFConstantString 具体对应参考 SafeKit 源码 其中，为了方便 NANumber, NSDictionary 等分类调用，Method Swizzling 操作也被作者在 NSObject 的 Swizzle 分类中替换成自己的 safe_swizzleMethod 方法：1234567891011121314151617181920212223242526272829303132333435@implementation NSObject(Swizzle)+ (void)safe_swizzleMethod:(SEL)srcSel tarSel:(SEL)tarSel&#123; Class clazz = [self class]; [self safe_swizzleMethod:clazz srcSel:srcSel tarClass:clazz tarSel:tarSel];&#125;+ (void)safe_swizzleMethod:(SEL)srcSel tarClass:(NSString *)tarClassName tarSel:(SEL)tarSel&#123; if (!tarClassName) &#123; return; &#125; Class srcClass = [self class]; Class tarClass = NSClassFromString(tarClassName); [self safe_swizzleMethod:srcClass srcSel:srcSel tarClass:tarClass tarSel:tarSel];&#125;+ (void)safe_swizzleMethod:(Class)srcClass srcSel:(SEL)srcSel tarClass:(Class)tarClass tarSel:(SEL)tarSel&#123; if (!srcClass) &#123; return; &#125; if (!srcSel) &#123; return; &#125; if (!tarClass) &#123; return; &#125; if (!tarSel) &#123; return; &#125; Method srcMethod = class_getInstanceMethod(srcClass,srcSel); Method tarMethod = class_getInstanceMethod(tarClass,tarSel); method_exchangeImplementations(srcMethod, tarMethod);&#125;@end 需要注意的是：在 iOS10 及以前，NSArray 的语法糖 array[i] 用法会先调用 - (ObjectType)objectAtIndexedSubscript:(NSUInteger)idx NS_AVAILABLE(10_8, 6_0); 方法，如果没有再调用 - (ObjectType)objectAtIndex:(NSUInteger)index; 方法，所以 SafeKit 可以保证安全。 但是在 iOS11 beta 版中， array[i] 语法糖会直接调用 - (ObjectType)objectAtIndexedSubscript:(NSUInteger)idx NS_AVAILABLE(10_8, 6_0); 方法，如果没有则直接报错，所以为了适配 iOS11 ，在 SafeKit 的 NSArray+SafeKit 分类中还应该替换掉 - (ObjectType)objectAtIndexedSubscript:(NSUInteger)idx NS_AVAILABLE(10_8, 6_0); 方法。 Method Swizzling 使用分析Method Swizzling 大概是 Runtime 中最常用的一个黑魔法了，它本质上就是对 IMP 和 SEL 进行交换。 Method Swizzling 应该在 +load 方法中执行+load 方法是当类或分类被添加到 Objective-C runtime 时被调用的；+initialize 方法是在类或它的子类收到第一条消息之前被调用的，这里所指的消息包括实例方法和类方法的调用。也就是说 +initialize 方法是以懒加载的方式被调用的，如果程序一直没有给某个类或它的子类发送消息，那么这个类的 +initialize 方法是永远不会被调用的。 所以 Method Swizzling 应该在 +load 方法中执行，避免 Method Swizzling 不会被执行到的情况 使用 dispatch_once 保证执行次数Method Swizzling 本质上就是对 IMP 和 SEL 进行交换，如果被执行偶数次那么调换就会失效，相当于没有调换。比如同时调换 NSArray 和 NSMutableArray 中的 objectAtIndex:，如果不用 dispatch_once 保证执行，就可能导致调换方法失效。 也正因为这个原因，在 load 方法中执行 Method Swizzling 时不可调用 [super load] 方法，否则同样会导致调换方法失效。 参考Objective-C Method Swizzling 的最佳实践 一文中给出的最佳实践：12345678910111213141516171819202122232425262728293031323334@interface UIViewController (MRCUMAnalytics)@end@implementation UIViewController (MRCUMAnalytics)+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; Class class = [self class]; SEL originalSelector = @selector(viewWillAppear:); SEL swizzledSelector = @selector(mrc_viewWillAppear:); Method originalMethod = class_getInstanceMethod(class, originalSelector); Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector); BOOL success = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); if (success) &#123; class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); &#125; else &#123; method_exchangeImplementations(originalMethod, swizzledMethod); &#125; &#125;);&#125;#pragma mark - Method Swizzling- (void)mrc_viewWillAppear:(BOOL)animated &#123; [self mrc_viewWillAppear:animated]; [MobClick beginLogPageView:NSStringFromClass([self class])];&#125;@end 主类本身有实现需要替换的方法，也就是 class_addMethod 方法返回 NO 。这种情况的处理比较简单，直接交换两个方法的实现。 主类本身没有实现需要替换的方法，而是继承了父类的实现，即 class_addMethod 方法返回 YES 。这时使用 class_getInstanceMethod 函数获取到的 originalSelector 指向的就是父类的方法，我们再通过执行 class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); 将父类的实现替换到我们自定义的 mrc_viewWillAppear 方法中。这样就达到了在 mrc_viewWillAppear 方法的实现中调用父类实现的目的。 mrc_viewWillAppear:方法的定义看似是递归调用引发死循环，其实不会。因为 [self mrc_viewWillAppear:animated] 消息会动态找到mrc_viewWillAppear: 方法的实现，而它的实现已经被我们与 viewWillAppear: 方法实现进行了互换，所以这段代码不仅不会死循环，如果把 [self mrc_viewWillAppear:animated] 换成 [self viewWillAppear:animated] 反而会引发死循环。 神经病院Objective-C Runtime出院第三天——如何正确使用Runtime 一文中给出的Swizzling Method 标准定义，避免命名冲突：123456789101112131415@implementation NSView (MyViewAdditions)static void MySetFrame(id self, SEL _cmd, NSRect frame);static void (*SetFrameIMP)(id self, SEL _cmd, NSRect frame);static void MySetFrame(id self, SEL _cmd, NSRect frame) &#123; // do custom work SetFrameIMP(self, _cmd, frame);&#125;+ (void)load &#123; [self swizzle:@selector(setFrame:) with:(IMP)MySetFrame store:(IMP *)&amp;SetFrameIMP];&#125;@end 虽然上面的代码看上去不是OC(因为使用了函数指针)，但是这种做法确实有效的防止了命名冲突的问题。原则上来说，其实上述做法更加符合标准化的Swizzling。这种做法可能和人们使用方法不同，但是这种做法更好。Swizzling Method 标准定义应该是如下的样子： 123456789101112131415161718192021typedef IMP *IMPPointer;BOOL class_swizzleMethodAndStore(Class class, SEL original, IMP replacement, IMPPointer store) &#123; IMP imp = NULL; Method method = class_getInstanceMethod(class, original); if (method) &#123; const char *type = method_getTypeEncoding(method); imp = class_replaceMethod(class, original, replacement, type); if (!imp) &#123; imp = method_getImplementation(method); &#125; &#125; if (imp &amp;&amp; store) &#123; *store = imp; &#125; return (imp != NULL);&#125;@implementation NSObject (FRRuntimeAdditions)+ (BOOL)swizzle:(SEL)original with:(IMP)replacement store:(IMPPointer)store &#123; return class_swizzleMethodAndStore(self, original, replacement, store);&#125;@end 后记 小白出手，请多指教。如言有误，还望斧正！ 转载请保留原文地址：http://gonghonglou.com/2017/09/07/analyse-safekit/ Reference Objective-C +load vs +initialize Objective-C Method Swizzling 的最佳实践 神经病院Objective-C Runtime出院第三天——如何正确使用Runtime Objective-C Runtime]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[100 Days, 100 Blogs]]></title>
    <url>%2F2017%2F08%2F09%2F100days-100blogs%2F</url>
    <content type="text"><![CDATA[一直以来都活跃在微博、简书等各大网站搜罗技术博客，每当看到大牛发布或者转发技术博客都会点进去搂一眼，内容比较好或者比较感兴趣的话就会转发收藏。但这些都是零零碎碎的，大多时候都是路上、睡觉前或者什么间隙看到一篇好文章，简单看一下就收藏了，当时来不及 想着以后细读，但往往是在这之后基本上不会再次翻阅了。所以计划从今天起每天仔细阅读一篇技术博客，在这里做一做笔记。 微博每日打卡：#100days,100blogs# # 持续更新中……# Day 55 : iOS 组件化方案探索由 bang’s blog 发布 分别介绍了Limboy的蘑菇街组件化方案和Casa的组件化方案，通过简练的总结和简单的代码示例令这两种方案的原理更加易懂。 # Day 54 : iOS应用架构谈 组件化方案由 Casa Taloyum 发布 iOS应用架构谈 系列文章。对比了蘑菇街的组件化方案和CTMediator组件化方案。 # Day 53 : iOS应用架构谈 本地持久化方案及动态部署由 Casa Taloyum 发布 iOS应用架构谈 系列文章。 # Day 52 : iOS应用架构谈 网络层设计方案由 Casa Taloyum 发布 iOS应用架构谈 系列文章。 # Day 51(yesterday) : iOS应用架构谈 view层的组织和调用方案由 Casa Taloyum 发布 iOS应用架构谈 系列文章。 # Day 50 : iOS应用架构谈 开篇由 Casa Taloyum 发布 iOS应用架构谈 系列文章。评论区也是值得看的地方。 # Day 49 : 组件化架构漫谈由 刘小壮 发布 主要以蘑菇街组件化架构和casatwy组件化方案讲解组件化实现思路，并介绍了滴滴淘宝的组件化过程。 # Day 48 : 细说GCD（Grand Central Dispatch）如何用由 戴铭（ming1016） 发布 文中较详细介绍GCD队列，各种GCD使用方法，实例如何使用Dispatch Source监听系统底层对象，分析不同锁的性能对比，实例GCD死锁情况。 # Day 47 : 不再安全的 OSSpinLock由 Garan no Dou (ibireme) 发布 – 最终的结论就是，除非开发者能保证访问锁的线程全部都处于同一优先级，否则 iOS 系统中所有类型的自旋锁都不能再使用了。– 可以看到除了 OSSpinLock 外，dispatch_semaphore 和 pthread_mutex 性能是最高的。有消息称，苹果在新系统中已经优化了 pthread_mutex 的性能，所以它看上去和 OSSpinLock 差距并没有那么大了。 # Day 46(yesterday) : iOS 保持界面流畅的技巧由 Garan no Dou (ibireme) 发布 演示项目 屏幕显示图像的原理 卡顿产生的原因和解决方案3.1. CPU 资源消耗原因和解决方案3.2. GPU 资源消耗原因和解决方案 AsyncDisplayKit4.1. ASDK 的由来4.2. ASDK 的资料4.3. ASDK 的基本原理4.4. ASDK 的图层预合成4.5. ASDK 异步并发操作4.6. Runloop 任务分发 微博 Demo 性能优化技巧5.1. 预排版5.2. 预渲染5.3. 异步绘制5.4. 全局并发控制5.5. 更高效的异步图片加载5.6. 其他可以改进的地方 如何评测界面的流畅度 YY大神的深度好文，之前已经读过，温故而知新！ # Day 45 : iOS 处理图片的一些小 Tip由 Garan no Dou (ibireme) 发布 – 如何把 GIF 动图保存到相册– 将 UIImage 保存到磁盘，用什么方式最好– UIImage 缓存是怎么回事– 用 imageWithData 能不能避免缓存– 怎么能避免缓存– 能直接取到图片解码后的数据，而不是通过画布取到吗– 如何判断一个文件的图片类型– 怎样像浏览器那样边下载边显示图片 # Day 44 : 移动端图片格式调研由 Garan no Dou (ibireme) 发布 几种图片格式简介 移动端图片类型的支持情况 静态图片的编码与解码3.1. JPEG3.2. PNG3.3. WebP3.4. BPG 动态图片的编码与解码4.1. GIF4.2. APNG4.3. WebP4.4. BPG4.5. 动图性能对比 分析了目前主流和新兴的几种图片格式的特点、性能分析、参数调优，以及相关开源库的选择。 # Day 43 : 深入理解RunLoop由 Garan no Dou (ibireme) 发布 RunLoop 的概念 RunLoop 与线程的关系 RunLoop 对外的接口 RunLoop 的 Mode RunLoop 的内部逻辑 RunLoop 的底层实现 苹果用 RunLoop 实现的功能7.1. AutoreleasePool7.2. 事件响应7.3. 手势识别7.4. 界面更新7.5. 定时器7.6. PerformSelecter7.7 关于GCD7.8 关于网络请求 RunLoop 的实际应用举例8.1. AFNetworking8.2. AsyncDisplayKit YY大神的经典文章，文章太长就不做笔记了，目录贴出来，适合再次阅读。还有阳神关于 RunLoop 的线下分享视频：http://v.youku.com/v_show/id_XODgxODkzODI0.html # Day 42 : Clang Attributes 黑魔法小记由 sunnyxx的技术博客 发布 Clang Attributes 是 Clang 提供的一种源码注解，方便开发者向编译器表达某种要求，参与控制如 Static Analyzer、Name Mangling、Code Generation 等过程，一般以 __attribute__(xxx) 的形式出现在代码中；为方便使用，一些常用属性也被 Cocoa 定义成宏，比如在系统头文件中经常出现的 NS_CLASS_AVAILABLE_IOS(9_0) 就是 __attribute__(availability(...)) 这个属性的简单写法。 – objc_subclassing_restricted：定义一个不可被继承的类。– objc_requires_super：标志子类继承这个方法时需要调用 super，否则给出编译警告。– objc_boxable：box 一个 struct 类型或是 union 类型成 NSValue 对象。– constructor / destructor：构造器和析构器，加上这两个属性的函数会在分别在可执行文件（或 shared library）load和 unload 时被调用，可以理解为在 main() 函数调用前和 return 后执行（若有多个 constructor 且想控制优先级的话，可以写成 attribute((constructor(101)))，里面的数字越小优先级越高，1 ~ 100 为系统保留。）– enable_if：只能用在 C 函数上，可以用来实现参数的静态检查。– cleanup：声明到一个变量上，当这个变量作用域结束时，调用指定的一个函数，Reactive Cocoa 用这个特性实现了神奇的 @onExit。– overloadable：用于 C 函数，可以定义若干个函数名相同，但参数不同的方法，调用时编译器会自动根据参数选择函数原型。– objc_runtime_name：用于 @interface 或 @protocol，将类或协议的名字在编译时指定成另一个。 # Day 41 : 巧用 Class Extension 分离接口依赖由 sunnyxx的技术博客 发布 – Category 的实现可以依赖主类，但主类一定不依赖 Category，也就是说移除任何一个 Category 的代码不会对主类产生任何影响。– Category 可以直接使用主类已有的私有成员变量，但不应该为实现 Category 而往主类中添加成员变量，考虑在 Category 的实现中使用 objc association 来达到相同效果。– Class Extension 和 Category 在语言机制上有着很大差别：Class Extension 在编译期就会将定义的 Ivar、属性、方法等直接合入主类，而 Category 在程序启动 Runtime Loading 时才会将属性（没 Ivar）和方法合入主类。– 将对公业务和对私业务用 Class Extension 的形式拆到两个 Header 中，这样私有类对私有属性的依赖就被成功隔离开 # Day 40 : 2015 Objective-C 新特性由 sunnyxx的技术博客 发布 – Nullability：Nullability 在编译器层面提供了空值的类型检查，在类型不符时给出 warning，方便开发者第一时间发现潜在问题。1234@property (nonatomic, copy, readonly, nullable) NSArray *friends;+ (nullable NSString *)friendWithName:(nonnull NSString *)name;// 假如用来修饰一个变量，前面还要加双下划线：- (void)startWithCompletionBlock:(nullable void (^)(NSError * __nullable error))block; – Lightweight Generics *1234NSArray&lt;NSString *&gt; *strings = @[@"sun", @"yuan"];NSDictionary&lt;NSString *, NSNumber *&gt; *mapping = @&#123;@"a": @1, @"b": @2&#125;;@property (readonly) NSArray&lt;NSURL *&gt; *imageURLs;@interface Stack&lt;ObjectType&gt; : NSObject – __covariant - 协变性，子类型可以强转到父类型（里氏替换原则）：1@interface Stack&lt;__covariant ObjectType&gt; : NSObject – __contravariant - 逆变性，父类型可以强转到子类型：1@interface Stack&lt;__contravariant ObjectType&gt; : NSObject – __kindof123@property (nonatomic, readonly, copy) NSArray&lt;__kindof UIView *&gt; *subviews;这样，写下面的代码时就没有任何警告了：UIButton *button = view.subviews.lastObject; # Day 39(yesterday) : 黑魔法attribute((cleanup))由 sunnyxx的技术博客 发布 – attribute((cleanup(…)))，用于修饰一个变量，在它的作用域结束时可以自动执行一个指定的方法。– 所谓作用域结束，包括大括号结束、return、goto、break、exception等各种情况。– 假如一个作用域内有若干个cleanup的变量，他们的调用顺序是先入后出的栈式顺序；而且，cleanup是先于这个对象的dealloc调用的。– 可以修饰的变量有：NSString、自定义Class、基本类型、block：12345678910111213141516171819202122232425262728293031323334// 1.NSString ---------------------------------------------// 指定一个cleanup方法，注意入参是所修饰变量的地址，类型要一样// 对于指向objc对象的指针(id *)，如果不强制声明__strong默认是__autoreleasing，造成类型不匹配static void stringCleanUp(__strong NSString **string) &#123; NSLog(@"%@", *string);&#125;// 在某个方法中：&#123; __strong NSString *string __attribute__((cleanup(stringCleanUp))) = @"sunnyxx";&#125; // 当运行到这个作用域结束时，自动调用stringCleanUp// 2.自定义的Class ---------------------------------------------static void sarkCleanUp(__strong Sark **sark) &#123; NSLog(@"%@", *sark);&#125;__strong Sark *sark __attribute__((cleanup(sarkCleanUp))) = [Sark new];// 3.基本类型 ---------------------------------------------static void intCleanUp(NSInteger *integer) &#123; NSLog(@"%d", *integer);&#125;NSInteger integer __attribute__((cleanup(intCleanUp))) = 1;// 4.block ---------------------------------------------// void(^block)(void)的指针是void(^*block)(void)static void blockCleanUp(__strong void(^*block)(void)) &#123; (*block)();&#125;&#123; // 加了个`unused`的attribute用来消除`unused variable`的warning __strong void(^block)(void) __attribute__((cleanup(blockCleanUp), unused)) = ^&#123; NSLog(@"I'm dying..."); &#125;;&#125; Reactive Cocoa中神奇的@onExit方法，其实正是上面的写法，简单定义个宏：12#define onExit\ __strong void(^block)(void) __attribute__((cleanup(blockCleanUp), unused)) = ^ 用这个宏就能将一段写在前面的代码最后执行：12345&#123; onExit &#123; NSLog(@"yo"); &#125;;&#125; // Log "yo" # Day 38 : iOS 程序员 6 级考试（答案和解释）由 sunnyxx的技术博客 发布 五道iOS题目，查看原文。 # Day 37 : iOS 程序 main 函数之前发生了什么由 sunnyxx的技术博客 发布 从dyld开始1.1. 动态链接库1.2. dyld：（the dynamic link editor），Apple 的动态链接器，系统 kernel 做好启动程序的初始准备后，交给 dyld 负责。1.3. ImageLoader：当然这个 image 不是图片的意思，它大概表示一个二进制文件（可执行文件或 so 文件），里面是被编译过的符号、代码等，所以 ImageLoader 作用是将这些文件加载进内存，且每一个文件对应一个ImageLoader实例来负责加载。 runtime 与 +load：dyld 担当了 runtime 和 ImageLoader 中间的协调者，当新 image 加载进来后交由 runtime 大厨去解析这个二进制文件的符号表和代码。2.1. 关于 +load 方法的几个 QA 简单总结：整个事件由 dyld 主导，完成运行环境的初始化后，配合 ImageLoader 将二进制文件按格式加载到内存，动态链接依赖库，并由 runtime 负责加载成 objc 定义的结构，所有初始化工作结束后，dyld 调用真正的 main 函数。 # Day 36 : 黑幕背后的Autorelease由 sunnyxx的技术博客 发布 Autorelease对象什么时候释放？1.1. 在没有手加Autorelease Pool的情况下，Autorelease对象是在当前的runloop迭代结束时释放的，而它能够释放的原因是系统在每个runloop迭代中都加入了自动释放池Push和Pop Autorelease原理2.1. AutoreleasePoolPage2.1.1. AutoreleasePool并没有单独的结构，而是由若干个AutoreleasePoolPage以双向链表的形式组合而成（分别对应结构中的parent指针和child指针）2.1.2. AutoreleasePool是按线程一一对应的（结构中的thread指针指向当前线程）2.1.3. AutoreleasePoolPage每个对象会开辟4096字节内存（也就是虚拟内存一页的大小），除了上面的实例变量所占空间，剩下的空间全部用来储存autorelease对象的地址2.1.4. 上面的id *next指针作为游标指向栈顶最新add进来的autorelease对象的下一个位置2.1.5. 一个AutoreleasePoolPage的空间被占满时，会新建一个AutoreleasePoolPage对象，连接链表，后来的autorelease对象在新的page加入2.2. 释放时刻2.2.1. 每当进行一次objc_autoreleasePoolPush调用时，runtime向当前的AutoreleasePoolPage中add进一个哨兵对象，值为0（也就是个nil）2.2.2. 根据传入的哨兵对象地址找到哨兵对象所处的page2.2.3. 在当前page中，将晚于哨兵对象插入的所有autorelease对象都发送一次- release消息，并向回移动next指针到正确位置2.2.4. 从最新加入的对象一直向前清理，可以向前跨越若干个page，直到哨兵所在的page2.3. 嵌套的AutoreleasePool2.3.1. 知道了上面的原理，嵌套的AutoreleasePool就非常简单了，pop的时候总会释放到上次push的位置为止，多层的pool就是多个哨兵对象而已，就像剥洋葱一样，每次一层，互不影响。 Autorelease返回值的快速释放机制3.1. 黑魔法之Thread Local Storage3.2. 黑魔法之__builtin_return_address3.3. 黑魔法之反查汇编指令 其他Autorelease相关知识点4.1. 使用容器的block版本的枚举器时，内部会自动添加一个AutoreleasePool。当然，在普通for循环和for in循环中没有，所以，还是新版的block版本枚举器更加方便。for循环中遍历产生大量autorelease变量时，就需要手加局部AutoreleasePool咯。 # Day 35 : Objective-C Method Swizzling由 玉令天下的博客 发布 Method Swizzling 常用实现方案方案A：如果类中没有实现 Original selector 对应的方法，那就先添加 Method，并将其 IMP 映射为 Swizzle 的实现。然后替换 Swizzle selector 的 IMP 为 Original 的实现；否则交换二者 IMP。1234567891011121314151617181920212223242526+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; Class aClass = [self class]; SEL originalSelector = @selector(method_original:); SEL swizzledSelector = @selector(method_swizzle:); Method originalMethod = class_getInstanceMethod(aClass, originalSelector); Method swizzledMethod = class_getInstanceMethod(aClass, swizzledSelector); BOOL didAddMethod = class_addMethod(aClass, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); if (didAddMethod) &#123; class_replaceMethod(aClass, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); &#125; else &#123; method_exchangeImplementations(originalMethod, swizzledMethod); &#125; &#125;);&#125; 有时为了避免方法命名冲突和参数 _cmd 被篡改，也会使用下面这种『静态方法版本』的 Method Swizzle。CaptainHook 中的宏定义也是采用这种方式，比较推荐：12345678910111213141516171819202122232425262728293031typedef IMP *IMPPointer;static void MethodSwizzle(id self, SEL _cmd, id arg1);static void (*MethodOriginal)(id self, SEL _cmd, id arg1);static void MethodSwizzle(id self, SEL _cmd, id arg1) &#123; // do custom work MethodOriginal(self, _cmd, arg1);&#125;BOOL class_swizzleMethodAndStore(Class class, SEL original, IMP replacement, IMPPointer store) &#123; IMP imp = NULL; Method method = class_getInstanceMethod(class, original); if (method) &#123; const char *type = method_getTypeEncoding(method); imp = class_replaceMethod(class, original, replacement, type); if (!imp) &#123; imp = method_getImplementation(method); &#125; &#125; if (imp &amp;&amp; store) &#123; *store = imp; &#125; return (imp != NULL);&#125;+ (BOOL)swizzle:(SEL)original with:(IMP)replacement store:(IMPPointer)store &#123; return class_swizzleMethodAndStore(self, original, replacement, store);&#125;+ (void)load &#123; [self swizzle:@selector(originalMethod:) with:(IMP)MethodSwizzle store:(IMP *)&amp;MethodOriginal];&#125; 方案 B(方案 A 的阉割版)：12345678910111213+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; Class aClass = [self class]; SEL originalSelector = @selector(method_original:); SEL swizzledSelector = @selector(method_swizzle:); Method originalMethod = class_getInstanceMethod(aClass, originalSelector); Method swizzledMethod = class_getInstanceMethod(aClass, swizzledSelector); method_exchangeImplementations(originalMethod, swizzledMethod); &#125;);&#125; 直接交换 IMP 是很危险的。因为如果这个类中没有实现这个方法，class_getInstanceMethod() 返回的是某个父类的 Method 对象，这样 method_exchangeImplementations() 就把父类的原始实现（IMP）跟这个类的 Swizzle 实现交换了。这样其他父类及其其他子类的方法调用就会出问题，最严重的就是 Crash。但如果这个类中实现了此方法，那么方案 A 等价于方案 B。 结论： Hook 顺序：先 Child 类后 Super 类为了保证 Hook 后方法调用顺序是对的，需要同时满足以下两个条件：– 1.Child 类实现被 Hook 的方法– 2.Super 类实现被 Hook 的方法或使用 A 方案 Hook Hook 顺序：先 Super 类后 Child 类因为 Hook 的顺序是正确的，所以只需满足以下任意一个条件即可：– 1.实现被 Hook 的方法– 2.使用方案 A 进行 Hook # Day 34 : Objective-C 引用计数原理由 玉令天下的博客 发布 有些对象如果支持使用 TaggedPointer，苹果会直接将其指针值作为引用计数返回；如果当前设备是 64 位环境并且使用 Objective-C 2.0，那么“一些”对象会使用其 isa 指针的一部分空间来存储它的引用计数；否则 Runtime 会使用一张散列表来管理引用计数。 引用计数如何存储1.1. TaggedPointer1.2. isa 指针（NONPOINTER_ISA）1.3. 散列表 获取引用计数 修改引用计数3.1. retain 和 release3.2. alloc, new, copy, mutableCopy3.3. autorelease Reference # Day 33(yesterday) : Objective-C 消息发送与转发机制原理由 玉令天下的博客 发布 消息发送和转发流程可以概括为：消息发送（Messaging）是 Runtime 通过 selector 快速查找 IMP 的过程，有了函数指针就可以执行对应的方法实现；消息转发（Message Forwarding）是在查找 IMP 失败后执行一系列转发流程的慢速通道，如果不作转发处理，则会打日志和抛出异常。 八面玲珑的 objc_msgSend1.1. 源码解析1.2. 为什么使用汇编语言 使用 lookUpImpOrForward 快速查找 IMP2.1. 优化缓存查找&amp;类的初始化2.2. 继续在类的继承体系中查找2.3. 回顾 objc_msgSend 伪代码 forwarding 中路漫漫的消息转发3.1. objc_msgForward_impcache 的转换3.2. objc_msgForward 也只是个入口3.3. objc_setForwardHandler 设置了消息转发的回调3.4. 逆向工程助力刨根问底 总结 参考文献 # Day 32 : HTTPS 是如何保证安全的？由 程序员Delton 发布 HTTP 面临的一个问题叫做 “窃听” 或者 “嗅探” ，指的是和你在同一个网络下或者是途径的路由上的攻击者可以偷窥到你传输的内容。 HTTPS 通常是通过“加密”来解决这个问题。2.1. 对称加密：需要一个密钥 key 来加密整个信息，加密和解密所需要使用的 key 是一样的。比如 AES 算法，在数学上保证了，只要你使用的 key 足够足够足够足够的长，破解是几乎不可能的。2.2. 非对称加密：可以生成一对密钥 (k1, k2)，凡是 k1 加密的数据，k1 自身不能解密，而需要 k2 才能解密；凡是 k2 加密的数据，k2 不能解密，需要 k1 才能解密。这种算法事实上有很多，常用的是 RSA，其基于的数学原理是两个大素数的乘积很容易算，而拿到这个乘积去算出是哪两个素数相乘就很复杂了。2.2.1. 用 RSA 技术生成了一对 k1、k2，你把 k1 用明文发送了出去，路经有人或许会截取，但是没有用，k1 加密的数据需要用 k2 才能解密。而此时，k2 在你自己的手里。k1 送达目的地后，目的地的人会去准备一个接下来用于对称加密传输的密钥 key，然后用收到的 k1 把 key 加密了，把加密好的数据传回来。路上的人就算截取到了，也解密不出 key。等到了你自己手上，你用手上的 k2 把用 k1 加密的 key 解出来，现在就只有你和你的目的地拥有 key，你们就可以用 AES 算法进行对称加密的传输啦。2.2.2. 第一个问题：因为 非对称加密 的密码对生成和加密的消耗时间比较长，为了节省双方的计算时间，通常只用它来交换密钥，而非直接用来传输数据。2.2.3. 第二个问题：中间人攻击。2.2.4. 为解决第二个问题引入一个第三方叫做 CA。CA 是一些非常权威的专门用于认证一个网站合法性的组织。服务商可以向他们申请一个证书，使得他们建立安全连接时可以带上 CA 的签名。如果和你建立安全连接的人带着这些人的签名，那么认为这个安全连接是安全的，没有遭到中间人攻击。 # Day 31 : Objective-C Runtime由 玉令天下的博客 发布 引言 简介 与 Runtime 交互3.1. Objective-C 源代码3.2. NSObject 的方法3.3. Runtime 的函数 Runtime 基础数据结构4.1. SEL4.2. id4.3. Class4.3.1. cache_t4.3.2. class_data_bits_t4.3.3. class_ro_t4.3.4. class_rw_t4.3.5. realizeClass4.4. Category4.5. Method4.6. Ivar4.7. objc_property_t4.8. protocol_t4.9. IMP 消息5.1. objc_msgSend 函数5.2. 方法中的隐藏参数5.3. 获取方法地址 动态方法解析 消息转发7.1. 重定向7.2. 转发7.3. 转发和多继承7.4. 替代者对象(Surrogate Objects)7.5. 转发与继承 健壮的实例变量 (Non Fragile ivars) Objective-C Associated Objects Method Swizzling 总结 文章相当长且有质量，把目录贴出来，有不清楚或需要学习的再去原文查阅吧！ # Day 30 : 神经病院Objective-C Runtime出院第三天——如何正确使用Runtime由 一缕殇流化隐半边冰霜（halfrost） 发布 Runtime的优点 实现多继承Multiple Inheritance： – forwardingTargetForSelector:这一步将消息转发给正确的类对象就可以模拟多继承的效果 – 即使我们利用转发消息来实现了“假”继承，但是NSObject类还是会将两者区分开，像respondsToSelector:和 isKindOfClass:这类方法只会考虑继承体系，不会考虑转发链，可以重写 respondsToSelector:和 isKindOfClass:等方法来加入自己的转发算法。 Method Swizzling： Method Swizzling原理：本质上就是对IMP和SEL进行交换。 Method Swizzling使用：通常应用于在category中添加一个方法。 Method Swizzling注意点 – Swizzling应该总在+load中执行 – Swizzling应该总是在dispatch_once中执行 – Swizzling在+load中执行时，不要调用[super load] Method Swizzling使用场景 – 实现AOP – 实现埋点统计 – 实现异常保护 Aspect Oriented Programming Isa Swizzling – KVO是为了监听一个对象的某个属性值是否发生变化。在属性值发生变化的时候，肯定会调用其setter方法。所以KVO的本质就是监听对象有没有调用被监听属性对应的setter方法。 Associated Object关联对象 动态的增加方法 NSCoding的自动归档和自动解档 – 用runtime实现的思路就比较简单，我们循环依次找到每个成员变量的名称，然后利用KVC读取和赋值就可以完成encodeWithCoder和initWithCoder了。 字典和模型互相转换 字典转模型 – 调用 class_getProperty 方法获取当前 Model 的所有属性。 – 调用 property_copyAttributeList 获取属性列表。 – 根据属性名称生成 setter 方法。 – 使用 objc_msgSend 调用 setter 方法为 Model 的属性赋值（或者 KVC） 模型转字典 – 调用 class_copyPropertyList 方法获取当前 Model 的所有属性。 – 调用 property_getName 获取属性名称。 – 根据属性名称生成 getter 方法。 – 使用 objc_msgSend 调用 getter 方法获取属性值（或者 KVC） Runtime的缺点 – Method swizzling is not atomic – Changes behavior of un-owned code – Possible naming conflicts – Swizzling changes the method’s arguments – The order of swizzles matters – Difficult to understand (looks recursive) – Difficult to debug 日常可能用的比较多的Runtime函数：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859// 调用指定方法的实现 id method_invoke ( id receiver, Method m, ... ); // 调用返回一个数据结构的方法的实现 void method_invoke_stret ( id receiver, Method m, ... ); // 返回指定方法的方法描述结构体 struct objc_method_description * method_getDescription ( Method m ); //获取cls类对象所有成员ivar结构体 Ivar *class_copyIvarList(Class cls, unsigned int *outCount) //获取cls类对象name对应的实例方法结构体 Method class_getInstanceMethod(Class cls, SEL name) //获取cls类对象name对应类方法结构体 Method class_getClassMethod(Class cls, SEL name) //获取cls类对象name对应方法imp实现 IMP class_getMethodImplementation(Class cls, SEL name) //测试cls对应的实例是否响应sel对应的方法 BOOL class_respondsToSelector(Class cls, SEL sel) //获取cls对应方法列表 Method *class_copyMethodList(Class cls, unsigned int *outCount) //测试cls是否遵守protocol协议 BOOL class_conformsToProtocol(Class cls, Protocol *protocol) //为cls类对象添加新方法 BOOL class_addMethod(Class cls, SEL name, IMP imp, const char *types) //替换cls类对象中name对应方法的实现 IMP class_replaceMethod(Class cls, SEL name, IMP imp, const char *types) //为cls添加新成员 BOOL class_addIvar(Class cls, const char *name, size_t size, uint8_t alignment, const char *types) //为cls添加新属性 BOOL class_addProperty(Class cls, const char *name, const objc_property_attribute_t *attributes, unsigned int attributeCount) //获取m对应的选择器 SEL method_getName(Method m) //获取m对应的方法实现的imp指针 IMP method_getImplementation(Method m) //获取m方法的对应编码 const char *method_getTypeEncoding(Method m) //获取m方法参数的个数 unsigned int method_getNumberOfArguments(Method m) //copy方法返回值类型 char *method_copyReturnType(Method m) //获取m方法index索引参数的类型 char *method_copyArgumentType(Method m, unsigned int index) //获取m方法返回值类型 void method_getReturnType(Method m, char *dst, size_t dst_len) //获取方法的参数类型 void method_getArgumentType(Method m, unsigned int index, char *dst, size_t dst_len) //设置m方法的具体实现指针 IMP method_setImplementation(Method m, IMP imp) //交换m1，m2方法对应具体实现的函数指针 void method_exchangeImplementations(Method m1, Method m2) //获取v的名称 const char *ivar_getName(Ivar v) //获取v的类型编码 const char *ivar_getTypeEncoding(Ivar v) //设置object对象关联的对象 void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy) //获取object关联的对象 id objc_getAssociatedObject(id object, const void *key) //移除object关联的对象 void objc_removeAssociatedObjects(id object) ⚠️注：runtime 系列文章，有原理讲解有用法示例，深度好文！ # Day 29 : 神经病院Objective-C Runtime住院第二天——消息发送与转发由 一缕殇流化隐半边冰霜（halfrost） 发布 objc_msgSend函数简介。objc_msgSend会做一下几件事情： – 检测这个 selector 是不是要忽略的。 – 检查target是不是为nil。如果这里有相应的nil的处理函数，就跳转到相应的函数中。如果没有处理nil的函数，就自动清理现场并返回。这一点就是为何在OC中给nil发送消息不会崩溃的原因。 – 确定不是给nil发消息之后，在该class的缓存中查找方法对应的IMP实现。如果找到，就跳转进去执行。如果没有找到，就在方法分发表里面继续查找，一直找到NSObject为止 – 如果还没有找到，那就需要开始消息转发阶段了。至此，发送消息Messaging阶段完成。这一阶段主要完成的是通过select()快速查找IMP的过程 消息发送Messaging阶段—objc_msgSend源码解析 消息转发Message Forwarding阶段 forwardInvocation的例子 入院考试 Runtime中的优化 – 方法列表的缓存 – 虚函数表vTable – dyld共享缓存 runtime 系列文章，同样很有深度。因为有很多源码分析和原理讲解且内容较多所以不好简洁总结，之后再温故知新吧！ # Day 28 : 神经病院Objective-C Runtime入院第一天——isa和Class由 一缕殇流化隐半边冰霜（halfrost） 发布 NSObject起源 – 在NSObject协议中，有以下5个方法： 12345- (Class)class OBJC_SWIFT_UNAVAILABLE("use 'anObject.dynamicType' instead"); // 返回对象的类- (BOOL)isKindOfClass:(Class)aClass; // 检查对象是否存在于指定的类的继承体系中(是否是其子类或者父类或者当前类的成员变量)- (BOOL)isMemberOfClass:(Class)aClass; // 检查对象是否存在于指定的类的继承体系中(是否是其子类或者父类或者当前类的成员变量)- (BOOL)conformsToProtocol:(Protocol *)aProtocol; // 检查对象能否响应指定的消息- (BOOL)respondsToSelector:(SEL)aSelector; // 检查对象是否实现了指定协议类的方法 在NSObject的类中还定义了一个方法：- (IMP)methodForSelector:(SEL)aSelector;这个方法会返回指定方法实现的地址IMP – 当我们导入了objc/Runtime.h和objc/message.h两个头文件之后，我们查找到了Runtime的函数之后，代码打完，发现没有代码提示了，可以在 Build settings 中搜索 objc_msg 将 Enable Strict Checking objc_msgSend Calls 设为 NO – 在引入元类之后，类对象和对象查找方法的机制就完全统一了：对象的实例方法调用时，通过对象的 isa 在类中获取方法的实现。类对象的类方法调用时，通过类的 isa 在元类中获取方法的实现。 – isa_t结构体的具体实现 – cache_t的具体实现：Cache的作用主要是为了优化方法调用的性能。当对象receiver调用方法message时，首先根据对象receiver的isa指针查找到它对应的类，然后在类的methodLists中搜索方法，如果没有找到，就使用super_class指针到父类中的methodLists查找，一旦找到就调用方法。如果没有找到，有可能消息转发，也可能忽略它。但这样查找方式效率太低，因为往往一个类大概只有20%的方法经常被调用，占总调用次数的80%。所以使用Cache来缓存经常调用的方法，当调用方法时，优先在Cache查找，如果没有找到，再到methodLists查找 – class_data_bits_t的具体实现 入院考试 – [self class] 与 [super class] – isKindOfClass 与 isMemberOfClass – Class与内存地址 ⚠️注：很有深度，应该是那种温故而知新的文章，后续还会再读！ # Day 27 : 处理手势冲突和错乱的一点经验由 玉令天下的博客 发布 对于复杂页面掺合多种手势的场景，采用“状态机”的方案来区分手势进行页面操作 – 对手势统一处理和分发：把各种手势全都添加到底层的全屏视图上，然后统一处理和分发结果。因为每种手势只有一个且都加在了底层视图，所以不会发生不同视图间的手势错乱。而不同种手势之间的冲突就需要在 UIGestureRecognizerDelegate 中根据业务逻辑来解决了。– 计算响应手势的视图：可以通过 locationInView: 获取手势的坐标，但这里决不能简单地计算手势坐标到视图 center 的距离并选取最近的视图，这里需要检测手势坐标处于哪个视图的范围内。– 处理 Pinch 手势：1、分辨率：当对含有矢量内容的视图进行缩放时会有模糊和锯齿出现，这时递归需要改变 UIView 的 contentScaleFactor 和 CALayer 的 contentsScale 属性。2、坐标：视图的 transform 属性是不会修改视图的 bounds 的，但 frame 作为计算属性还是会变化的。也就是说无论视图放大了多少倍，视图内部的子视图的 frame 不会变。– 处理 Rotation 手势：一直用『视图区域』而不直接用 frame 来描述手势判断依据，是因为当视图旋转（90°倍数除外）之后 frame 并不等于『视图区域』（文中有提供方法用于判断某个点是否在『视图区域』内）– 如果所有手势都交给一个底层视图统一处理的话，上层那一坨视图是不需要响应触摸事件的，有些甚至可以用 Layer 来做。 其中两条参考链接值得参考：Taking Charge of UIView Transforms in iOS ProgrammingScaling UITextView using contentScaleFactor property # Day 26 : 详解CALayer 和 UIView的区别和联系由 kissGod 发布 – 每个 UIView 内部都有一个 CALayer 在背后提供内容的绘制和显示，并且 UIView 的尺寸样式都由内部的 Layer 所提供。两者都有树状层级结构，layer 内部有 SubLayers，View 内部有 SubViews.但是 Layer 比 View 多了个AnchorPoint– 在 View显示的时候，UIView 做为 Layer 的 CALayerDelegate,View 的显示内容由内部的 CALayer 的 display– CALayer 是默认修改属性支持隐式动画的，在给 UIView 的 Layer 做动画的时候，View 作为 Layer 的代理，Layer 通过 actionForLayer:forKey:向 View请求相应的 action(动画行为)– layer 内部维护着三分 layer tree,分别是 presentLayer Tree(动画树),modeLayer Tree(模型树), Render Tree (渲染树),在做 iOS动画的时候，我们修改动画的属性，在动画的其实是 Layer 的 presentLayer的属性值,而最终展示在界面上的其实是提供 View的modelLayer– 两者最明显的区别是 View可以接受并处理事件，而 Layer 不可以 # Day 25 : iOS 常见知识点（三）：Lock由 AidenRao 发布 iOS 中的八大锁– NSLock：遵循 NSLocking 协议lock 方法是加锁，unlock 是解锁，tryLock 是尝试加锁，如果失败的话返回 NO，lockBeforeDate: 是在指定Date之前尝试加锁，如果在指定时间之前都不能加锁，则返回NO互斥锁会使得线程阻塞，阻塞的过程又分两个阶段，第一阶段是会先空转，可以理解成跑一个 while 循环，不断地去申请加锁，在空转一定时间之后，线程会进入 waiting 状态，此时线程就不占用CPU资源了，等锁可用的时候，这个线程会立即被唤醒。– NSConditionLock：遵循 NSLocking 协议，方法都类似，只是多了一个 condition 属性，以及每个操作都多了一个关于 condition 属性的方法。NSConditionLock 还可以实现任务之间的依赖– NSRecursiveLock：递归锁，他和 NSLock 的区别在于，NSRecursiveLock 可以在一个线程中重复加锁（反正单线程内任务是按顺序执行的，不会出现资源竞争问题），NSRecursiveLock 会记录上锁和解锁的次数，当二者平衡的时候，才会释放锁，其它线程才可以上锁成功– NSCondition：NSCondition 并不会像上文的那些锁一样，先轮询，而是直接进入 waiting 状态，当其它线程中的该锁执行 signal 或者 broadcast 方法时，线程被唤醒，继续运行之后的方法– @synchronized：– dispatch_semaphore：GCD 用来同步的一种方式– OSSpinLock：OSSpinLock 会一直轮询，等待时会消耗大量 CPU 资源，不适用于较长时间的任务– pthread_mutex：C 语言下多线程加互斥锁的方式 这里介绍了iOS中的几种锁，简单介绍了其中的用法，但仅凭阅读一篇博客并不能熟知iOS中锁的应用，具体的原理及使用还是要代码中实践才是。 # Day 24 : iOS书写高质量代码之耦合的处理由 MrPeak杂货铺 发布 写高质量代码之耦合的处理的几种方式：– .m引用：直接在 .m 文件创建对象调用方法– .h Property：.h 文件中声明引用，依赖关系清晰– .h ReadOnly Property：重写 setter 方法，对代码有更大的掌控能力，且避免轻易修改引用属性– init 注入：对外就只提供一次机会（初始化init）来设置– parameter 注入：将依赖类作为参数传入函数，耦合只发生在函数内部，一旦函数调用结束，就结束了依赖关系– 单例引用：函数调用中使用单例，缺点也十分明显，应当慎用单例– 继承：通过继承调用父类的方法，但确认父子关系也是麻烦的存在– runtime依赖：耦合度非常之低，甚至可以说感觉不到，但是当依赖类的方法名发生改变时编译并不会提醒– protocol依赖：好处在于他只规定了方法的声明，并不限定具体是那个类来实现它，给后期的维护留下更大的空间和可能性 以上方法的优点和缺点都很明显，怎么使用还要靠业务和coder自己决定。 # Day 23 : iOS关于时间的处理由 MrPeak杂货铺 发布 – GMT：以格林尼治的时间作为公共时间，也就是我们所说的GMT时间（Greenwich Mean Time）。– UTC：原子钟所反映的时间，也就是我们现在所使用的UTC（Coordinated Universal Time ）标准时间。– NSDate：描述的是时间线上的一个绝对的值，和时区和文化无关，它参考的值是：以UTC为标准的，2001年一月一日00：00：00这一刻的时间绝对值。受手机系统时间控制的。也就是说，当你修改了手机上的时间显示，NSDate获取当前时间的输出也会随之改变。1234NSDate* date = [NSDate date];NSLog(@"current date: %@", date); // 绝对的UTC时间NSLog(@"current date interval: %f", [date timeIntervalSinceReferenceDate]); // 返回的是距离参考时间的偏移量NSLog(@"timeIntervalSince1970: %f", [date timeIntervalSince1970]); // 返回Unix time – CFAbsoluteTimeGetCurrent()：参考点是：以GMT为标准的，2001年一月一日00：00：00这一刻的时间绝对值。会跟着当前设备的系统时间一起变化，也可能会被用户修改。– gettimeofday：获得的值是Unix time。Unix time是以UTC 1970年1月1号 00：00：00为基准时间，当前时间距离基准点偏移的秒数。受当前设备的系统时间影响。只不过是参考的时间基准点不一样而已。我们和服务器通讯的时候一般使用Unix time。1234struct timeval now;struct timezone tz;gettimeofday(&amp;now, &amp;tz);NSLog(@"gettimeofday: %ld", now.tv_sec); // Unix time 在Mac的终端可以通过 date -r 1481266031 命令转换成可阅读的时间。– mach_absolute_time()：返回的是CPU已经运行的tick（CPU的时钟周期数）的数量。将这个tick数经过一定的转换就可以变成秒数，或者纳秒数，这样就和时间直接关联了。不会受系统时间影响，只受设备重启和休眠行为影响。– CACurrentMediaTime()：就是将上面mach_absolute_time()的CPU tick数转化成秒数的结果。不会受系统时间影响，只受设备重启和休眠行为影响。12345double mediaTime = CACurrentMediaTime();NSLog(@"CACurrentMediaTime: %f", mediaTime); // 开机后设备一共运行了(设备休眠不统计在内)多少秒NSTimeInterval systemUptime = [[NSProcessInfo processInfo] systemUptime];NSLog(@"systemUptime: %f", systemUptime); // 相同效果：开机后设备一共运行了(设备休眠不统计在内)多少秒 – sysctl：返回的值是上次设备重启的Unix time。会受系统时间影响，用户如果修改时间，值也会随着变化。1234567891011121314151617#include &lt;sys/sysctl.h&gt;- (long)bootTime&#123;#define MIB_SIZE 2 int mib[MIB_SIZE]; size_t size; struct timeval boottime; mib[0] = CTL_KERN; mib[1] = KERN_BOOTTIME; size = sizeof(boottime); if (sysctl(mib, MIB_SIZE, &amp;boottime, &amp;size, NULL, 0) != -1) &#123; return boottime.tv_sec; &#125; return 0;&#125; – 场景一，时间测量：CACurrentMediaTime与NSDate代码本身的损耗差异在几微秒，而我们做UI性能优化的维度在毫秒级别，几个微秒的差异完全不会影响我们最后的判断结果。所以使用NSDate做benchmark完全是可行的，以下是我常用的两个宏：12#define TICK NSDate *startTime = [NSDate date]#define TOCK NSLog(@"Time Cost: %f", -[startTime timeIntervalSinceNow]) – 场景二：客户端和服务器之间的时间同步：（给出了一点技巧，参考原文） # Day 22 : 正确使用@synchronized()由 MrPeak杂货铺 发布 123@synchronized(obj) &#123; //code&#125; @synchronized原理 – synchronized是使用的递归mutex来做同步。 – @synchronized(nil)不起任何作用 – synchronized中传入的object的内存地址，被用作key，通过hash map对应的一个系统维护的递归锁。 @synchronized使用 – 慎用@synchronized(self)，正确的做法是传入一个类内部维护的NSObject对象，而且这个对象是对外不可见的。 – 精准的粒度控制，不同的 @synchronized (token) 使用不同的 token – 注意内部的函数调用，避免 {} 内部有其他隐蔽的函数调用拖慢锁的性能 # Day 21 : iOS多线程到底不安全在哪里？由 MrPeak杂货铺 发布 – self.userName = @&quot;peak&quot;; 是在对指针本身进行赋值，而 [self.userName rangeOfString:@&quot;peak&quot;]; 是在访问指针指向的字符串所在的内存区域，这二者并不一样。– 由于BOOL大小只有1个字节，64位系统的地址总线对于读写指令可以支持8个字节的长度，所以对于BOOL的读和写操作我们可以认为是原子的，所以当我们声明BOOL类型的property的时候，从原子性的角度看，使用atomic和nonatomic并没有实际上的区别（当然如果重载了getter方法就另当别论了）。– atomic的作用只是给getter和setter加了个锁，atomic只能保证代码进入getter或者setter函数内部时是安全的，一旦出了getter和setter，多线程安全只能靠程序员自己保障了。– iOS给代码加锁的方式有很多种，常用的有：@synchronized(token)，NSLock，dispatch_semaphore_t，OSSpinLock，这几种锁都可以带来原子性，性能的损耗依次更小。– _intA ++;（非原子性），OSAtomicIncrement32(&amp;(_intA));（原子性），Atomic Operation只能应用于32位或者64位的数据类型，在多线程使用NSString或者NSArray这类对象的场景，还是得使用锁。 # Day 20 : 与调试器共舞 - LLDB 的华尔兹由 ObjC 中国 发布 这是一篇有料有趣的文章，介绍了很多 LLDB 的命令和用法1234567891011121314151617181920help // 列举出所有的命令print // prin，pri，p，但不能使用 pr，因为 LLDB 不能消除和 process 的歧义expression // 改变一个值po // e -0 --，打印对象p/x // 打印十六进制变量p/t // 打印二进制变量（two）p/c // 打印字符p/s // 打印以空终止的字符串 (译者注：以 '\0' 结尾的字符串)c // continuen // next，thread step-over 如果这行代码是一个函数调用，那么就不会跳进这个函数，而是会执行这个函数，然后继续。s // step，thread step in跳进一个函数调用来调试或者检查程序的执行情况。注意，当前行不是函数调用时，next 和 step 效果是一样的。breakpoint list // br li，看到所有的断点breakpoint set -f main.m -l 16 // b main.m:16，创建断点b isEven // br s -F isEven，在一个符号 (C 语言函数) 上创建断点，而完全不用指定哪一行// 创建断点breakpoint set -F "-[NSArray objectAtIndex:]"b -[NSArray objectAtIndex:]breakpoint set -F "+[NSSet setWithObject:]"b +[NSSet setWithObject:]po [[[UIApplication sharedApplication] keyWindow] recursiveDescription] // 可以看到整个层次 在 Xcode 的UI上创建符号断点：你可以点击断点栏左侧的 + 按钮，选择 “Add Symbolic Breakpoint”，这时会出现一个弹出框，你可以在里面添加例如 -[NSArray objectAtIndex:] 这样的符号断点。这样每次调用这个函数的时候，程序都会停止，不管是你调用还是苹果调用。 断点行为 (Action)：右击任意断点选择“Edit Breakpoint”– 添加 action，可以添加 Debugger Command，Shell Command，Log Message，Sound 等行为– 选项： “Automatically continue after evaluation actions.” 选中它，调试器会运行你所有的命令，然后继续运行 调试器可用命令总览参考：GDB to LLDB # Day 19 : IP，TCP 和 HTTP由 ObjC 中国 发布 又温习一遍网络连接的知识。。。 # Day 18 : 基础集合类由 ObjC 中国 发布 这篇文章可真的是基础了，可能是今天时间太紧张没找到一篇比较有深度的文章，不过这篇文章从基础集合类（NSArray, NSSet, NSOrderedSet 和 NSDictionary）讲起，分别介绍了它们的方法，分析了性能，当是基础知识的一次复习吧。文中总结列出了枚举 NSArray 和 NSDictionary 的几种方法，并分析了各自的性能，值得一看。因为都是一些基础集合类，就不做什么笔记了，各个类的方法到 Xcode 里都能轻易找着。 # Day 17 : Build 过程由 ObjC 中国 发布 解密 Build 日志 Build过程的控制 – Build Phases：代表将代码转变为可执行文件的最高级别规则。 – 定制Build Phases：可以在 build phases 中添加运行自定义脚本，就像CocoaPods使用的一样，来做额外的工作。 – Build Rules：指定了不同的文件类型该如何编译。 – Build Settings：可以配置每个任务（之前在 build log 输出中看到的任务）的详细内容。例如可以添加一个 “Run Script”：如果一个源文件超过指定行数，就发出警告。如下代码所示，设置的行数为 200： 1find "$&#123;SRCROOT&#125;" \( -name "*.h" -or -name "*.m" \) -print0 | xargs -0 wc -l | awk '$1 &gt; 200 &amp;&amp; $2 != "total" &#123; print $2 ":1: warning: file more than 200 lines" &#125;' 工程文件（.pbxproj） # Day 16 : 自定义控件由 ObjC 中国 发布 该篇文章比较基础，介绍了自定义控件用到的 UIView 基类、渲染、交互、本地化及测试： 视图层次概览 – reponders (响应者)：UIView 的父类，能够处理触摸、手势、远程控制等事件。 – views (视图)：视图的区域是由它的 frame 定义的。实际上 frame 是一个派生属性，是由 center 和 bounds 合成而来。 – controls (控件)：建立在视图上，增加了更多的交互支持。最重要的是，它增加了 target / action 模式。 渲染 – 尽量避免 drawRect:，使用现有的视图构建自定义视图。如果重写 drawRect:，确保检查内容模式。默认的模式是将内容缩放以填充视图的范围，这在当视图的 frame 改变时并不会重新绘制。 – 处理图片时，你也可以让 GPU 为你工作来代替使用 Core Graphics。使用 Core Image，你不必用 CPU 做任何的工作就可以在图片上建立复杂的效果。 自定义交互 – 使用 Target-Action – 使用代理 – 使用 Block – 使用 KVO – 使用通知 辅助功能 (Accessibility) – 本地化：使用 NSLocalizedString 本地化字符串。 – 测试：可以使用 UIAutomation 或者其它基于它的工具。 # Day 15 : 底层并发 API由 ObjC 中国 发布 该篇文章并非是专门介绍 GCD(Grand Central Dispatch) 使用的，但从分析及解决并发问题的角度出发介绍了很多 GCD 的用法 从前…：dispatch_once 延后执行：dispatch_after – 队列 – 目标队列：为一个类创建它自己的队列而不是使用全局的队列，这种方式可以设置队列的名字，在 Xcode 的 Debug Navigator 中可以看到所有的队列名字，(lldb) thread list 命令会在控制台打印出所有队列的名字。 – 优先级 隔离 – 资源保护 – 单一资源的多读单写：dispatch_barrier_async – 锁竞争 – 全都使用异步分发：dispatch_async() – 如何写出好的异步 API 迭代执行：dispatch_apply – 组：dispatch_group_t – 对现有API使用 dispatch_group_t 事件源：dispatch_source_t – 监视进程 – 监视文件 – 定时器 – 取消 输入输出 – GCD 和缓冲区：dispatch_data_t – 读和写：dispatch_io_create_with_path、dispatch_io_read、dispatch_io_write 和 dispatch_io_close 基准测试：uint64_t dispatch_benchmark(size_t count, void (^block)(void));能够测量给定的代码执行的平均的纳秒数 原子操作 – 计数器 – 比较和交换 – 原子队列 – 自旋锁 # Day 14 : 常见的后台实践由 ObjC 中国 发布 作者从以下方面介绍了将耗时操作放进后台执行的策略：– 后台的 Core Data– 更新 Main Context– 后台 UI 代码– 后台绘制：如果确定 drawRect: 是应用的性能瓶颈，把 drawRect:中的代码放到后台操作中去。然后将原本打算绘制的视图用一个 image view 来替换，等到操作执行完后再去更新。在绘制的方法中，使用 UIGraphicsBeginImageContextWithOptions 来取代 UIGraphicsGetCurrentContext ：12345UIGraphicsBeginImageContextWithOptions(size, NO, 0);// drawing code hereUIImage *i = UIGraphicsGetImageFromCurrentImageContext();UIGraphicsEndImageContext();return i; 通过在第三个参数中传入 0 ，设备的主屏幕的 scale 将被自动传入，这将使图片在普通设备和 retina 屏幕上都有良好的表现。 – 异步网络请求处理：像 AFNetworking 这样的框架：建立一个独立的线程，为建立的线程设置自己的 run loop，然后在其中调度 URL 连接。– 进阶：后台文件 I/O：对于不方便一次性读入内存的大文件可以使用异步处理文件的 NSInputStream。。。。。。 # Day 13 : 并发编程：API 及挑战由 ObjC 中国 发布 ##1、OS X 和 iOS 中的并发编程– 线程可以使用 Instruments 中的 CPU strategy view 来得知代码是如何在多核 CPU 中调度执行的。– Grand Central DispatchGCD 公开有 5 个不同的队列：运行在主线程中的 main queue，3 个不同优先级的后台队列，以及一个优先级更低的后台队列（用于 I/O）。 另外，开发者可以创建自定义队列：串行或者并行队列。自定义队列非常强大，在自定义队列中被调度的所有 block 最终都将被放入到系统的全局队列中和线程池中。强烈建议在绝大多数情况下使用默认的优先级队列，避免在不同优先级的队列中调度访问共享资源的任务而产生不可预期的行为，比如低优先级的任务阻塞了高优先级任务而造成程序的完全挂起。– Operation QueuesNSOperationQueue 有两种不同类型的队列：主队列和自定义队列。主队列运行在主线程之上，而自定义队列在后台执行。你可以通过重写 main 或者 start 方法来定义自己的 operations。你可以通过 maxConcurrentOperationCount 属性来控制一个特定队列中可以有多少个操作参与并发执行，还可以在 operation 之间指定依赖关系。– Run Loops主线程一般来说都已经配置好了 main run loop。然而其他线程默认情况下都没有设置 run loop。你也可以自行为其他线程设置 run loop ，但是一般来说我们很少需要这么做。大多数时间使用 main run loop 会容易得多。 ##2、并发编程中面临的挑战– 资源共享– 互斥锁– 死锁– 资源饥饿（Starvation）– 优先级反转 ##3、总结我们建议采纳的安全模式是这样的：从主线程中提取出要使用到的数据，并利用一个操作队列在后台处理相关的数据，最后回到主队列中来发送你在后台队列中得到的结果。使用这种方式，你不需要自己做任何锁操作，这也就大大减少了犯错误的几率。 # Day 12 : 理解 Scroll Views由 ObjC 中国 发布 该篇文章比较简洁，从 UIView 的光栅化和组合说起，简单明了的介绍了 Scroll View 的实现思路。并介绍了 Scroll View 的：– Content Offset：相当于更改 Superview.bounds.origin– Content Size：可滚动区域– Content Insets：可以改变 content offset 的最大和最小值，这样便可以滚动出可滚动区域 或许可以应用在有键盘弹出的页面，比如登录页面，弹出键盘输入用户名密码时会遮挡屏幕下半部的视图，可以采用 Scroll View 的滚动特性来解决这一尴尬，恰巧今天碰见 Medium 的登录页面貌似就是这么设计的。 # Day 11 : 绘制像素到屏幕上由 ObjC 中国 发布 文章知识比较碎却又是全集中在屏幕绘制这一块，许多知识点都基于原理特别受用。以下是文章中提及的知识点（目录）：– 图形堆栈– 软件组成：Display &lt;-&gt; GPU &lt;-&gt; GPU Driver &lt;-&gt; OpenGL(Open Graphics Library) &lt;-&gt; Core Animation/Core Graphics/Core Image &lt;-&gt; app– 硬件参与者– 合成：对于屏幕上的每一个像素，GPU 需要算出怎么混合这些纹理来得到像素 RGB 的值，并最终显示在屏幕上。所以减少视图层级可以有效提高性能，因为 GPU 需要将重叠的视图计算合成在一起（将纹理中的一个像素合成到另一个纹理的像素上）。– 不透明 VS 透明：当源纹理是完全不透明的时候，目标像素就等于源纹理。这可以省下 GPU 很大的工作量，这样只需简单的拷贝源纹理而不需要合成所有的像素值。CALayer 有一个叫做 opaque 的属性，如果这个属性为 YES，GPU 将不会做任何合成，而是简单从这个层拷贝，不需要考虑它下方的任何东西(因为都被它遮挡住了)，这节省了 GPU 相当大的工作量。Instruments 中 color blended layers 选项中所涉及的，允许你看到哪一个 layers(纹理) 被标注为透明的。– 像素对齐 VS 不重合在一起：「缩放」和「纹理的起点不在一个像素的边界上」会导致一个 layer 上所有的像素和屏幕上的像素不对齐，GPU 需要再做额外的计算。它需要将源纹理上多个像素混合起来，生成一个用来合成的值。– Masks(蒙板)：mask 是一个拥有 alpha 值的位图，当像素要和它下面包含的像素合并之前都会把 mask 应用到图层的像素上去。当你要设置一个图层的圆角半径时，你可以有效的在图层上面设置一个 mask。– 离屏渲染(Offscreen Rendering)：为 layer 使用蒙板、设置圆角半径、产生阴影会造成屏幕外渲染。Instrument 的 Core Animation 工具有一个叫做 Color Offscreen-Rendered Yellow 的选项，它会将已经被渲染到屏幕外缓冲区的区域标注为黄色。同时记得检查 Color Hits Green and Misses Red 选项。绿色代表无论何时一个屏幕外缓冲区被复用，而红色代表当缓冲区被重新创建。– 更多的关于合成– OS X– Core Animation OpenGL ES– CPU 限制 VS GPU 限制：你可以使用 OpenGL ES Driver instrument，点击上面那个小的 i 按钮，配置一下，同时注意勾选 Device Utilization %。现在，当你运行你的 app 时，你可以看到你 GPU 的负荷。– Core Graphics / Quartz 2D– CGLayer– 像素– 默认的像素布局– 深奥的布局– 二维数据– YCbCr– 图片格式– JPEG– PNG– 挑选一个格式– UIKit 和 Pixels– With –drawRect:– 不使用 -drawRect:– 实现-drawRect: 还是不实现 -drawRect:– 单一颜色– 可变尺寸的图像– 并发绘图– CALayer– 自定义绘制的图层– 形状和文本图层– 异步绘图 # Day 10 : 谈谈 iOS 中图片的解压缩由 雷纯锋的技术博客 发布 ##1、图片加载图片加载的工作流参考 FastImageCache 在 GitHub 上的 README.md。图片在渲染到 UIImageView 的图层之前需要将其解压缩，而对图片解压缩默认是在主线程完成的，并且是一个非常耗时的操作，在对性能要求比较高时可以在图片渲染到屏幕之前在子线程提前对图片进行强制解压缩，强制解压缩的原理就是对图片进行重新绘制，得到一张新的解压缩后的位图。其中，用到的最核心的函数是 CGBitmapContextCreate ：1234CG_EXTERN CGContextRef __nullable CGBitmapContextCreate(void * __nullable data, size_t width, size_t height, size_t bitsPerComponent, size_t bytesPerRow, CGColorSpaceRef cg_nullable space, uint32_t bitmapInfo) CG_AVAILABLE_STARTING(__MAC_10_0, __IPHONE_2_0); 其中：– data：如果不为 NULL ，那么它应该指向一块大小至少为 bytesPerRow height 字节的内存；如果 为 NULL ，那么系统就会为我们自动分配和释放所需的内存，所以一般指定 NULL 即可；– width 和 height：位图的宽度和高度，分别赋值为图片的像素宽度和像素高度即可；– bitsPerComponent：像素的每个颜色分量使用的 bit 数，在 RGB 颜色空间下指定 8 即可；– bytesPerRow：位图的每一行使用的字节数，大小至少为 width bytes per pixel 字节。有意思的是，当我们指定 0 时，系统不仅会为我们自动计算，而且还会进行 cache line alignment 的优化；– space：就是我们前面提到的颜色空间，一般使用 RGB 即可；– bitmapInfo：就是我们前面提到的位图的布局信息。涉及到的概念：Pixel Format（像素格式）、Color and Color Spaces（颜色空间）、Color Spaces and Bitmap Layout（位图布局） ##2、开源库贴出了 YYKit 中存在于 YYImageCoder 类中用于解压缩图片的核心代码的函数 YYCGImageCreateDecodedCopy。讲解代码步骤并对 YYKit，SDWebImage，FLAnimatedImage 做了性能比对。 # Day 9 : Objective-C Fast Enumeration 的实现原理由 雷纯锋的技术博客 发布 ##1、解析 NSFastEnumeration 协议1234567891011121314/** Returns by reference a C array of objects over which the sender should iterate, and as the return value the number of objects in the array. @param state Context information that is used in the enumeration to, in addition to other possibilities, ensure that the collection has not been mutated. @param buffer A C array of objects over which the sender is to iterate. @param len The maximum number of objects to return in stackbuf. @discussion The state structure is assumed to be of stack local memory, so you can recast the passed in state structure to one more suitable for your iteration. @return The number of objects returned in stackbuf. Returns 0 when the iteration is finished. */- (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state objects:(id __unsafe_unretained [])stackbuf count:(NSUInteger)len 结构体 NSFastEnumerationState 的定义:123456typedef struct &#123; unsigned long state; id __unsafe_unretained _Nullable * _Nullable itemsPtr; unsigned long * _Nullable mutationsPtr; unsigned long extra[5];&#125; NSFastEnumerationState; ##2、快速枚举的内部实现通过 clang -rewrite-objc main.m 命令重写了一段 OC 的快速枚举代码，详尽的注释介绍了快速枚举的内部实现，及在 for/in 语句中利用 goto 实现 continue 和 break 命令的 c++ 代码。 ##3、实现 NSFastEnumeration 协议作者给出了一个实现 - (NSUInteger)countByEnumeratingWithState:(NSFastEnumerationState *)state objects:(id __unsafe_unretained [])stackbuf count:(NSUInteger)len; 的例子 ##3、参考链接在文末的参考链接中有文 Friday Q&amp;A 2010-04-16: Implementing Fast Enumeration 同样介绍了快速枚举的实现。 # Day 8 : iOS 并发编程之 Operation Queues由 雷纯锋的技术博客 发布 这篇文章比较长，且相当详细，很多也是 Operation Queues 的基础用法，所以这里就只将文章目录记下来好了，下次复习（的话）先来过一遍目录，记不起的再去查阅文章吧。该篇文章详细介绍了 Operation Queues 的一系列使用，并且 SDWebImage 也用到了 Operation Queues，对于不久后去阅读 SDWebImage 源码想必会很有帮助。 ##1、基本概念– 进程（process）、线程（thread）、任务（task）– 串行 vs. 并发– 同步 vs. 异步– 队列 vs. 线程的概念。 ##2、iOS 的并发编程模型 ##3、Operation Queues vs. Grand Central Dispatch (GCD) ##4、关于 Operation 对象– 并发 vs. 非并发 Operation– 创建 NSInvocationOperation 对象– 创建 NSBlockOperation 对象 ##5、自定义 Operation 对象– 执行主任务– 响应取消事件– 配置并发执行的 Operation– 维护 KVO 通知 ##6、定制 Operation 对象的执行行为– 配置依赖关系– 修改 Operation 在队列中的优先级– 修改 Operation 执行任务线程的优先级– 设置 Completion Block ##7、执行 Operation 对象– 添加 Operation 到 Operation Queue 中– 手动执行 Operation– 取消 Operation– 等待 Operation 执行完成– 暂停和恢复 Operation Queue ##8、总结 # Day 7 : Objective-C Method Swizzling 的最佳实践由 雷纯锋的技术博客 发布 ##1、Method 的数据结构：1234567891011121314struct method_t &#123; SEL name; // 方法的名称，用于唯一标识某个方法，比如 @selector(viewWillAppear:) const char *types; // 方法的返回值和参数类型 IMP imp; // 函数指针，指向方法的实现 struct SortBySELAddress : public std::binary_function&lt;const method_t&amp;, const method_t&amp;, bool&gt; &#123; bool operator() (const method_t&amp; lhs, const method_t&amp; rhs) &#123; return lhs.name &lt; rhs.name; &#125; &#125;; // 一个根据 name 的地址对方法进行排序的函数&#125;; – 实例方法保存在类对象中，类方法保存在元类对象中。（参见Objective-C 对象模型）– 原则上，方法的名称 name 和方法的实现 imp 是一一对应的，而 Method Swizzling 的原理就是动态地改变它们的对应关系，以达到替换方法实现的目的。 ##2、Method Swizzling 的最佳实践+load 和 +initialize 是 Objective-C runtime 会自动调用的两个类方法。– +initialize 方法以懒加载的方式被调用的，有可能不会被调用，而 +load 方法是在类被加载的时候调用。– Objective-C runtime 自动调用 +load 方法时，分类中的 +load 方法并不会对主类中的 +load 方法造成覆盖综上，分类中的 +load 方法是实现 Method Swizzling 逻辑的最佳“场所”– 应当使用 dispatch_once 保证 Method Swizzling 只被调用一次 文章示例代码：– 主类本身有实现需要替换的方法，即返回 NO 时，直接交换两个方法的实现；– 主类本身没有实现需要替换的方法，而是继承了父类的实现，即返回 YES 时，将父类的实现替换到我们自定义的 mrc_viewWillAppear 方法中。123456789101112131415161718192021222324252627@implementation UIViewController (MRCUMAnalytics)+ (void)load &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; Class class = [self class]; SEL originalSelector = @selector(viewWillAppear:); SEL swizzledSelector = @selector(mrc_viewWillAppear:); Method originalMethod = class_getInstanceMethod(class, originalSelector); Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector); BOOL success = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); if (success) &#123; class_replaceMethod(class, swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); &#125; else &#123; method_exchangeImplementations(originalMethod, swizzledMethod); &#125; &#125;);&#125;#pragma mark - Method Swizzling- (void)mrc_viewWillAppear:(BOOL)animated &#123; [self mrc_viewWillAppear:animated]; [MobClick beginLogPageView:NSStringFromClass([self class])];&#125;@end # Day 6 : Objective-C Autorelease Pool 的实现原理由 雷纯锋的技术博客 发布 ##1、autoreleased 对象的释放时机对象 A 被创建时引用计数为 1，当有变量 B 指向这个对象时，引用计数 +1，变量 B 离开作用域后为 nil，对象 A 的引用计数 -1，当对象 A 所在的 autoreleasepool 被 drain ，其中的 autoreleased 对象被 release ，对象 A 的引用计数 -1。当对象 A 的引用计数为 0 时随即被释放。 其中提到了 __weak 的两个特性：– __weak 变量不会影响所指向对象的生命周期– __weak 变量所指向的对象被释放时，__weak 变量的值会被置为 nil ##2、AutoreleasePoolPage– 介绍了 AutoreleasePoolPage 的内存结构– Autorelease Pool Blocks 通过 clang -rewrite-objc 改写成 c++ 代码的实现，和其中的 push 操作、autorelease 操作、pop 操作 ##3、NSThread、NSRunLoop 和 NSAutoreleasePool Each NSThread object, including the application’s main thread, has an NSRunLoop object automatically created for it as needed. The Application Kit creates an autorelease pool on the main thread at the beginning of every cycle of the event loop, and drains it at the end, thereby releasing any autoreleased objects generated while processing an event. Each thread (including the main thread) maintains its own stack of NSAutoreleasePool objects. # Day 5 : Objective-C Associated Objects 的实现原理由 雷纯锋的技术博客 发布 ##1、相关函数在 Objective-C 中可以通过 Category 给一个现有的类添加属性，但是却不能添加实例变量，我们可以通过 Associated Objects 来弥补这一不足123void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy); // 用于给对象添加关联对象，传入 nil 则可以移除已有的关联对象id objc_getAssociatedObject(id object, const void *key); // 用于获取关联对象void objc_removeAssociatedObjects(id object); // 用于移除一个对象的所有关联对象 ##2、key 值上边前两个函数需要传入一个 key 作为唯一变量，作者推荐 selector ，使用 getter 方法的名称作为 key 值。这样就省掉了一个变量名，解决了给这个 key 命名的烦恼。 ##3、关联策略 关联策略 等价属性 说明 OBJC_ASSOCIATION_ASSIGN @property (assign) or @property (unsafe_unretained) 弱引用关联对象 OBJC_ASSOCIATION_RETAIN_NONATOMIC @property (strong, nonatomic) 强引用关联对象，且为非原子操作 OBJC_ASSOCIATION_COPY_NONATOMIC @property (copy, nonatomic) 复制关联对象，且为非原子操作 OBJC_ASSOCIATION_RETAIN @property (strong, atomic) 强引用关联对象，且为原子操作 OBJC_ASSOCIATION_COPY @property (copy, atomic) 复制关联对象，且为原子操作 ##4、实现 getter setter 方法ViewController+AssociatedObjects.h：123@interface ViewController (AssociatedObjects)@property (nonatomic, copy) NSString *associatedObject_copy;@end ViewController+AssociatedObjects.m：12345678@implementation ViewController (AssociatedObjects)- (NSString *)associatedObject_copy &#123; return objc_getAssociatedObject(self, _cmd);&#125;- (void)setAssociatedObject_copy:(NSString *)associatedObject_copy &#123; objc_setAssociatedObject(self, @selector(associatedObject_copy), associatedObject_copy, OBJC_ASSOCIATION_COPY_NONATOMIC);&#125;@end ##5、总结– 关联对象与被关联对象本身的存储并没有直接的关系，它是存储在单独的哈希表中的；– 关联对象的五种关联策略与属性的限定符非常类似，在绝大多数情况下，我们都会使用 OBJC_ASSOCIATION_RETAIN_NONATOMIC 的关联策略，这可以保证我们持有关联对象；– 关联对象的释放时机与移除时机并不总是一致，比如实验中用关联策略 OBJC_ASSOCIATION_ASSIGN 进行关联的对象，很早就已经被释放了，但是并没有被移除，而再使用这个关联对象时就会造成 Crash 。 # Day 4 : Objective-C +load vs +initialize由 雷纯锋的技术博客 发布 ##1、+load– 调用所有类的 +load 方法（包括分类的 +load 方法）是直接使用函数内存地址的方式 (*load_method)(cls, SEL_load); 进行调用的，而不是使用发送消息 objc_msgSend 的方式。也就是说如果子类没有实现 +load 方法，那么当它被加载时 runtime 是不会去调用父类的 +load 方法的。同理，当一个类和它的分类都实现了 +load 方法时，两个方法都会被调用。– 子类的 +load 方法会在它的所有父类的 +load 方法之后执行，而分类的 +load 方法会在它的主类的 +load 方法之后执行。但是不同的类之间的 +load 方法的调用顺序是不确定的。 ##2、+initialize– runtime 使用了发送消息 objc_msgSend 的方式对 +initialize 方法进行调用。如果子类没有实现 +initialize 方法，那么继承自父类的实现会被调用；如果一个类的分类实现了 +initialize 方法，那么就会对这个类中的实现造成覆盖。– 如果一个子类没有实现 +initialize 方法，那么父类的实现是会被执行多次的。可以使用下面的代码确保自己的 +initialize 方法只执行一次：12345+ (void)initialize &#123; if (self == [ClassName self]) &#123; // ... do the initialization ... &#125;&#125; ##3、总结 +load +initialize 调用时机 被添加到 runtime 时 收到第一条消息前，可能永远不调用 调用顺序 父类-&gt;子类-&gt;分类 父类-&gt;子类 调用次数 1次 多次 是否需要显式调用父类实现 否 否 是否沿用父类的实现 否 是 分类中的实现 类和分类都执行 覆盖类中的方法，只执行分类的实现 # Day 3 : Objective-C对象模型及应用由 唐巧的博客 发布 ##1、ISA 指针– 每一个对象都有一个名为 isa 的指针，指向该对象的类。– 在 Objective-C 语言中，每一个类实际上也是一个对象，每一个类也有一个名为 isa 的指针，指向该类的元类。– 元类的 isa 指针指向根元类。– 根元类的 isa 指针指向自己。 （文章中有一张图直白的说明了 isa 指针的指向） ##2、Method Swizzling API 说明– class_replaceMethod, 当需要替换的方法可能有不存在的情况时，可以考虑使用该方法。– method_exchangeImplementations，当需要交换 2 个方法的实现时使用。– method_setImplementation 最简单的用法，当仅仅需要为一个方法设置其实现方式时使用。 # Day 2 : 谈Objective-C block的实现由 唐巧的博客 发布 ##1、block 的 struct 结构：123456789101112131415struct Block_descriptor &#123; unsigned long int reserved; unsigned long int size; void (*copy)(void *dst, void *src); void (*dispose)(void *);&#125;;struct Block_layout &#123; void *isa; // 所有对象都有该指针，用于实现对象相关的功能。 int flags; // 用于按 bit 位表示一些 block 的附加信息，本文后面介绍 block copy 的实现代码可以看到对该变量的使用。 int reserved; // 保留变量。 void (*invoke)(void *, ...); // 函数指针，指向具体的 block 实现的函数调用地址。 struct Block_descriptor *descriptor; // 表示该 block 的附加描述信息，主要是 size 大小，以及 copy 和 dispose 函数的指针。 /* Imported variables. */&#125;; ##2、clang 命令改写 OC 语言下的 block使用 clang 的 clang -rewrite-objc block.c 命令，可以将 Objetive-C 的源码改写成 c 语言的，生成的 .cpp 文件中有许多关键代码展示了 block 的实现原理。 其中，block 中操作未经 __block 修饰的外部变量时，.cpp 文件中相关代码为：12345static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; int a = __cself-&gt;a; // bound by copy printf("%d\n", a); &#125; block 中操作经 __block 修饰的外部变量时，.cpp 文件中相关代码为：123456static void __main_block_func_0(struct __main_block_impl_0 *__cself) &#123; __Block_byref_a_0 *a = __cself-&gt;a; // bound by ref printf("%d\n", (a-&gt;__forwarding-&gt;a)); (a-&gt;__forwarding-&gt;a) = 1023; &#125; 结论：1、在 block 内部修改变量 a 的内容，不会影响外部的实际变量 a，是因为在 block 内部 copy 了一份变量 a。2、当变量使用 __block 修饰时，block 内部是引用的外部变量的指针，所以可以修改外部的实际变量 a。 # Day 1 : 深入理解Objective-C：Category由 美团点评技术团队 发布 ##1、category 在 runtime 层用结构体 category_t 定义：12345678typedef struct category_t &#123; const char *name; // 类的名字 classref_t cls; // 类 struct method_list_t *instanceMethods; // category中所有给类添加的实例方法的列表 struct method_list_t *classMethods; // category中所有添加的类方法的列表 struct protocol_list_t *protocols; // category实现的所有协议的列表 struct property_list_t *instanceProperties; // category中添加的所有属性&#125; category_t; 由该结构体可以看出 category 可以动态的添加实例方法，类方法，甚至可以实现协议，添加属性，但无法添加实例变量因为无法添加实例变量，所以当采用 category 为类添加属性时，并不会自动生成带有 _ 的实例变量，所以 setter 和 getter 方法也需要自己去实现，在文章末尾有介绍采用关联对象来实现，使用 objc_setAssociatedObject 和 objc_getAssociatedObject 方法。 ##2、category 替换原来类已有的方法category 的方法被放到了新方法列表的前面，而原来类的方法被放到了新方法列表的后面，运行时在查找方法的时候是顺着方法列表的顺序查找的，它只要一找到对应名字的方法，就会罢休。所以，category 的方法没有“完全替换掉”原来类已经有的方法。在文章第六节也有介绍可以使用 class_copyMethodList 方法获取方法列表，顺着方法列表找到最后一个对应名字的方法，就可以调用原来类的方法 ##3、-category 和 +load 方法在类的 +load 方法调用的时候，我们可以调用 category 中声明的方法，因为附加 category 到类的工作会先于 +load 方法的执行+load 的执行顺序是先类，后 category，而 category 的 +load 执行顺序是根据编译顺序决定的（Compile Sources（4 items）里的顺序） 后记 小白出手，请多指教。如言有误，还望斧正！ 转载请保留原文地址：http://gonghonglou.com/2017/08/09/100days-100blogs]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[记环青海湖骑行]]></title>
    <url>%2F2017%2F07%2F29%2Fqinghaihu-cycling%2F</url>
    <content type="text"><![CDATA[生活终究按不住远方的躁动骑行将会是你爱上的运动方式 自去年环崇明岛骑行之后便念念不忘再计划骑行一次，而且最近特别喜好西北远方，虽然在2016 年的年终总结里计划了五月份骑行青海湖，不过听网友推荐七月才是青海湖最美骑行季节，由环湖赛就安排在七月份也可见一斑。所以便将这份骑行计划安排在了七月份，只身一人，来一场远方的躁动吧！ 其实青海湖有许多租车服务，只不过我更喜欢骑自己的车子，所以自己带了车子过去。一辆车子，一个满满的驮包，讲真：带起来超费劲。到了西宁住宿洗澡的时候我才发现，两肩已经勒出淤血。。。也正是因为自己带了车子，所以选择了火车出行，因此省下了一笔出行费。二十五个小时的卧铺，这是我坐过的最长时间的火车了，本以为会累成狗，实际上却没有。在车上看一部电影（《神奇女侠》）、看一本书（东野圭吾的《恶意》）、听车厢里的人聊天、看路过的风景。就这些，不知觉的西宁就到了。 这种，一个人，坐上驶往远方的列车，置身嘈杂的车厢，却有独自宁静的感觉……也让人蛮享受的「摊手」 经历“短暂”的二十五小时的卧铺，西宁站，到了： 背一车子，拎一驮包，加持三千多海拔及西北内陆地区的干燥，在从西宁站到宾馆短短不足一公里的路程，休息了无数次，特别容易气喘而且干燥异常，而我…还没带水……（在接下来的四五天了，我留了N次鼻血…因为青海这干燥的天气。五分钟不喝水就感觉要干涸了，然而喝过水之后也不会缓解这种感觉多少💊） 总之，历尽辛苦总算到了宾馆！在卸下行李关上房门之后才感觉，一个人，有些太宁静了。突然感觉太空荡了，或者是，空荡荡…打开电视，CCTV1，调大音量，who care 节目是什么…出门买了瓶水，吃了碗面（真tm咸，突然想起来大一时候，南方同学乍来北方说北方的饭啥都咸，我想现在的我稍微能感受一点了） 回宾馆路上，约晚上十一点，一个人，七月的西宁，凉爽的夜晚，有风，没有身影。 洗个澡睡个觉，明个早起赶七点半西宁到西海镇的首班客车。环青海湖路线及大事件：西海镇 —- 151基地 —- 黑马河（茶卡盐湖、黑马河日出） —- 刚察县 —- 西海镇 接下来便是我四天环青海湖骑行的行程，多图预警⚠️⚠️⚠️ 16号提前在网上买好了西宁到西海的车票，赶上七点半的班车，发往西海。大约十点钟就抵达了西海镇。终于，携带车子的负担结束了，终于，可以把车子组装起来了： 在开往西海的车上认识了一位也是独自一人来环青海湖骑行的齐子煜，在哈尔滨读书，开学大三，潍坊人，也算遇到老乡了，都是一人，所以就结伴骑行了，就这样，捡到了骑友。我装好了车子，他租好了车子，简单吃了个午饭，约十二点，出发了。坐标：西海，目标：西海！ 刚开始便是十五公里的上坡。然后在抵达湖东种羊场之前一直是大上坡大下坡的起伏路，既有日渐荒化的沙漠也有广阔无垠的草原： 过了湖东种羊场，一直到转上109国道之前的这段环湖东路，应该是环青海湖路程中最美的一段路了，怎么能不停下来多拍几张照： 然后的路程就是最苦逼的了，不知道是第一天刚开始的不适应，还是的确这段路比较难行，尤其是转上109国道之后，骑起来特别费力，这是一段特别辛苦的路程。但也不差有好的风景： 本来是打算骑到江西沟的，然后明天上午只需要骑行五十公里便可以抵达黑马河，但由于这段路的辛苦，速度太慢，而且体力不支，所以只能在151基地（二郎剑景区）附近住宿了。下午七点多，在距离151基地四公里处住了下来。骑友的租车老板介绍的宾馆 —- 牧民之家。一个人骑行，已经做好了住宿青旅的打算，然而现在是两人骑行，所以住宿当然也是选择略舒适的两人间。这几天的住宿都还不错，两人间，160，价格和环境都比预期的满意多了： 有意思的是，青海这边大部分只支持微信支付，极少支持支付宝。老板说：支付宝太麻烦，我们也不会用，微信收支付很方便。 今天骑了约七十公里！ 17号休息了一夜，一早七八点钟，吃过早饭再次赶路。所谓“骑行，最重要的是一个坚强的屁股”绝对是一句箴言！一踏上车子，坐上车座，我天，屁股炸裂，即使穿了骑行裤，感觉像垫了姨妈巾，依然没有什么卵用！ 在青海湖，最不缺的就是油菜花： 所谓油菜花，应该是与美女的连衣裙相配才是，而我也厚着脸皮以头盔加骑行装合了两张照片😂 今天，仍旧不轻松。前路漫漫，虽然坡不大，但遇上逆风，骑起来就艰难异常。骑行，最绝望的，就是望不到尽头的上坡。在很长的一段路途中，上坡加逆风会让你脑袋放空，鼻孔大口吸气，嘴巴负责呼气，两腿只需要机械的运动。你能听到的只有你粗重的喘息声，两手扶好车把，两腿只要卖力的蹬、蹬、蹬，直到征服这段上坡！ 接近黑马河的是一段约五到十公里的下坡，约下午一点半抵达黑马河。找了宾馆，放了车子，吃了午饭，和人拼车去茶卡盐湖。 橡皮山，海拔 3817米，大概是去茶卡盐湖路上的最高海拔点，司机师傅还停车让我们能拍了个照： 大约两个多小时抵达了茶卡盐湖，又是一波放照： 从茶卡盐湖出来，湿过的裤腿又干了，已经变的硬邦邦。。。 再回到黑马河已经是晚上十点，不知道是这边天黑得晚（将近九点）还是黑马河的旅游旺季，这个点了，所有的店还都开着门呢。黑马河，不像其他地方的旅游景点，这里的人像服务员、包车司机、宾馆老板都特别客气。服务员：要么是中学生大小带着诚挚的表情，要么是二十多岁带着亲和的笑容，让人心情愉悦，感叹这里民风淳朴。包车司机：不知道是汉语不够好还是心地太纯良，他也想多挣点钱，所以对去哪哪的包车价格支吾的报一个略高的价格，然而却是以一种轻易让人听得出来心思的语气表达，又极易被乘客的语言套路。。。乘客和司机都没有恶意，反而觉得这样的关系很轻松。宾馆老板娘：简直好的不要不要的，我需要洗衣盆，洗衣粉，衣架，热水，老板娘都很耐心给找来，更要命的是，第二天一大早我想冲包感冒冲剂，问老板娘有没有一次性纸杯，她说等一会，然后，然后，她就去超市买了一袋纸杯回来。没有的话她完全可以拒绝我啊，我们只是花了160住了个两人间。 今天骑了约八十公里！ 18号2017年7月18日的黑马河，日出时间是06:16:00。五点多钟起床匆匆洗漱，卸下行李，踏上单车，轻装上阵，骑往湖边等待日出。从镇上到湖边观日出的地点大约有五六公里，这段路早已人满为患，有开车的，骑行的，步行的，排满了整段路。还好，我们骑车的比较快，六点之前就赶到了湖边。虽然看日出的人很多，但是湖边的岸线很长，所以并不显得拥挤，大家都有看日出的位置。然后，就是等待日出： 看完日出，回去吃完午饭，当然是继续赶路，今天有一整天的时间，要赶到刚察县，一百二十公里！不过听司机师傅说接下来两天的路况还都不错，应该是比前两天轻松的。 征服过一个大上坡之后的路边休息： 骑行青海湖的小朋友： 遇见青藏铁路： 大概在下午七点钟的样子，终于赶到刚察，找到宾馆直接瘫在床上睡了两个小时才休息过来出门吃饭。只不过，青海的饭菜实在是吃不惯，还贵。在青海的这几天，感觉汉堡和士力架就是最合口的了，然而除了西海镇是没有汉堡的。 今天骑了约一百二十公里！ 19号今天还有九十公里的路程，路上还要翻越一座绝望坡，因为要赶上西海到西宁的末班车，五点半，而且要早点赶到才能买上车票，所以还是要加紧赶路。 今天的状态特别好，感觉可以一口气骑到西海着（要不是遇到绝望坡。。。）路过甘子河，状态依然，所以也没有停下来休息： 终于遇到绝望坡，这样看起来好像还好，不过实际上还是挺大的坡，而且特别长，忘记了骑了多长时间，好几次想停下了休息，总是想：骑上这个坡头就休息。然而骑过一个坡头又望见一个坡头，就这样最慢以 7-8km/h 的的速度登上了绝望坡，然后再没力气了，只能停下来休息，顺便等一下骑友吃个午饭。 休息了四五十分钟吃了碗泡面，继续赶路，听骑过的骑友讲还剩来两个小坡，随后二十公里全是下坡了，不蹬都能到 30km/h，赶路！ 终于，在下午三点半赶到了西海镇，买上了最后一班车的车票。环青海湖骑行，三百六十公里，完成了！ 每次骑行的时候都累到：骑完这次再不骑了。骑完之后又还想再计划一次骑行。 今天骑了约九十公里！ 再见青海因为休了一周的年假，所以时间还早，计划回济南同学聚一波。顺便爬一爬泰山，弥补一下在济南待了四年喊着要去爬泰山的遗憾。所谓“累成狗”应该是一种比较舒适的状态吧「二哈」在兰州中川机场飞济南遥墙，遇见西北地貌，再见青海！ 后记这里有一份.gpx文件 👉点击下载 ，记录了环青海湖的骑行轨迹，有兴趣的话可以下载下来看看。将它导入到支持 gpx 格式的软件里就可以了，我用的是「行者」，大家喜欢用什么软件可以自行 Google～ 转载请保留原文地址：http://gonghonglou.com/2017/07/29/qinghaihu-cycling]]></content>
      <categories>
        <category>Journey</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[一小时轻松实现科学上网]]></title>
    <url>%2F2017%2F07%2F10%2Fss-vps%2F</url>
    <content type="text"><![CDATA[自从科学上网这件事越来越成为一门口口相传的手艺的时候，就一直想要亲身实践下自建 VPS。Green VPN 突然发布了这则「相遇有时，后会无期」的公告，使我又失去了一个科学上网的工具，终于敦促我完成了这次体验。 我还能说什么，当然是选择原谅她。。。 以下是几种服务的对比： PPTP： – 优点：网上关于搭建 PPTP 服务的教程最多 – 缺点：可能是因为 PPTP 不够安全，所以苹果禁用了这种服务的连接。就是说 Mac OX 和 iOS 系统上是不能使用这种服务的。 L2TP、IKEv2、IPSec： – 优点：Mac OX 和 iOS 系统上可以使用 – 缺点：使用系统添加此类服务的 VPN 配置无法实现智能分流，也就是 Shadowsocks 里的「自动代理模式」（PPTP 同样存在这个缺点） Shadowsocks： – 优点：可以实现自动代理模式，实现国内国外线路智能分流。 – 缺点：必须下载 Shadowsocks 客户端来使用该服务 所以，为了自动代理，我选择了 Shadowsocks。简单来说就是在自己的服务器上搭建一个 Shadowsocks 服务，对外提供「IP 地址 + 端口号」和「密码」 实现的功能： 服务器开机自动启动 Shadowsocks 服务 可配置多个账号（即：多个端口号 + 密码） 实现自动代理模式 所以我们需要： 购买服务器（vps） 装载 Shadowsocks 服务 下载 iOS、Mac 客户端连接 vps 购买 VPS在 搬瓦工 购买一款适合你的主机，单纯搭建 Shadowsocks 服务的话「10G VPS」已经完全够用了，一年 19.9 美元，网上搜一个 6% 的优惠码，折合人民币大概 130 块一年。购买过程可以参考：新手用户搬瓦工VPS购买图文指导教程我买的是 KVM，关于 KVM 和 OpenVZ的区别可以参考：Linux VPS基本常识 - KVM与OpenVZ架构的区别 购买成功后，在这个地址点击 KiwiVM Control Panel 跳转至 KiwiVM 可管理你的主机然后就可以看到你主机的详细信息了，并且搬瓦工已经帮你装好了 Centos 系统： 装载 Shadowsocks 服务接下来，你有两种选择： 一键安装 – 优点：方便快捷 – 缺点：不能添加账号，不能随意更改密码（只能重新生成） 自己搭建 Shadowsocks 服务 – 优点：可以添加多个账号（任意增删端口号即可），可以修改密码 – 缺点：ssh 连接服务器，执行一系列命令行命令（不过，这对于想要捣鼓捣鼓服务器的人来说，比如我，这也算是优点） 一键安装如下图，点击 Intsall Shadowsocks Server 即可： 安装成功后如下图，会提供给我们：端口号、加密方式、密码，其中密码只能重新生成，不能更改。 下载 iOS、Mac 客户端连接 vps Mac 客户端：ShadowsocksX iOS 客户端：App Store 搜索「Wingy」或着「Shadowrocket」 windows 客户端：Shadowsocks Windows 如下图为 Shadowsocks Mac 客户端，填入服务器 IP 地址、上图中 Shadowsocks Server 端口号、加密方式、密码确定即可连接 VPS 的 Shadowsocks 服务，iOS 上的软件也是填写这些内容： 如此，便可以科学上网了，一键安装，就是这么简单～接下来是略微专业一点的做法，需要了解一些 Linux 命令。 自己搭建 Shadowsocks 服务接下来，该是此篇博客最有趣的内容了：操作 Linux 服务器，搭建 Shadowsocks 服务。 首先如果你使用了上一种方式一键安装了 Shadowsocks，那么，在采用这种方式搭建服务前应当卸载上一个 Shadowsocks 服务，上一张图片所在网页的最下方会有一键卸载：Unintsall Shadowsocks Server。如果不卸载该服务，会和接下来自己手动安装的 Shadowsocks 服务冲突。 保险起见，你可以选择从头来过：重装系统。这里又是开始～如下图选择一款操作系统来安装，墙裂建议选择 centos-7-x86_64-bbr，因为接下来安装 Shadowsocks 要依赖 python2.7 版本，而 Centos-6 默认安装的是 python2.6： 重装完成后，你会受到一封告知邮件，并且附有一份临时服务器登录密码。当然，你也可以点击上图中的 Root password modification 重新生成一份密码。注意：生成密码前需要先 stop 服务器。 连接服务器开启终端，使用 ssh 远程连接服务器：1ssh root@you_server_ip -p you_server_port you_server_ip：你的服务器 ip 地址，you_server_port：你的服务器端口号，回车输入 root 登录密码即可。如果你之前 ssh 登录过服务器，又重装之后再次登录可能会有以下问题： @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ WARNING: POSSIBLE DNS SPOOFING DETECTED! @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ 执行如下命令，将 known_hosts 文件里包含你服务器 ip 地址那一段删掉即可成功连接：1vim ~/.ssh/known_hosts 为方便之后 ssh 登录，可执行以下命令修改 root 密码：1passwd 回车输入新密码确认即可。 安装 Shadowsocks安装 setuptools 和 pip ，在终端执行以下命令：1yum install python-setuptools &amp;&amp; easy_install pip 安装 Python-Gevent，用于提高性能，在终端执行以下命令：123yum install libeventyum install python-develpip install gevent 安装 M2Crypto，用于加密的第三库，在终端执行以下命令：1234yum install openssl-develyum install swigyum install gccpip install M2Crypto 安装 Shadowsocks 服务端，在终端执行以下命令：1pip install shadowsocks 配置 Shadowsocks新建配置文件，在终端执行以下命令：1vi /etc/shadowsocks.json 编辑 shadowsocks.json 文件内容如下：12345678910111213&#123; "server":"you_server_ip", "local_address":"127.0.0.1", "local_port":1080, "port_password":&#123; "9000":"9000password", "9001":"9001password", "9002":"9002password" &#125;, "timeout":300, "method":"rc4-md5", "fast_open": false&#125; 解释一下： Name Explanation server 服务器 IP 地址 server_port 服务器端口号 local_address 本地代理地址 local_port 本地代理端口 port_password Shadowsocks 服务端口号及密码 timeout 超时断开，以秒为单位 method 加密方式，推荐使用 rc4-md5，比 aes-256-cfb 速度快很多 fast_open 是否使用TCP 后端开启与停止 Shadowsocks 服务，在终端执行以下命令：12ssserver -c /etc/shadowsocks.json -d startssserver -c /etc/shadowsocks.json -d stop 或者选择前端开启 Shadowsocks 服务，在终端执行以下命令：执行该命令当连接成功或出错时终端会打印详情信息，建议第一次开启 Shadowsocks 服务时执行该命令：1ssserver -c /etc/shadowsocks.json 至此，使用 Shadowsocks 客户端就可以科学上网了。 设置服务器开机启动设置开机启动，在终端执行以下命令：1vi /etc/rc.local 将以下开启 Shadowsocks 服务命令加入 rc.local 文件：1ssserver -c /etc/shadowsocks.json -d start 保存退出即可。执行命令 reboot 重启服务器试试看～ 至此，已经可以科学上网，秒开 Youtobe，1080无压力～ 给安装 Centos-6 的补充补充一：如果你装的系统是 Centos-6 那么执行 pip install ... 或许会有以下报错： DEPRECATION: Python 2.6 is no longer supported by the Python core team, please upgrade your Python. A future version of pip will drop support for Python 2.6 说明，你的 Python 版本是 2.6，终端执行命令 Python -V 查看 Python 版本。你可以执行以下命令简单升级 Python2.7123yum install centos-release-SCLyum install python27. /opt/rh/python27/enable 然后执行命令 Python -V 验证此时的 Python 版本，注意，此时不要更换操作目录，接下来的安装和启动 Shadowsocks 都需要在这个目录下完成，因为你的 Shadowsocks 就是用这个目录下的 Python2.7 安装的。设置开机自启动时， 也应该在 rc.local 文件里加入以下命令：12. /opt/rh/python27/enablessserver -c /etc/shadowsocks.json -d start 补充二：然而，当你第二次在 python2.6 环境下执行 pip install shadowsocks 也许会有如下提示： DEPRECATION: Python 2.6 is no longer supported by the Python core team, please upgrade your Python. A future version of pip will drop support for Python 2.6Requirement already stisfied:shadowsocks in /usr/lib/python2.6/site-packages 虽然有报错，但你的确已经在 python2.6 环境下安装好了 shadowsocks 服务，那么在任意目录下你都可以执行 ssserver -c /etc/shadowsocks.json 命令开启 shadowsocks 服务。 补充三：你当然可以自行 Google 完全升级 Python 的方法。 后记以上便是我搭建个人 VPS，实现科学上网的全过程，希望对大家有所帮助，欢迎吐槽～ 转载请保留原文地址：http://gonghonglou.com/2017/07/10/ss-vps Reference 安装SSserver和配置(二)]]></content>
      <categories>
        <category>Technology</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[UITableViewCell计算行高的几种方式]]></title>
    <url>%2F2017%2F07%2F05%2Fcell-height%2F</url>
    <content type="text"><![CDATA[当我还是小白时（比现在更白的时候）对于 UITableViewCell 的行高问题还是比较头疼的，当然这个算是 iOS 开发中相当基础的内容了，但是当时的我就想过，将 UITableViewCell 的行高问题解决了一定写一篇总结博客，所以就有了这篇博客。尽管拖了这。么。久。。。 iOS 的界面中，UITableView 应该是用的最多的控件之一了吧：微信列表、聊天记录、朋友圈、微博 time line。。。哪哪离不开 UITableView。而 UITableView 则是由 UITableViewCell 组成的，这些 cell 有的行高是固定的，大部分则需要根据内容反计算行高来展示。本篇博客则来介绍 UITableViewCell 计算行高的几种方式。 固定行高有相当一部分 UITableView 的行高是固定的，这种 cell 在代码书写和代码性能上相比而言就简单了许多，有以下两种方式设定行高： 统一设定1self.tableView.rowHeight = 44; // 系统自带的 cell 的行高大概就是 44 优点：这种方式最为简单。 缺点：相对的对 tableView 的可控性也最弱，它会将 tableView 所有的 cell 高度统一设置为 44。 通过代理设定通过实现 UITableViewDelegate 方法，同样可以控制 tableView 的行高。 123456789101112131415161718- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath &#123; // 1. // return 44; // 2. // if (tableView == self.tableView1) &#123; // return 44; // &#125; else &#123; // return 88; // &#125; // 3. if (indexPath.row == 1) &#123; return 44; &#125; else &#123; return 88; &#125;&#125; 优点：采用这种实现代理的方法可以对不同的 tableView 、tableView 中不同的 section、row，进行判断分别设置，可控性更强。 缺点：因为在每次展示 cell 时都会调用了一次该代理方法，所以较于第一种方法一些性能损耗。 这个缺点在苹果介绍 rowHeight 属性的文档里也有指明： There are performance implications to using tableView:heightForRowAtIndexPath: instead of rowHeight. Every time a table view is displayed, it calls tableView:heightForRowAtIndexPath: on the delegate for each of its rows, which can result in a significant performance problem with table views having a large number of rows (approximately 1000 or more). 所以，如果你的 tableView 的行高是统一的、固定的，那么最好采用第一种方法，直接设置 rowHeight。 不定行高固定行高的 tableView 已经算是小儿科了，但是也属于 UITableViewCell 行高的范畴，所以还是简单提了一下。那么，当 tableView 的行高不固定时，有以下几种计算方式。 估算行高其实，UITableView 的 rowHeight 可以设置为 UITableViewAutomaticDimension，顾名思义，cell 可以设置为自动计算行高。然而，仅仅将 rowHeight 设置为 UITableViewAutomaticDimension 对自计算行高是不起效的，这时候就需要另一个属性：estimatedRowHeight。 iOS8 苹果推出了 self-sizing 的概念。UITableView 在 iOS7 就增加了一个属性： estimatedRowHeight ，苹果是这样描述的： Providing a nonnegative estimate of the height of rows can improve the performance of loading the table view. If the table contains variable height rows, it might be expensive to calculate all their heights when the table loads. Using estimation allows you to defer some of the cost of geometry calculation from load time to scrolling time.When you create a self-sizing table view cell, you need to set this property and use constraints to define the cell’s size.The default value is 0, which means there is no estimate. 你可以使用这个属性来给 cell 估算行高，但是默认值为 0，不会进行估算。所以如果想开启估算行高的话，必须设置 estimatedRowHeight，如： 12self.tableView.estimatedRowHeight = 60;self.tableView.rowHeight = UITableViewAutomaticDimension; 将 estimatedRowHeight 设置为一个大概的估计行高值即可，没有严格的限制。比如你的 cell 高度大概在 50 到 100 之间，那么你可以将 estimatedRowHeight 设置为 75；rowHeight 的默认值为 UITableViewAutomaticDimension，所以第二行可以省略。 然后就是对你的 cell 进行布局设置，这里以 Masonry 为例（AutoLayout 的话，这个框架大家应该都在用吧？～）伪代码如下： 12345678910111213141516171819202122232425262728- (instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier &#123; self = [super initWithStyle:style reuseIdentifier:reuseIdentifier]; if (self) &#123; __weak __typeof(self)weakSelf = self; UILabel *label1 = [UILabel new]; [self.contentView addSubview:label1]; [label1 mas_makeConstraints:^(MASConstraintMaker *make) &#123; __strong __typeof(weakSelf)strongSelf = weakSelf; make.top.equalTo(strongSelf.contentView).with.offset(10); make.left.equalTo(strongSelf.contentView).with.offset(10); make.right.equalTo(strongSelf.contentView).with.offset(-10); make.height.mas_equalTo(22); // ① &#125;]; UILabel *label2 = [UILabel new]; [label2 setNumberOfLines:0]; [self.contentView addSubview:label2]; [label2 mas_makeConstraints:^(MASConstraintMaker *make) &#123; __strong __typeof(weakSelf)strongSelf = weakSelf; make.top.equalTo(label1.mas_bottom).with.offset(10); make.left.equalTo(label1); make.right.equalTo(label1); make.bottom.equalTo(strongSelf.contentView.mas_bottom).with.offset(-10); // ② &#125;]; &#125; return self;&#125; 注释①：该条约束可以注释掉，然后将 label1 设置为 [label1 setNumberOfLines:0]; 这样 label1 就可以根据内容自动计算高度。注释②：必须设置该条约束。为了确定 cell 的高度，最接近 cell bottom 的控件需要设置一个距离 cell bottom 的约束。 布局结果大概是这样的效果： 优点：代码书写简单，页面布局快捷。在 cell 的 initWithStyle: 方法里就已经新建各个控件并将位置设置好，并且不需要单独计算 cell 的高度。 缺点：效率低，稍微复杂些的页面就能感觉到 tableView 滑动时的掉帧。 代理计算行高首先来执行一波伪代码，用打印来观察各个代理方法的执行顺序： 1234567891011121314151617181920#pragma mark - UITableViewDataSource- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section &#123; NSLog(@"---方法 : numberOfRowsInSection: ---section : %ld", (long)section); return 10;&#125;- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; NSLog(@"---方法 : cellForRowAtIndexPath: ---row : %ld", (long)indexPath.row); UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@"cell"]; return cell;&#125;#pragma mark - UITableViewDelegate- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath &#123; NSLog(@"---方法 : heightForRowAtIndexPath: ---row : %ld", (long)indexPath.row); return cellHight;&#125; 控制台打印结果如下： ①：首先执行 numberOfRowsInSection: 方法，返回 cell 个数为 10。②：其次执行的就是 heightForRowAtIndexPath: 方法，如上图，此时执行该方法会将所有 cell 的高度全部返回。③④⑤：这时候就开始执行 cellForRowAtIndexPath: 方法，因为当前页面只能布局 3 条 cell，所以该方法会被执行三次。并且，执行一次 cellForRowAtIndexPath: 方法紧接着就会执行一次 heightForRowAtIndexPath: 方法返回 cell 高度。 因此，当我们从网络或者本地缓存中获取到所需数据（ array ）后，可以直接执行代码： 1[self.tableView reloadData]; 然后就会调用 cellForRowAtIndexPath: 方法和 heightForRowAtIndexPath: 方法。 cell 的 initWithStyle: 方法：123456789101112- (instancetype)initWithStyle:(UITableViewCellStyle)style reuseIdentifier:(NSString *)reuseIdentifier &#123; self = [super initWithStyle:style reuseIdentifier:reuseIdentifier]; if (self) &#123; UILabel *label1 = [UILabel new]; [self.contentView addSubview:label1]; UILabel *label2 = [UILabel new]; [label2 setNumberOfLines:0]; [self.contentView addSubview:label2]; &#125; return self;&#125; 我们可以在 cellForRowAtIndexPath: 方法进行 cell 布局，如： 123456789101112131415161718- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@"cell"]; if (!cell) &#123; cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:@"cell"]; &#125; // 内容 cell.label1.text = @"..."; cell.label2.text = @"..."; // 布局 CGFloat viewWidth = [UIScreen mainScreen].bounds.size.width; cell.label1.fream = CGRectMake(10, 10, viewWidth-20, 22); CGFloat label2Height = [text boundingRectWithSize:CGSizeMake(viewWidth-20, MAXFLOAT) options:NSStringDrawingUsesLineFragmentOrigin attributes:@&#123;NSFontAttributeName:font&#125; context:nil].size.height; cell.label2.fream = CGRectMake(10, 10, viewWidth-20, label2Height); return cell;&#125; 布局结果大概是这样的效果： 然后在 heightForRowAtIndexPath: 方法里根据 array 数据计算 cell 的高度，如：12345- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath &#123; CGFloat viewWidth = [UIScreen mainScreen].bounds.size.width; CGFloat label2Height = [text boundingRectWithSize:CGSizeMake(viewWidth-20, MAXFLOAT) options:NSStringDrawingUsesLineFragmentOrigin attributes:@&#123;NSFontAttributeName:font&#125; context:nil].size.height; return 10 + 22 + 10 + label2Height + 10;&#125; 优点：通过 feram 的方式能够提高布局效率 缺点：因为每次 cell 将要出现时都去执行一次 heightForRowAtIndexPath: 所以效率还是不够高，而且行高没有得到缓存，造成大量不必要的计算上的浪费。所以就有了下边这种方法。 提前计算行高这种方式是出自 MVVM 的产物，因为最近都在使用 MVVM 框架，所有的计算都放到了 viewModel 里，所以在 viewModel 从网络或者本地缓存拿到数据后接着就会处理，将原始数据处理封装成 cell 的 VO（view object） 类对象，该 VO 类里包含着 cell 所需要的展示内容和尺寸，如： 12345678910@interface TableViewCellVO : NSObject// 数据@property (nonatomic, copy) NSString *label1Text;@property (nonatomic, copy) NSString *label2Text;// 尺寸@property (nonatomic, assign) CGRect label1Fream;@property (nonatomic, assign) CGRect label2Fream;// 行高@property (nonatomic, assign) CGFloat cellHeight;@end 然后将处理好的 cellVOArray 传给 UITableView 的数据源和代理，在 cellForRowAtIndexPath: 方法直接赋值： 1234567891011121314- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath &#123; UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@"cell"]; if (!cell) &#123; cell = [[UITableViewCell alloc] initWithStyle:UITableViewCellStyleDefault reuseIdentifier:@"cell"]; &#125; TableViewCellVO *cellVO = cellVOArray[indexPath.row]; // 数据 cell.label1.text = cellVO.label1Text; cell.label2.text = cellVO.label2Text; // 布局 cell.label1.fream = cellVO.label1Fream; cell.label2.fream = cellVO.label2Fream; return cell;&#125; 在 heightForRowAtIndexPath: 方法里直接返回行高： 1234- (CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath *)indexPath &#123; TableViewCellVO *cellVO = cellVOArray[indexPath.row]; return cellVO.cellHeight&#125; 优点：行高与 cell 内的各控件尺寸都提前计算好，在执行 cellForRowAtIndexPath: 方法和 heightForRowAtIndexPath: 方法时比较快，且行高得到缓存，避免了冗余的计算。 缺点：在从网络或者本地缓存拿到数据之后，执行 [self.tableView reloadData]; 之前需要花费时间处理数据及计算 fream。这里需要谨慎处理数据，可以采用多线程等技术缩短数据处理的时间。 因为在数据处理上所花费的时间要远小于页面滚动时所消耗的时间。凡是涉及页面的操作都是相当耗费时间的，相比而言对于 cpu 在处理数据上的时间就可以忽略不计了，毕竟我们所要处理的数据都不会太大，如果数据过多的话可以做分次获取处理（下拉刷新操作），所以这里的缺点相对于上一种方法还是可以忍受的。 XIB 方式处理 UITableViewCell 的行高问题对于纯 Code 和 SB 方式的页面布局问题业界已经相爱相杀了很久，各有各的道理。我的观点是：哪种布局方式适合自己就好了，看个人喜好。相比于 SB 的“所见即所得”，快速布局等，我个人更喜欢纯 Code 的方式，对代码的可控性更强（亦不排除我个人是比较喜欢 Coding 的因素）。不过，如果你是偏好 SB 的布局方式，采用 XIB 方式处理 UITableViewCell，那么你可以看看sunnyxx 的 UITableView-FDTemplateLayoutCell（点击可查看GitHub）这种解决方案。而且，本文的前一部分也参考了 sunnyxx 的这篇博客 优化UITableViewCell高度计算的那些事 ，推荐阅读。 后记 小白出手，请多指教。如言有误，还望斧正！ 转载请保留原文地址：http://gonghonglou.com/2017/07/05/cell-height]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Say Bye 2016]]></title>
    <url>%2F2016%2F12%2F26%2Fsaybye2016%2F</url>
    <content type="text"><![CDATA[嘿，不觉间 2016 马上就要结束了，所以，这一年你都干了啥？ 2016 年，最大的变动就是毕了业，十六年的求学历程 结束了，然后，从一名学生变成了员工！ 怀念毕业了，才发现真的会怀念学生时代。 早晨拖着身子爬起来上课，然而课上少有听讲，就那样浪费着时间蚕食着生命，可那也是我的大学生活啊，不再有的挥霍时光。到学校食堂吃饭，乌泱泱的人群，打饭都要先占座，可以的，那也是我怀念的。每学期的宿舍聚餐、班级聚会、元旦晚会，终究会怀念身处群体中的日子，和身处公司不同。真心希望有一天会在社会团体中找到校园中的集体感，大概就像 Nicholas Tse 描述的 PO 那样的团体吧，如果是自己建立的就最完美了，Fighting ！做学生时没有发现，原来这个社会对于学生的照顾这么多，电话费、住宿费、食堂、车票、景区门票等等等等这些有形的和那些无形的对于「学生」这一称号，每每感受到这一点在小小怀念学生时代之外都会多少感概这个社会还是很美好的，嗯。毕业后每当看到朋友圈有人晒出学校照片都会特别感概真想回去看看，当初吃够了的商业街现在也是很怀念扬州炒饼和如意捞的火锅小料。 期待未知年后的大学聚会，我们校园一聚。 选择2016 年 1 月 11 日实习入职，马上我也要工作满一年了呢。当时找工作时收到了几份 offer ，最终选择了卓骥（现在的公司），也很幸运遇到了卓骥： 1、实习入职的第二天就开始负责写 iPad 项目重构版的网络请求库。2、实习结束回学校前的一个月开始接手整个 iPad 项目的重构版本。3、正式入职后花费了四个月的时间完成了 iPad 项目重构的大部分内容。4、紧接着接手了公司所有 iOS 业务（ iPad 和 iTouch 端）。5、之后很快将会进行 iTouch 项目的重构 这些都让我觉得：当初的选择没错。 成绩2016，应该是我技术道路的正式开端，因为这些，所以还不算荒废： 1、算上这篇，今年该是写了十二篇博客。不像那些大 V 的博客对于求学者有较高的技术学习和参考价值，迄今为止「与佳期的个人博客」的主要内容或者功能应该是给自己的技术总结吧。切身体会对于很多技术，代码实现和博客输出还是有很大差距的，开始写某项技术博客前以为对该项技术已经掌握了，开始后和结束后才发现自己 too young too simple ，每篇技术博客写下来都觉得获益匪浅能学到更多知识，即便这样我也深知还仅是皮毛而已。继续努力吧，希望以后自己的博客输出也能在技术深度上对别人有所帮助和影响。2、顺利完成毕业设计，还要感谢马根老师（我的学术指导老师）我的毕业设计也是做的 iOS 的一款跳蚤市场类软件。3、完成了公司 iPad 项目重构版的网络请求库的开发。熟悉了网络请求、数据解析和部分缓存操作。4、完成了公司 iPad 的重构项目，主要代码成绩就是这个了，花费了约四五个月的时间，大部分的技术成长也都在这里了，从控件使用、页面布局、业务实现到设计模式、工程架构。5、接手公司所有 iOS 业务（ iPad 和 iTouch 端）。主要成长了 Debug 的能力吧以及对公司业务的熟悉。6、上线了一款个人 App：RDER，一款轻量极简的 RSS 订阅软件。大概有七八千行代码，虽然软件简单但是一点一滴都是自己细心雕琢的，因为这款软件也了解了关于一款软件上线的所有流程，而且用到了 relam ，和 sqlite 有了比较。 以上，今年大概写了有近十万行代码。 幸运一直都觉得自己少有努力，更多是幸运。 大一大二浑浑噩噩度过了两年，大二末总觉得该做点什么，所以办了个兼职中心，起名「曙光」。希望更多和我一样在大学迷茫的同学们能够因此看到方向，至少生活不再荒诞。然而最终也没办成个样子，现在看来那种职业生活的确不是我喜欢的，所以没有成样子也是有原因的。可也正因为这个兼职中心才让我遇到了马根老师（还要多谢班主任盛莉老师的引荐），遇到了编程，遇到了 iOS ，遇到了自己真正喜欢的东西。 大三到大四有近一年的时间都待在马老师的实验室里，机电楼 C 228。这间实验并不是开放实验室，偶尔有班级过来做实验的时间我就会带电脑到图书馆，所以大部分时间实验室只有我一个人在，偶尔晚上马老师也在。早上八九点钟吃过早饭到实验室，然后午饭、晚饭，晚上大概十点半十一点回宿舍，就这样日复一日匆匆过了一年。没有无聊反而一直很充实。那时候打开浏览器真的就感觉“徜徉在（互联网的）知识的海洋里”，那是我上了十几年学第一次有“知识的海洋”的概念。经过物联网 -&gt; 计算机 -&gt; 前端 -&gt; iOS -&gt; Objective-C 这一层层，要学的知识仍然像“海洋”一样望不到头，每天都是鼓足干劲的学习这些编程技术，从最基础的编程基础开始，for 循环、页面布局、多线程、数据库、网络编程、设计模式、开源代码……每阶段都有学不完的技术。当然也不是一直热情高涨，最受打击的应该是在继续学习的路上，对于刚开始一块崭新技术的迷惑，比如多线程和数据库，刚开始接触的时候真的是一脸懵逼，切身体会在那种时候一份基础系统的学习资料有多重要，一份好的技术博客或者技术文档有多重要！ 总感觉自己是幸运的：幸运的在大学快结束的时候找到了自己喜欢的东西；幸运的来到上海在上海海事大学和上海大学秋季招聘会上拿到了几份 offer ；幸运的在这几份 offer 里遇见的现在的公司—卓骥，才有了上边的“这些都让我觉得：当初的选择没错。” 幸运的父母都在上海可以住在一起；幸运的和父母住在一起不必负担房租；幸运的和父母住在一起连生活费都省了。因为这接连的三个幸运才能把钱攒起来一分不剩的花在了自己任性花的地方。而且我一直觉得迈入社会的第一年是我们人生负担最小收入最低的一年，如果说是要轻奢生活不虑积蓄，那这一年应该是最合适的时间了，所以我做了一名合格的月光族，有（了）钱任性所以真的是一分不剩。。。 遗憾1、生活上，以往的宿舍聚餐。 离开学校的前一天晚上宿舍最后一次聚餐，我们拿着班里分得的班费找了一家烧烤狠搓了一顿，胡吃海喝侃天侃地。那天说了好多话，而以往的宿舍聚餐因为酒量原因和吃货基因大家很少喝酒只顾吃吃吃，这应该就是最遗憾的了。只有喝了酒大家才能推心置腹吧，所以那晚喝了很多酒，带着怀念和不舍，口口声声说着我们再聚再聚。曾经你让我不爽我让你不快的事如今都成了加深我们情义的助力。我们吹牛打屁的时候顿顿默默带了一波节奏，人高马大的他竟然落了几滴猫尿，我看到后立马大笑指着他：“卧槽，你竟然…” 然后突然哽咽，同样泪流不止。那天喝的很真心。 小插曲：第二天起床就吐了还带着块块“血色”，肠胃一直不好上次喝酒吐了一夜胆汁，这次竟然吐了血，吓坏了。可是毕业离校不想让室友们担心所以装作无事。此事过了个把月知乎上看到那个笑话才会回忆起，那晚喝过酒回宿舍好像顺便买了个西瓜。哈，哈哈哈哈…… 2、技术上，遇到编程的时间太晚。 在大三初开始接触编程，上学期一直在入门 Java ，因为是刚入门所以进度很慢。看了一学期的 Java 大概熟悉了编程语言基础，对于移动端有 iOS 和 Android 两大阵营，都想学可是显然时间来不及，所以选择了逼格略高且逼格高就是我所爱的 iOS 。即便如此，学习 iOS 的时间也只有大三下学期到大四上学期，15 年大约十月底十一月就开始找工作了。所以大学里学习 iOS 的时间太短，编程生涯开始的太晚。如果可以早一年甚至两年的话至少在毕业时对于应聘这件事会游刃有余的多吧。 计划有了大学技术起步晚的遗憾，现在怎么能不早点做打算。 年初的时候大概有了自己的第一个“五年计划”：两年上海，两年北京，2020 年的时候稳定于杭州。至于届时是买房买车平淡安稳的上班生活还是破釜沉舟不甘平庸的技术创业，就在下一个“五年计划”里决定吧，无论哪种，对这五年来说主要目的就是技术积累。然而在毕业的那段时间还是感觉又落入了类大学迷茫期的循环，接下来的五年除了积累技术还应该往什么方向思考。大学：除了学习学习还能干嘛？毕业：除了技术技术还能干嘛？在接下来的五年能否像大学末期幸运的找到兴趣职业那样也幸运的找到兴趣事业呢？而且既然有了上边的技术遗憾当然是想越早发现越早准备的好。 现在，马上就到年底了心里也大概有了底，虽然不够坚信但至少有了大致的方向。我们都很脆弱当然想尽量避免事业的打击，还好还有一段时间可以慢慢谋取，还好这一点在技术上是有优势的。16 年就要结束了，接下来就是 “1+2”，此处省略三年的时间…… 总要有一些更实际有生活的计划： 旅行：（或）1、三月份去趟黄山，2、五月份骑行青海湖，3、十月份去趟拉萨 读书：1、技术书籍，2、龙应台的书， 3、其他一些小说 技术：1、维护更新 RDER ，2、写一款第三方微博客户端，3、更新技术博客，4、写一款牛逼的工具类 App（如果来得及） 呼～工作量还真不小，时间真的蛮紧张，撸开袖子，干吧！ 相信天空和大海，对于你，全是未来！]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS应用程序语言本地化及应用内语言设置]]></title>
    <url>%2F2016%2F10%2F29%2Fset-language%2F</url>
    <content type="text"><![CDATA[Xcode 新建一个工程的默认语言是英文，所以你在 app 里粘贴复制都是显示的 copy paste，你可以通过在 info.plst 文件里选择 Localization native development region 来设置不同语言。 可是如果你想在软件内选择设置语言，为软件添加多语言选择功能就需要一番折腾了，倒也简单，只不过还是有几个坑的。以下是一篇详细介绍为软件配置多语言选项的博客，走起 ➜ ➜ ➜ 关于 NSBundle在开始正式文章之前你或许应当先搞明白 NSBundle 是什么东西。 Bundle 是一个目录，其中包含了在程序会使用到的资源，包含了如图像、声音、程序中需要用到的文件，甚至是编译好的代码等等。而在实现软件内配置语言的时候就是通过 Bundle 的路径去获取配置文件，根据这个配置文件取出对应的字体渲染到 view 上。 当然，配置程序语言只是 Bundle 的一种用途。还可以用 Bundle 去获取工程中 info.plist 的详细信息，比如：123456789101112131415// 获取版本号：Bundle Short VersionNSString *shortVersion = [[[NSBundle mainBundle] infoDictionary] objectForKey:@"CFBundleShortVersionString"];// 获取版本号：Bundle versionNSString *version = [[[NSBundle mainBundle] infoDictionary] objectForKey:@"CFBundleVersion"];// 获取应用标识：Bundle identifierNSString *bundleIdentifier = [[[NSBundle mainBundle] infoDictionary] objectForKey:@"CFBundleIdentifier"];// 获取应用名称：Bundle display nameNSString *bundleDisplayName = [[[NSBundle mainBundle] infoDictionary] objectForKey:@"CFBundleDisplayName"];// 获取Bundle nameNSString *bundleName = [[[NSBundle mainBundle] infoDictionary] objectForKey:@"CFBundleDisplayName"];// 获取 app 包路径NSString *path = [[NSBundle mainBundle] bundlePath];// 获取 app 资源目录路径NSString *resPath = [[NSBundle mainBundle] resourcePath];... 大概明白 NSBundle 是怎么回事了吧，接下来就正式开始应用程序语言本地化及应用内语言设置。 配置 Project添加语言如下图，点击 PROJECT -&gt; info -&gt; Localizations 这里默认只有 English 点击下方的加号可以添加你想要的语言，比如这里添加的中文 Chinese(Simplifid) 。 注意： zh-Hans 是简体中文， zh-Hant 是繁体中文。 新建 .strings 配置文件1、Command + N 新建 Strings File 文件，命令为 RDLocalizable ，会生成一份 RDLocalizable.strings 文件。 2、选中RDLocalizable.strings 文件，如下图操作，点击 Localize... 按钮，左侧弹框中选择语言。 3、之后右侧会如下图显示，勾选上你想要的语言即可（Base 无用） 4、当勾选两门语言后，会发现RDLocalizable.strings 文件可以展开并存在两个配置文件，一份英文，一份中文。分别在两个文件内输入对应的语言，比如在英文文件里输入：123"收录" = "Collection";"订阅" = "Subscription";"我的" = "Mine"; 中文文件里输入：123"收录" = "收录";"订阅" = "订阅";"我的" = "我的"; 前边对应 键(key) ，后边对各个语言的 值(value)。看后面的 使用方法 就会明白了。 至此，对工程的配置已经完成。接下来要做的就是获取软件语言、设置语言、监听语言改变。。。 创建多语言设置工具类因为该工具类比较简单，直接将代码贴出来吧，后面会介绍一些坑。因为是一个继承于 NSObject 的工具类，都是使用类方法实现功能，以便类名直接调用。 头文件.h12345678910111213141516171819202122232425262728293031323334353637383940//// RDLocalizableController.h// rder//// Created by gonghonglou on 2016/10/29.// Copyright © 2016年 gonghonglou. All rights reserved.//#import &lt;Foundation/Foundation.h&gt;#define RDLanguageKey @"userLanguage"#define RDCHINESE @"zh-Hans"#define RDENGLISH @"en"#define RDNotificationLanguageChanged @"rdLanguageChanged"#define RDLocalizedString(key) [[RDLocalizableController bundle] localizedStringForKey:(key) value:@"" table:@"RDLocalizable"]@interface RDLocalizableController : NSObject/** * 获取当前资源文件 */+ (NSBundle *)bundle;/** * 初始化语言文件 */+ (void)initUserLanguage;/** * 获取应用当前语言 */+ (NSString *)userLanguage;/** * 设置当前语言 */+ (void)setUserlanguage:(NSString *)language;@end 实现文件.m12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576//// RDLocalizableController.m// rder//// Created by gonghonglou on 2016/10/29.// Copyright © 2016年 gonghonglou. All rights reserved.//#import "RDLocalizableController.h"static RDLocalizableController *currentLanguage;@implementation RDLocalizableControllerstatic NSBundle *bundle = nil;// 获取当前资源文件+ (NSBundle *)bundle&#123; return bundle;&#125;// 初始化语言文件+ (void)initUserLanguage&#123; NSString *languageString = [[NSUserDefaults standardUserDefaults] valueForKey:RDLanguageKey]; if(languageString.length == 0)&#123; // 获取系统当前语言版本 NSArray *languagesArray = [[NSUserDefaults standardUserDefaults] objectForKey:@"AppleLanguages"]; languageString = languagesArray.firstObject; [[NSUserDefaults standardUserDefaults] setValue:languageString forKey:@"userLanguage"]; [[NSUserDefaults standardUserDefaults] synchronize]; &#125; // 避免缓存会出现 zh-Hans-CN 及其他语言的的情况 if ([[RDLocalizableController chinese] containsObject:languageString]) &#123; languageString = [[RDLocalizableController chinese] firstObject]; // 中文 &#125; else if ([[RDLocalizableController english] containsObject:languageString]) &#123; languageString = [[RDLocalizableController english] firstObject]; // 英文 &#125; else &#123; languageString = [[RDLocalizableController chinese] firstObject]; // 其他默认为中文 &#125; // 获取文件路径 NSString *path = [[NSBundle mainBundle] pathForResource:languageString ofType:@"lproj"]; // 生成bundle bundle = [NSBundle bundleWithPath:path];&#125;// 英文类型数组+ (NSArray *)english &#123; return @[@"en"];&#125;// 中文类型数组+ (NSArray *)chinese&#123; return @[@"zh-Hans", @"zh-Hant"];&#125;// 获取应用当前语言+ (NSString *)userLanguage &#123; NSString *languageString = [[NSUserDefaults standardUserDefaults] valueForKey:RDLanguageKey]; return languageString;&#125;// 设置当前语言+ (void)setUserlanguage:(NSString *)language &#123; if([[self userLanguage] isEqualToString:language]) return; // 改变bundle的值 NSString *path = [[NSBundle mainBundle] pathForResource:language ofType:@"lproj"]; bundle = [NSBundle bundleWithPath:path]; // 持久化 [[NSUserDefaults standardUserDefaults] setValue:language forKey:RDLanguageKey]; [[NSUserDefaults standardUserDefaults] synchronize]; [[NSNotificationCenter defaultCenter] postNotificationName:RDNotificationLanguageChanged object:currentLanguage];&#125;@end 使用方法： 1、在 AppDelegate 的 - (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions 方法里初始化该工具类，并监听通知：1234// 语言初始化[RDLocalizableController initUserLanguage];// 监控语言切换[[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(languageChange:) name:RDNotificationLanguageChanged object:nil]; 2、记得在 - (void)applicationWillTerminate:(UIApplication *)application方法里删除通知：1[[NSNotificationCenter defaultCenter] removeObserver:self name:RDNotificationLanguageChanged object:nil]; 3、实现通知方法：1234- (void)languageChange:(NSNotification *)note&#123; // 在该方法里实现重新初始化 rootViewController 的行为，并且所有带有文字的页面都要重新渲染 // 比如：[UIApplication sharedApplication].keyWindow.rootViewController = ...;&#125; 4、使用 RDLocalizedString(&lt;#key#&gt;)方法 给所有文字添加本地化语言方法：123label.text = RDLocalizedString(@"收录");[button setTitle:RDLocalizedString(@"订阅") forState:UIControlStateNormal];... 5、更改语言方法：12345// 设置中文[RDLocalizableController setUserlanguage:RDCHINESE];// 设置英文[RDLocalizableController setUserlanguage:RDENGLISH]; 至此，对于应用程序语言本地化及应用内语言设置的功能就已经可以实现了。接下来是对遇到的几个坑的说明。 多语言设置的「坑」关于更改语言后重新初始化页面语言更改后，要重新渲染view，所以应该在更改语言之后回到根目录。不仅页面需要初始化，如果页面数据在 viewModel 里，那么该 viewModel 也应当初始化，因为字体是 RDLocalizedString(&lt;#key#&gt;) 这个方法从 .strings 配置文件里取出来的，更改语言后必须重新取一次。 当然也不是一定要留在根目录，有几种页面友好的解决方案： 1、更改语言功能一般会放在「我的」页面 push 出来的某一级页面，可以初始化 rootViewController 并且将之前 push 出来的几级 viewController 手动添加到 mineViewController.navigationController.viewControllers 这个数组中。这样页面就不会产生太大的错落感。 2、在每一个页面写一个检测语言改变的通知的方法。当接受到通知后就将该页面重新布局一次以更改字体。 PS：在这个问题上，感觉支付宝比微信做的界面跳转友好的多。。。 关于本地化语言的宏定义 RDLocalizedString(&lt;#key#&gt;)系统自带的方法是：NSLocalizedString(&lt;#key#&gt;, &lt;#comment#&gt;)，这也是一份宏定义：12#define NSLocalizedString(key, comment) \ [NSBundle.mainBundle localizedStringForKey:(key) value:@"" table:nil] 能看到它调用的是 NSBundle.mainBundle ，而我们在更改语言的工具类里的 bundle 已经更改了。所以系统的 NSLocalizedString(&lt;#key#&gt;, &lt;#comment#&gt;) 已经失效，必须重写一份宏定义：1#define RDLocalizedString(key) [[RDLocalizableController bundle] localizedStringForKey:(key) value:@"" table:@"RDLocalizable"] 1、必须使用自己的类名来调用类方法 [RDLocalizableController bundle] 以获取自己的 bundle 2、table 后的参数为 .strings 文件的文件名，若你创建的文件名为 Localizable.strings ，则该参数可为 nil ，系统默认按 Localizable.strings 查找。否则必须配置文件名，且只是文件名，不加 .stringd 后缀。 关于初始化语言 [RDLocalizableController initUserLanguage]在 initUserLanguage 方法中有这样一段代码来做判断 1234567if ([[RDLocalizableController chinese] containsObject:languageString]) &#123; languageString = [[RDLocalizableController chinese] firstObject]; // 中文&#125; else if ([[RDLocalizableController english] containsObject:languageString]) &#123; languageString = [[RDLocalizableController english] firstObject]; // 英文&#125; else &#123; languageString = [[RDLocalizableController chinese] firstObject]; // 其他默认为中文&#125; 各位可能会对这个判断比较疑惑，在这之前已经有判断了：先获取用户设置的语言，有则使用用户设置的语言，没有则使用系统语言。 然而因为某些原因用户设置过的语言（如：zh-Hans）会在另一个相同工程运行之后将该语言更改为zh-Hans-CZ；或者用户将系统语言设置为日本语或其他语言。 出现以上情况时 RDLocalizedString(&lt;#key#&gt;) 这个方法从 .strings 配置文件里是去不到对应的字体，就会返回空。后果轻则页面一片空白了，重则直接 crash ，如：1NSArray *array = @[RDLocalizedString(@"收录"), RDLocalizedString(@"订阅"), RDLocalizedString(@"我的")]; // 数组不能存空 就想使用 NSLocalizedString(&lt;#key#&gt;, &lt;#comment#&gt;) 方法1、有一种极端情况，比如：软件需要配置多国语言，很多很多的那一种。。。在 .strings 文件里配置了许多国家的语言。然而在软件内部只提供中文、英文等某几种语言，其他语言根据系统语言自适应。不想在 initUserLanguage 方法里做一大堆的乱七八糟的判断。只要在 initUserLanguage 的判断方法 else 里使用系统语言：123&#125; else &#123; languageString = [[NSUserDefaults standardUserDefaults] objectForKey:@"AppleLanguages"][0]; // 其他默认为系统语言&#125; 2、另一种情况，比如：每次使用 RDLocalizedString(&lt;#key#&gt;) 方法都要做引用 #import &quot;RDLocalizableController.h&quot; 好麻烦。当然你可以把 #import &quot;RDLocalizableController.h&quot; 放到 .pch 文件里，哦，顺便提一下 .pch 文件会拖慢启动时间 3、还有一种情况，比如：就想使用 NSLocalizedString(&lt;#key#&gt;, &lt;#comment#&gt;) 方法，还可以解决以上两种情况 还是有方法使用 NSLocalizedString(&lt;#key#&gt;, &lt;#comment#&gt;) 的。使用 Category 为 NSBundle 类扩展一个设置语言的方法，并且使用 runtime 为 NSBundle 动态添加一个关于 bundle 的属性，重载 NSBundle.mainBundle 的 localizedStringForKey 方法。目的就是将更改的字体传给 NSLocalizedString(&lt;#key#&gt;, &lt;#comment#&gt;) 映射的 localizedStringForKey 方法返回的 bundle ，使得更改的字体应用到系统上。 好吧，show you the code:123456789101112131415161718192021222324252627282930313233#import "NSBundle+RDLanguage.h"#import &lt;objc/runtime.h&gt;static const NSString *RDBundleKey = @"RDLanguageKey";@interface BundleEx : NSBundle@end@implementation BundleEx- (NSString *)localizedStringForKey:(NSString *)key value:(NSString *)value table:(NSString *)tableName &#123; NSBundle *bundle = objc_getAssociatedObject(self, &amp;RDBundleKey); if (bundle) &#123; return [bundle localizedStringForKey:key value:value table:tableName]; &#125; else &#123; return [super localizedStringForKey:key value:value table:tableName]; &#125;&#125;@end@implementation NSBundle (RDLanguage)+ (void)setLanguage:(NSString *)language &#123; static dispatch_once_t onceToken; dispatch_once(&amp;onceToken, ^&#123; object_setClass([NSBundle mainBundle], [BundleEx class]); &#125;); id value = language ? [NSBundle bundleWithPath:[[NSBundle mainBundle] pathForResource:language ofType:@"lproj"]] : nil; objc_setAssociatedObject([NSBundle mainBundle], &amp;RDBundleKey, value, OBJC_ASSOCIATION_RETAIN_NONATOMIC);&#125;@end 以上代码是 NSBundle 的 Category。解释一下哈：1、objc_getAssociatedObject 和 objc_setAssociatedObject 是一对 getter、setter 方法，目的是为了给 NSBundle 类动态添加一个属性。2、object_setClass：在 BundleEx 里实现一个 localizedStringForKey 方法，然后将 BundleEx 这个类设置给 [NSBundle mainBundle] 。目的就是相当于重载 [NSBundle mainBundle] 的 localizedStringForKey 方法。 说明：runtime 的具体用法和原理，由于在下才疏学浅就不多做讲解了，免得误人子弟。关于更多 runtime 的知识可以学习 一缕殇流化隐半边冰霜 写的 神经病院Objective-C Runtime入院 系列文章。 再说本篇文章，该类别新增方法的使用：在 RDLocalizableController 类的 + (void)setUserlanguage:(NSString *)language 方法里，本地化存储语言之后，发送通知之前调用如下方法：1[NSBundle setLanguage:language]; 之后，关于 RDLocalizableController 类里边关于 bundle 的操作就可以舍弃了。 注意：使用这种方法要确保你的 .strings 的文件名为 Localizable.strings否则还是要重新设置宏定义：12#define NSLocalizedString(key, comment) \ [NSBundle.mainBundle localizedStringForKey:(key) value:@"" table:@“RDLocalizable”] 这样的话该宏定义会有一个警告，毕竟系统已经定义过了的，而且你还要到处重定义。。。又犯了上面第二种情况的尴尬。 到这里，该篇博客就结尾了，希望能帮助到各位一二祝大家生活愉快，勤勉Coding 后记 小白出手，请多指教。如言有误，还望斧正！ 转载请保留原文地址：http://gonghonglou.com/2016/10/29/set-language]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[技术博跑题之手把手教你制作iPhone铃声]]></title>
    <url>%2F2016%2F09%2F21%2Fmake-ringtone%2F</url>
    <content type="text"><![CDATA[有没有觉得手机来电撞铃太痛 有没有觉得闹钟太安静叫不醒 iPhone手机不能直接在音乐软件里设置铃声，但也提供了可以更换铃声的方法，需要用到 iTunes 软件，虽然麻烦，但好歹也可以更换铃声了 生命在于折腾 ～ 硬件 MacBook Pro 10.11.5 iPhone6s iOS9 软件 iTunes 12.3.3.17 网易云音乐 1.4.5 获取歌曲 1、打开网易云音乐（为什么是网易云音乐？喜欢、任性～）。搜索喜欢的歌曲，下载后，在 Finder 中显示，拷贝出来放到桌面（便于操作） 制作铃声 2、打开 iTunes 软件。点击 🎵 图标，选择播放列表（便于操作），将桌面上的 .mp3 格式的音乐拖到 iTunes 里 3、选中播放列表中的音乐文件，右键 –&gt; 显示简介 –&gt; 选项，设置自己喜欢的开始到结束的时间段（iPhone铃声最长设置为40秒），不要忘记前面打勾☑️ 确定之后播放试听一下是否满意。 4、如果满意呢，就选中播放列表中的音乐文件，右键 –&gt; 创建ACC版本，在播放列表下边会出现一个新文件 5、选中新文件，右键 –&gt; 在 Finder 中显示，这是一个 .m4a 格式的文件，将这个文件拷贝出来放到桌面（便于操作），更改后缀名为 .m4r - 6、将播放列表中生成的ACC版本文件删除 - 7、点击 ··· 符号，选中铃声，将桌面上的 .m4r文件拖到列表里 8、手机USB连接到电脑，iTunes 里会出现一个 📱 标志 - 9、点击 📱 标志，选中铃声，勾选你喜欢的铃声，点击 同步 即可(这里的同步会把制作的铃声同步到iPhone，也会把iPhone上的软件等等数据备份到iTunes里，所以第一次同步时会比较慢) 完成同步完成后在iPhone -&gt; 设置 -&gt; 声音 -&gt; 电话铃声 里看到了，另外闹钟铃声也可以使用。 ✌️✌️✌️]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS中关于二维码的识别与生成]]></title>
    <url>%2F2016%2F07%2F24%2FQRCode%2F</url>
    <content type="text"><![CDATA[提起二维码 QR Code 想必大家都不再陌生，“扫一扫加好友”、“扫一扫付款”等已是我们日常生活中司空见惯的情形。 以这篇博客来讲述在iOS中关于二维码的识别与生成，会尽可能周全的将二维码识别与生成相关的操作讲述清楚。 关于二维码生成的原理，感兴趣的话各位可以移驾 二维码的生成细节和原理 以做参考。 注：文中识别与生成二维码的方法同样适用于条形码。 先上几张二维码压压惊…… 识别二维码摄像头扫描二维码iOS7之后苹果推出系统原生API来支持通过扫描获取二维码的功能，较其它 ZBar、ZXing 等第三方库有明显的性能优势。 首先，你需要弄清楚要用到的以下对象分别起到什么作用： 1、 AVCaptureDevice：捕获数据的物理设备，如：摄像机、麦克风。 开关灯属性torchMode就是由它管理的。 2、 AVCaptureSession：会话，管理输入流、输出流之间的数据传递。 3、 AVCaptureDeviceInput：输入流，从物理设备获取数据。 4、 AVCaptureMetadataOutput：输出流，需要设置输出流代理及所在线程，由代理对象处理输出流数据。 需要说明的是： 需要将输出流添加到会话后，才能指定元数据类型，否则会报错。 将输出流设置在主线程中，其代理方法会执行一次。设置在其他线程的话，代理会执行多次且次数不可控制。 可以通过设置AVFoundation的rectOfInterest属性来设定扫描区域，该属性默认取值是CGRectMake(0, 0, 1, 1)即全屏扫描x、y、width、height的取值范围都是0～1，且原点在屏幕右上角，所以和我们正常理解的CGRect相比x和y对调，width和height对调。 如图： 5、 AVCaptureVideoPreviewLayerCALayer：预览图层，显示相机拍摄到的画面。正因为它是CALayer的子类，为了将它添加到屏幕上，我们需要额外添加一个UIView，在这个UIView的layer上添加AVCaptureVideoPreviewLayerCALayer，否则它会覆盖住所有的控件（除非你把所有的控件都在添加这个视图之后添加）。 AVCaptureSession 设置开始与结束扫描 12345// 开始会话[self.captureSession startRunning];// 停止会话[self.captureSession stopRunning];self.captureSession = nil; 获取AVCaptureDevice实例 初始化输入流 初始化输出流 3.1.设置代理及所在线程 3.2设置扫描区域 创建会话 4.1添加输入流 4.2添加输出流 *3.3指定元数据类型 创建预览图层 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 1.获取AVCaptureDevice实例self.captureDevice = [AVCaptureDevice defaultDeviceWithMediaType:AVMediaTypeVideo];// 2.初始化输入流NSError * error;AVCaptureDeviceInput *input = [AVCaptureDeviceInput deviceInputWithDevice:self.captureDevice error:&amp;error];if (!input) &#123; NSLog(@"%@", [error localizedDescription]); return;&#125;// 3.初始化输出流AVCaptureMetadataOutput *captureMetadataOutput = [AVCaptureMetadataOutput new];// 3.1设置代理及所在线程[captureMetadataOutput setMetadataObjectsDelegate:self queue:dispatch_get_main_queue()];// 3.2设置扫描区域[captureMetadataOutput setRectOfInterest:[self scanPlace]];// 4.创建会话self.captureSession = [AVCaptureSession new];// 4.1添加输入流[self.captureSession addInput:input];if ([self.captureSession canAddInput:input]) &#123; [self.captureSession addInput:input];&#125;// 4.2添加输出流if ([self.captureSession canAddOutput:captureMetadataOutput]) &#123; [self.captureSession addOutput:captureMetadataOutput];&#125;// 3.3指定元数据类型captureMetadataOutput.metadataObjectTypes = @[AVMetadataObjectTypeUPCECode, AVMetadataObjectTypeCode39Code, AVMetadataObjectTypeCode39Mod43Code, AVMetadataObjectTypeEAN13Code, AVMetadataObjectTypeEAN8Code, AVMetadataObjectTypeCode93Code, AVMetadataObjectTypeCode128Code, AVMetadataObjectTypePDF417Code, AVMetadataObjectTypeQRCode, // 二维码 AVMetadataObjectTypeAztecCode];// 5创建预览图层self.captureVideoPreviewLayer = [[AVCaptureVideoPreviewLayer alloc] initWithSession:self.captureSession];[self.captureVideoPreviewLayer setVideoGravity:AVLayerVideoGravityResizeAspectFill];[self.captureVideoPreviewLayer setFrame:self.scanView.layer.bounds];[self.scanView.layer addSublayer:self.captureVideoPreviewLayer]; AVCaptureMetadataOutput 的代理方法处理输出流，返回扫描结果 123456789101112#pragma mark - 代理方法处理输出流- (void)captureOutput:(AVCaptureOutput *)captureOutput didOutputMetadataObjects:(NSArray *)metadataObjects fromConnection:(AVCaptureConnection *)connection &#123; if (metadataObjects != nil &amp;&amp; [metadataObjects count] &gt; 0) &#123; AVMetadataMachineReadableCodeObject *metadataObj = [metadataObjects objectAtIndex:0]; NSString *result = metadataObj.stringValue; NSLog(@"result:%@", result); if ([[metadataObj type] isEqualToString:AVMetadataObjectTypeQRCode]) &#123; NSLog(@"二维码"); &#125; // ... [self closeScanQRCode]; &#125;&#125; 开灯 给开关灯按钮调用以下 AVCaptureDevice 方法，轻松实现开灯效果 123456789101112- (void)turnLight &#123; // 判断允许设置 if ([self.device hasTorch]) &#123; [self.device lockForConfiguration:nil]; if (self.device.torchMode == AVCaptureTorchModeOff) &#123; [self.device setTorchMode:AVCaptureTorchModeOn]; // 开灯 &#125; else if (self.device.torchMode == AVCaptureTorchModeOn) &#123; [self.device setTorchMode:AVCaptureTorchModeOff]; // 关灯 &#125; [self.device unlockForConfiguration]; &#125;&#125; 总结下来就是：AVCaptureSession管理从物理设备AVCaptureDevice那里获取的输入流AVCaptureDeviceInput数据通过输出流AVCaptureMetadataOutput显示到预览图层AVCaptureVideoPreviewLayerCALayer上并且由代理方法-(void)captureOutput:(AVCaptureOutput*)captureOutput didOutputMetadataObjects:(NSArray*)metadataObjects fromConnection:(AVCaptureConnection*)connection;处理捕获到的数据。 相册识别二维码 iOS8之后系统提供的识别二维码图片的方法相当简单 123456789// 读取二维码UIImage *sourceImage ＝ ...;CIContext *context = [CIContext contextWithOptions:nil];CIDetector *detector = [CIDetector detectorOfType:CIDetectorTypeQRCode context:context options:@&#123;CIDetectorAccuracy:CIDetectorAccuracyHigh&#125;];CIImage *image = [CIImage imageWithCGImage:sourceImage.CGImage];NSArray *array = [detector featuresInImage:image];CIQRCodeFeature *feature = [array firstObject];NSString *result = feature.messageString;NSLog(@"result:%@", result); UIImagePickerController 打开系统相册，选择图片识别： 1234567- (void)openPhotoLibrary &#123; UIImagePickerController *photoPicker = [UIImagePickerController new]; photoPicker.delegate = self; // 打开的相册类型 photoPicker.sourceType = UIImagePickerControllerSourceTypePhotoLibrary; [self presentViewController:photoPicker animated:YES completion:NULL];&#125; UIImagePickerController 的代理方法识别相册中选中的二维码： 1234567891011121314#pragma mark - UIImagePickerControllerDelegate- (void)imagePickerController:(UIImagePickerController *)picker didFinishPickingMediaWithInfo:(NSDictionary *)info &#123; [self dismissViewControllerAnimated:YES completion:^&#123; // 读取二维码 UIImage *sourceImage = [info objectForKey:UIImagePickerControllerOriginalImage]; CIContext *context = [CIContext contextWithOptions:nil]; CIDetector *detector = [CIDetector detectorOfType:CIDetectorTypeQRCode context:context options:@&#123;CIDetectorAccuracy:CIDetectorAccuracyHigh&#125;]; CIImage *image = [CIImage imageWithCGImage:sourceImage.CGImage]; NSArray *array = [detector featuresInImage:image]; CIQRCodeFeature *feature = [array firstObject]; NSString *result = feature.messageString; NSLog(@"result:%@", result); &#125;];&#125; 生成二维码 使用系统提供的CIFilter可以方便简单的生成二维码 生成二维码方法 12345678910111213141516- (UIImage *)generateQRCode:(NSString *)code width:(CGFloat)width height:(CGFloat)height &#123; CIImage *qrcodeImage; NSData *data = [code dataUsingEncoding:NSUTF8StringEncoding allowLossyConversion:false]; CIFilter *filter = [CIFilter filterWithName:@"CIQRCodeGenerator"]; [filter setValue:data forKey:@"inputMessage"]; [filter setValue:@"H" forKey:@"inputCorrectionLevel"]; qrcodeImage = [filter outputImage]; // 消除模糊 CGFloat scaleX = width / qrcodeImage.extent.size.width; // extent 返回图片的frame CGFloat scaleY = height / qrcodeImage.extent.size.height; CIImage *transformedImage = [qrcodeImage imageByApplyingTransform:CGAffineTransformScale(CGAffineTransformIdentity, scaleX, scaleY)]; return [UIImage imageWithCIImage:transformedImage];&#125; 使用 CIFilter 生成带背景色的二维码 12345678910111213141516171819202122- (UIImage *)gaveColor:(NSString *)code width:(CGFloat)width height:(CGFloat)height &#123; NSData *data = [code dataUsingEncoding:NSUTF8StringEncoding allowLossyConversion:false]; CIFilter *filter = [CIFilter filterWithName:@"CIQRCodeGenerator"]; [filter setValue:data forKey:@"inputMessage"]; [filter setValue:@"H" forKey:@"inputCorrectionLevel"]; //上色 CIFilter *colorFilter = [CIFilter filterWithName:@"CIFalseColor" keysAndValues: @"inputImage",filter.outputImage, @"inputColor0",[CIColor colorWithCGColor:[UIColor purpleColor].CGColor], // 前景色 @"inputColor1",[CIColor colorWithCGColor:[UIColor cyanColor].CGColor], // 背景色 nil]; CIImage *qrcodeImage = colorFilter.outputImage; // 消除模糊 CGFloat scaleX = width / qrcodeImage.extent.size.width; // extent 返回图片的frame CGFloat scaleY = height / qrcodeImage.extent.size.height; CIImage *transformedImage = [qrcodeImage imageByApplyingTransform:CGAffineTransformScale(CGAffineTransformIdentity, scaleX, scaleY)]; return [UIImage imageWithCIImage:transformedImage];&#125; 通过遍历图片的像素给二维码个性化上色 这里需要指出的是，如果你在下边方法中传入的 image 是通过 CIFilter 方法直接生成的，那么该方法是没法工作的。同理，下一节中保存图片时仍然不能用 CIFilter 方法直接生成的 image，而采用 CGContextRef 获取图片。（参见下一节：保存二维码） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051// 颜色变化void ProviderReleaseData (void *info, const void *data, size_t size) &#123; free((void *)data);&#125;- (UIImage *)imageBlackToTransparent:(UIImage *)image &#123; // 分配内存 const int imageWidth = image.size.width; const int imageHeight = image.size.height; size_t bytesPerRow = imageWidth * 4; uint32_t *rgbImageBuf = (uint32_t *)malloc(bytesPerRow * imageHeight); // 创建context CGColorSpaceRef colorSpace = CGColorSpaceCreateDeviceRGB(); CGContextRef context = CGBitmapContextCreate(rgbImageBuf, imageWidth, imageHeight, 8, bytesPerRow, colorSpace,kCGBitmapByteOrder32Little | kCGImageAlphaNoneSkipLast); CGContextDrawImage(context, CGRectMake(0, 0, imageWidth, imageHeight), image.CGImage); // 遍历像素 int pixelNum = imageWidth * imageHeight; uint32_t *pCurPtr = rgbImageBuf; for (int i = 0; i &lt; pixelNum; i++, pCurPtr++) &#123; if ((*pCurPtr &amp; 0xFFFFFF00) &lt; 0x99999900) &#123; // 改变下面的代码，将图片转成想要的颜色 uint8_t *ptr = (uint8_t *)pCurPtr; if (i&lt;pixelNum/2) &#123; ptr[3] = 1; //0~255 ptr[2] = 200; ptr[1] = 200; &#125; else &#123; ptr[3] = 200; //0~255 ptr[2] = 1; ptr[1] = 200; &#125; &#125; else &#123; // 白色 255,255,255 uint8_t *ptr = (uint8_t *)pCurPtr; ptr[0] = 0; &#125; &#125; // 将内存转成image CGDataProviderRef dataProvider = CGDataProviderCreateWithData(NULL, rgbImageBuf, bytesPerRow * imageHeight,ProviderReleaseData); CGImageRef imageRef = CGImageCreate(imageWidth, imageHeight, 8, 32, bytesPerRow, colorSpace,kCGImageAlphaLast | kCGBitmapByteOrder32Little, dataProvider, NULL, true, kCGRenderingIntentDefault); CGDataProviderRelease(dataProvider); UIImage *resultUIImage = [UIImage imageWithCGImage:imageRef]; // 释放 CGImageRelease(imageRef); CGContextRelease(context); CGColorSpaceRelease(colorSpace); return resultUIImage;&#125; 生成条码图片 123456789101112131415- (UIImage *)generateBarCode:(NSString *)code width:(CGFloat)width height:(CGFloat)height &#123; CIImage *barcodeImage; NSData *data = [code dataUsingEncoding:NSISOLatin1StringEncoding allowLossyConversion:false]; CIFilter *filter = [CIFilter filterWithName:@"CICode128BarcodeGenerator"]; [filter setValue:data forKey:@"inputMessage"]; barcodeImage = [filter outputImage]; // 消除模糊 CGFloat scaleX = width / barcodeImage.extent.size.width; // extent 返回图片的frame CGFloat scaleY = height / barcodeImage.extent.size.height; CIImage *transformedImage = [barcodeImage imageByApplyingTransform:CGAffineTransformScale(CGAffineTransformIdentity, scaleX, scaleY)]; return [UIImage imageWithCIImage:transformedImage];&#125; 保存二维码12345678910111213// 开启位图上下文UIGraphicsBeginImageContextWithOptions(self.imageView.bounds.size, NO, 0);// 获取绘图上下文CGContextRef context = UIGraphicsGetCurrentContext();// 将图片渲染的上下文中[self.imageView.layer renderInContext:context];// 获取上下文中的图片UIImage *image = UIGraphicsGetImageFromCurrentImageContext();// 关闭位图上下文UIGraphicsEndImageContext();// 保存图片UIImageWriteToSavedPhotosAlbum(image, self, @selector(image:didFinishSavingWithError:contextInfo:), nil); UIImageWriteToSavedPhotosAlbum 方法的指定回调，监测保存是否成功 123456789#pragma mark - 指定回调方法- (void)image:(UIImage *)image didFinishSavingWithError:(NSError *)error contextInfo:(void *)contextInfo &#123; NSString *string; if(!error)&#123; NSLog(@"save success"); &#125;else&#123; NSLog(@"save failed"); &#125; &#125; 看一哈效果图 ok，就这些吧。Demo地址：https://github.com/gonghonglou/QRCodeDemo 写到这里估计涉及了二维码操作的大部分内容，期望对诸君有所帮助。 祝大家敲码愉快！ 后记 小白出手，请多指教。如言有误，还望斧正！ 转载请保留原文地址：http://gonghonglou.com/2016/07/24/QRCode]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[丽江之行]]></title>
    <url>%2F2016%2F05%2F19%2Flijiang%2F</url>
    <content type="text"><![CDATA[本来就打算一场毕业旅行啊，只是因为没有找到小伙伴同行所以迟迟未定。某日夜，Yu小Rong同学突出奇想打工换宿邀游丽江。一拍而和！ 最初的想法是打工换宿二十天左右，然而丽江客栈招义工大都要女孩子啊。搞不懂看看客栈家门而已喽，身强力壮的小伙子就这么受歧视吗。。。 所以Yu小Rong同学顺利找到一家暖暖的客栈做义工，而我…放弃吗？NO！苦寻义工无果之后果断选择住宿青旅，也算穷游丽江啦！ 有意思的是在某团上订房间时某青旅有三种房间：混住房间、男生房间、女生房间，价格相同。不明白该青旅是报以什么样的想法加入了混住房间的呢（坏笑）当我把这件事告知Yu小Rong同学并得知我订的是男生房间而非混住房间时竟然吐槽我：注孤生！额，好像错过了什么，活该单身狗啊哈哈哈 12号－－出发丽江十点出门从浦东奔赴上海虹桥，十二点动车开往杭州，下午两点机场大巴从杭州东站开往萧山机场。六点四十起飞，时间还是挺充足的！ 萧山机场 三小时后三义机场和某个傻傻女孩 一翻奔波，安顿了Yu小Rong同学在客栈，然后赶到青旅已是十二点多。青旅虽说是六张床却是我一人住还是棒棒哒！可能现在是旅游淡季的缘故吧。 13号－－束河古镇今天是休闲的一天。而且感觉丽江是一个慢节奏的古镇，好多人来旅游度假，也有很多人来旅行休憩。相比上海的快节奏生活突然到这里还是有些稍稍不适应的，是那种没有从心底完全放松的感觉。不过好不容易来这一趟还是非常享受这里惬意、舒适、休闲的慢节奏生活的。想想有半月多的这种旅行生活还是蛮激动的😄 早晨起来才看清住的院子的真面目，不错哦。 上午就悠闲地待在小伙伴在的客栈里，大大的院子。 午饭后漫步于束河古镇的各条街道里，房屋大多都是木质的 好多手鼓店，而且都放着那首由 最美丽江手鼓女孩 火起来的欢快的《我的小宝贝》 回青旅休息的路上路过一家叫喜鹊的小酒吧，好像很热闹的样子，就到上边坐了一会。深夜，点一杯饮料听几首歌…… 14号－－拉市海在纳西族中，“拉”为荒坝，“市”为新。“拉市”意为新的荒坝。拉市海在当地人口中也称为老市海。上午十点半包车前往拉市海马场，这边真的有好多马场，会有很多游客来骑马。这里的马个头比较矮，不过据马夫讲这里的马脚力特别好，擅负重。 茶马古道上捕获软妹子一只，这么美好想上前搭讪呀😏 中午到拉市海海上会所吃过午饭后就开始划船了嘛。可惜今天阴天，不然就能看到拉市海清澈美丽的湖面上倒映着蔚蓝的天空和天空里洁白的棉花糖 仗桨天涯！ 美丽湖畔 15号－－雨一整天都在下雨，不知是因为还没适应丽江的慢节奏还是因为一个人的孤独，今天清晰的感觉到对这里 我没有归属感。美丽的丽江。 －: I’m sorry.－: For what?－:－: For this.You’re so beautiful,i can’t control myself. 16号－－丽江古城万幸今天没下雨，可以去古城逛一逛。来丽江已有几天了，今天才去古城玩了。尤其想去看看大冰的小屋。对于大冰，相比读者粉丝我想我更是《阳光快车道》的观众，那是儿时的记忆，每周六的精彩节目，陪伴大冰在《阳光快车道》里从外景主持人到节目扛把子😄 丽江古城 晚上回青旅路过没有名字的手鼓店，美美的老板娘 暖暖的土家族妹子。待了好长时间，手鼓没打几下倒是聊了好久，基本都是老板娘在讲：讲来丽江前做装修设计时的嗨翻生活；讲妈妈没有文采却有道理的生意之道；讲算是“前男友”的刻骨经历；讲快要结婚的男朋友的习性和她们之间相识经历生活小事还有老板娘爱吃醋的小性子。燕姐，一个有故事的手鼓老板娘，不由得让人感觉亲近。下文有照片哦～ 17号－－再游古城今天是个好天气，怎么舍得不出去。在丽江的这几天晴朗的天空就是最稀有美丽的风景。 专门到大冰的小屋里去坐了坐，一瓶风花雪月，一下午。小屋里都是来自五湖四海的朋友，而且大都是女孩子呢。驻唱歌手问大家想听什么歌，大家点了一圈，他只答：不会、没听过。他说不点歌的，只是那么随口问问233，想起什么唱什么。他想起了甜蜜蜜，大家鼓掌期待那首经典老歌，只是第二句便唱得小屋里的女孩们红透了脸，这个歌手好污😄大多都是流浪歌手的民谣之类的歌曲，也好多他自己的原创歌曲。 一把吉他弹起，旁边手鼓伴奏，轻声慢语，辽亢高歌。 丽江古城很大，昨天只逛了一部份而已。今天去的时候发现好多手鼓店里的女孩都贴别漂亮啊，所以忍不住挨个拍下照片，打算做一合辑，就叫 最美丽江手鼓女孩 18号－－束河鼓缘原本是打算在这里待二十天左右的，奈何天天下雨还特别冷，加之Yu小Rong同学男票不来了，所以打算提前回去喽。 因为好多地方没去，倒是剩下了许多费用，看到束河街道上好多手鼓店，买个手鼓玩玩也是极好的。其实已经在燕姐那看了好几天了，大概有了个相中的手鼓，在今天买定的。 漂亮的老板娘－－燕姐： 19号－－离开你时才爱上你今天就要滚回上海了，恰好就在今天才是来丽江这么多天天气最好的一天。 坐在机场大巴上，望着头顶上的广袤的蔚蓝的天空和那些大块大块的棉花糖简直美哭了远方的雪山美的心都要化了来丽江这么久从没像这一刻觉得丽江原来可以这么美。可惜了了手机并不能拍出那样的美景。 美丽的天空，美的都不舍得离开了。 当离开你时，才发现爱上了你。－－－－丽江。 最后附束河傍晚天空图一张 最后的最后分享阳光下的小花一组：(拍摄者：Yu小Rong) 后 记 : 未 经 允 许 请 勿 转 载 ! ! !]]></content>
      <categories>
        <category>Journey</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[记环崇明岛骑行]]></title>
    <url>%2F2016%2F05%2F10%2Fchongming-cycling%2F</url>
    <content type="text"><![CDATA[事件：环崇明岛骑行人物：博主、博主的小伙伴时间：五一小假地点：崇明岛正文：现在发是不有点晚了？ 闭嘴！ 列位权当是篇环崇明岛骑行的攻略来看也未尝不可。 博主的车子，算是一款入门级的山地车－－捷安特 ATX 850，油压碟刹还是蛮爽的😄 30号早上约八点半左右从浦东出发至石洞口码头，45km/2h。坐十一点的轮渡（每小时一航班）到崇明岛南门码头，拍了几张照吃过午饭大概有一点钟正式开始了环崇明岛的骑行。 直接上陈海公路，一条宽阔的省道。 不过骑起来并不舒服，因为路特别宽所以不挡风，骑行中稍微有些风都会明显感觉到阻力，且经常有上坡。大约一直在22km/h～25km/h之间的速度巡航。 其实陈海公路相当长一段距离都是不允许非机动车行驶的。当然可以选择团城公路来走，只不过团成公路车辆要多一些难免提不起速度来。 距离南门港大概有三四十公里的地方到了堡镇，休息了半个小时，再上车的时候。。。那个屁股。。。那个疼。。。。 所以说骑行最重要的是坚强的屁股啊！！！ 在这条路上出了个小状况，有一段路小伙伴在前面破风，我跟的比较近而且没有太关心前方路况，小伙伴的车子突然躲过一辆停在路边的三轮车时我没来得急反应一车撞翻过去。。。不过还好只是一些擦伤不算太严重🤕️ 只是膝盖的碰伤导致那个下午剩下的路程骑起来比较吃力。所以要告诫骑友们骑行中尽量保持精力集中，注意前方路况尤其是在有伙伴在前破风时。 五点钟左右抵达陈家镇，因为到的略早一点所以很快就找到了旅馆。提醒骑友们留宿的话尽量到镇中心、县中心且稍早一点找宾馆，节假日房源还是挺紧张的。 1号早晨八点左右吃过早饭赶往东滩湿地，路上又到三个同行的骑友，其中一个还是骑过川藏，环过海南岛的前辈呢。 十几公里的路程，从陈家镇半小时就能到东滩。拍了几张照： 小湖边的座驾 天空下的兄弟俩 最遗憾的便是我们绕了一大圈的路就为了去海边一看，结果到了海边大坝的地方却被野生自然保护区的门卫拦住了，距离海边不过几百米。。。大坝还挡住了我们远眺的视线。。。 继续环岛的路程，从东滩赶往北沿公路，剩下的便是一直沿着北沿公路骑直到陈海公路回南门港了。因为天气预报说2号早上有雨，所以我们决定直接骑到南门港留宿，1号一天便骑了140公里！ 北沿公路骑起来还是相当爽的，上午大概在25km/h～30km/h巡航，下午因为要赶到南门港加上北沿公路路况相当好所以一直在35km/h左右巡航，简直酸爽！ 不过当拐到陈海公路后因为逆风、上坡再加上已经连续骑了一百多公里，所以这段路就苦逼了。。。 这是我们环岛的轨迹： 环岛总路线：从南门港沿陈海公路一路向东南方向到陈家镇，住一晚第二天到都东滩狂了一圈，然后沿北沿公路向西北方向拐到陈海公路，再沿陈海公路到南门港。 2号早上坐十点半的轮渡回上海，再经约45km/2h的路程到家。 五一环崇明岛骑行，第一次远途骑行正式结束，感觉良好！ 后记什么，你说这当一篇攻略来看的话也太逊了？作为一名码农出身的骑行手，不能忍你！ 这里有一份.gpx文件 👉点击下载记录了环崇明岛的骑行轨迹，将它导入到支持 gpx 格式的软件里就可以了，我用的是「行者」，大家喜欢用什么软件可以自行 Google～ 转载请保留原文地址：http://gonghonglou.com/2016/05/10/chongming-cycling]]></content>
      <categories>
        <category>Journey</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mac上搭建Apache Tomcat ＋ MySQL]]></title>
    <url>%2F2016%2F04%2F01%2Fbuild-tomcat%2F</url>
    <content type="text"><![CDATA[因连接公司项目的测试服务器各种不便所以搭了个本地服务器Apache Tomcat，数据库用的MySQL。写下过程一来总结，二来分享，希望能帮到诸位一二，来介绍需要下载用到的工具吧。 Java环境点击下载：jdk-7u79-macosx-x64.dmg 下载之后一路点击安装即可 MySQL数据库点击下载：mysql-5.6.29-osx10.8-x86_64 下载之后同样一路点击安装即可，默认的安装路径为 /usr/local/mysql-5.6.29-osx10.8-x86_64 此时，在系统偏好设置的最下方如下图所示： 点击MySQL，然后点击 Start MySQL Server 开启数据库服务 /Users/user/Desktop/BuildTomcat:mysql.png 阿帕奇服务器点击下载：apache-tomcat-7.0.68.zip 下载解压后放到任一目录中，我选择的是MySQL的默认安装目录下 /usr/local/ 终端 cd 到阿帕奇服务器所在目录的 bin 目录下，执行如下命令： $ ./startup.sh // 开启服务器/Users/user/Desktop/mysql.png $ ./shutdown.sh // 关闭服务器 新下载的tomcat在启动时会报错： ./startup.sh: Permission denied 这是因为权限问题，执行如下命令即可解决： $ chmod u+x *.sh //表示对当前目录下的*.sh文件的所有者增加可执行权限 再次执行开启服务器命令即可。成功开启服务器后，浏览器打开 http://localhost:8080 出现如下界面表示开启成功： 如上图点击Manager App登录需要账号密码，点击取消会有解释。即打开/usr/local/apache-tomcat-7.0.68/conf目录下的tomcat-users.xml文件，在下方添加配置用户名密码如： &lt;role rolename=&quot;manager-gui&quot;/&gt; &lt;user username=&quot;tomcat_name&quot; password=&quot;tomcat_password&quot; roles=&quot;manager-gui&quot;/&gt; Sequel Pro点击下载mysql的图形化工具：sequel-pro-1.1.1.dmg 安装成功后打开，设置如下： Name随意，MySQL初始用户名为root 密码为空，因为初始并没有数据库所以Database也为空。 点击Connect进入后 1：左上角选择Add Database...，填入一个名字如troy，点击add 2：Sequel Pro菜单栏选择Database–&gt;User Accounts...,给 root 用户添加用户名密码，点击Apply 这样在下次登录时就要把Password和Database填上再连接 添加数据将自己的.sql文件用Sequel Pro打开并运行，这样在数据库中就有了数据 将自己的.war的jar包添加到/usr/local/apache-tomcat-7.0.68/webapps目录下，这样就有了执行程序 终端 cd 到阿帕奇服务器所在目录的 bin 目录下，开启服务器可执行如下任一命令： $ ./startup.sh // 单纯开启服务器 $ ./catalina.sh run // 开启服务器，控制台可打印服务器数据 到这里本地服务器就开启了 执行如下命令，查看服务器在局域网中的地址： $ ifconfig 这样你的手机等设备也可以连接到本地服务器了 总结一下 jdk-7u79-macosx-x64.dmg java环境 mysql-5.6.29-osx10.9-x86_64.dmg mysql数据库 apache-tomcat-7.0.68.zip 阿帕奇服务器 sequel-pro-1.1.1.dmg mysql的图形化工具 troy_2016-03-25.sql sql语句，放在 Sequel Pro中执行，生成数据） rest.war 运行程序，放在 apache-tomcat-7.0.68/webapps 目录下 开启服务器 愉快的玩耍 后记转载请保留原文地址：http://gonghonglou.com/2016/04/01/build-tomcat]]></content>
      <categories>
        <category>Technology</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[解决OS X 10.11之后CocoaPods的升级问题]]></title>
    <url>%2F2016%2F04%2F01%2Fupdate-pods-que%2F</url>
    <content type="text"><![CDATA[问题描述：OS X 10.11之后升级CocoaPods，执行命令： $ sudo gem update cocoapods // 更新至最新版 $ sudo gem update cocoapods --pre // 或者 更新至测试版 报如下错误： ERROR: While executing gem ... (Errno::EPERM) Operation not permitted - /usr/bin/pod 解决方案一：使用如下命令更新： $ sudo gem install -n /usr/local/bin cocoapods // 更新至最新版 $ sudo gem install -n /usr/local/bin cocoapods --pre // 或者 更新至预览版 这种解决方法最开始的sudo gem update cocoapods 和 sudo gem update cocoapods --pre升级命令是不能用的，若想一切恢复正常请尝试解决方案二。 解决方案二：推倒重来。。。安装Homebrew ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot; 安装Ruby： brew install ruby 升级CocoaPods，执行命令： $ sudo gem install cocoapods // 更新至最新版 $ sudo gem install cocoapods --pre // 或者 更新至测试版 此后，一切OK～ 后记 上一篇文章关于CocoaPods的详细介绍：iOS的库依赖管理工具CocoaPods 转载请保留原文地址：http://gonghonglou.com/2016/04/01/update-pods-que]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS的库依赖管理工具CocoaPods]]></title>
    <url>%2F2016%2F04%2F01%2FCocoaPods%2F</url>
    <content type="text"><![CDATA[工欲善其事，必先利其器！在iOS开发中 CocoaPods 作为库依赖管理工具就是一把利器。 有了CocoaPods你再也不需要手动将需要的第三方库拖进你的工程、添加第三方库所依赖的framework、设置如-fno-objc-arc等编译参数、手动管理这些库的更新，当某个第三方库有依赖其他的库还要继续拖、拖、拖…… 我们只需要将所需要的第三方库声明到一个名为Podfile文件中，然后执行Pod install命令就OK了，CocoaPods就会自动去下载我们所需要库，并为我的工程设置好相应的系统依赖和编译参数。 只能说，好用到哭～ 安装CocoaPodsCocoaPods依赖于Ruby环境，刚好Mac下自带Ruby，使用Ruby的gem命令即可安装CocoaPods。为防止因gem太老而引发问题，建议执行如下命令先更新gem： 1$ sudo gem update --system 执行如下命令安装CocoaPods： 1$ sudo gem install cocoapods 如果执行上述命令后没有反应，那是因为Ruby的软件源 https://rubygems.org 使用的是亚马逊的云服务而被墙了（GFW的伟大。。。）可以用淘宝的Ruby镜像来访问cocoapods，依次执行如下命令将官方的Ruby源替换成国内淘宝的源 12# $ gem sources --remove https://rubygems.org/# $ gem sources -a https://ruby.taobao.org/ 执行如下命令验证Ruby镜像的确是taobao的： 1# $ gem sources -l 出现如下文字才说明上面的命令是执行成功的： 123# *** CURRENT SOURCES ***## https://ruby.taobao.org/ 此时，再次执行gem命令安装CocoaPods： 12$ sudo gem install cocoapods$ pod setup 稍等片刻 即可安装成功。 注： pod setup 是Cocoapods将它的信息下载到 ~/.cocoapods/repos 目录下。即使在安装时不执行此命令，在初次执行 pod install 命令时，系统也会自动执行 pod setup ——10.27更新 以下————————————————ruby.taobao.org 停止更新了，使用 cocoapods 的同学，请更新到 ruby china 的源。更新方法：使用如下命令查看镜像源： 1$ gem sources -l 更改镜像源： 123$ gem sources --add https://gems.ruby-china.org/ --remove https://rubygems.org/or$ gem sources --add https://gems.ruby-china.org/ --remove https://ruby.taobao.org/ ——10.27更新 以上————————————————升级CocoaPods升级CocoaPods非常简单，使用Ruby的gem命令： 123$ sudo gem update cocoapods // 更新至最新版or$ sudo gem update cocoapods --pre // 更新至预览版 当然执行如下命令也可以更新： 123$ sudo gem install cocoapods // 更新至最新版or$ sudo gem install cocoapods --pre // 更新至预览版 注：OS X 10.11之后升级CocoaPods会有问题。解决方案参见下一篇博客：解决OS X 10.11之后CocoaPods的升级问题 降级CocoaPods有时我们需要降低CocoaPods版本来解决某些第三方库的兼容问题，例如RestKit不兼容CocoaPods的0.39.0版本，降级到0.38.2就OK了。 移除RubyGems中的Cocoapods程序包查看gems中本地程序包，执行如下命令：1$ gem list 输出如下： 123456789101112131415161718192021222324252627282930313233343536*** LOCAL GEMS ***activesupport (4.2.5.2) bigdecimal (1.2.8) claide (1.0.0.beta.1, 0.9.1) cocoapods (1.0.0.beta.4, 0.39.0) cocoapods-core (1.0.0.beta.4, 0.39.0) cocoapods-deintegrate (1.0.0.beta.1) cocoapods-downloader (1.0.0.beta.1, 0.9.3) cocoapods-plugins (1.0.0.beta.1, 0.4.2) cocoapods-search (1.0.0.beta.1, 0.1.0) cocoapods-stats (1.0.0.beta.3, 0.6.2) cocoapods-trunk (1.0.0.beta.2, 0.6.4) cocoapods-try (1.0.0.beta.2, 0.5.1) colored (1.2) did_you_mean (1.0.0) escape (0.0.4) fourflusher (0.3.0) fuzzy_match (2.0.4) i18n (0.7.0) io-console (0.4.5) json (1.8.3) minitest (5.8.3) molinillo (0.4.4) nap (1.1.0) net-telnet (0.1.1) netrc (0.7.8) power_assert (0.2.6) psych (2.0.17) rake (10.4.2) rdoc (4.2.1) rubygems-update (2.6.1) test-unit (3.1.5) thread_safe (0.3.5) tzinfo (1.2.2) xcodeproj (1.0.0.beta.3, 0.28.2) 其中包含的CocoaPods版本：1cocoapods (1.0.0.beta.4, 0.39.0) 移除指定版本cocoapods如1.0.0.beta.4，执行如下命令： 1$ sudo gem uninstall cocoapods -v 1.0.0.beta.4 成功删除则输出： 1Successfully uninstalled cocoapods-1.0.0.beta.4 还有一个0.39.0版本，移除程序包，执行如下命令： 1$ sudo gem uninstall cocoapods -v 0.39.0 当移除最后一个版本时，询问： 1234Remove executables: pod, sandbox-pod in addition to the gem? [Yn] 按下回车键删除pod。查看CocoaPods组件的安装目录，执行命令$ which pod所得目录下的pod文件随即删除。 安装指定版本的Cocoapods程序包安装指定版本的CocoaPods 如0.39.0，执行如下命令：1$ sudo gem install cocoapods -v 0.39.0 注：若不指定版本，即命令如sudo gem install cocoapods则默认安装最新版。 安装成功后，执行命令查看版本号： 1$ pod --version 输出： 10.39.0 使用CocoaPods搜索第三方库为判断某第三方库（如AFNetworking）是否支持CocoaPods，执行如下命令来搜索： 1$ pod search AFNetworking 若如下图所示，则可用CocoaPods管理AFNetworking 创建Podfile的文件CocoaPods就可以根据Podfile文件里的内容来帮你下载你所需要的库。点击前往CocoaPods官方对Podfile文件的介绍。终端cd到你的项目所在目录下，创建Podfile文件： 1$ vim Podfile 按下i键进入输入状态，在Podfile文件里输入以下文字：12345platform :ios, '8.0' target 'Your_App_Name' dopod 'AFNetworking', '~&gt; 3.0'end 按下esc键退出输入。然后保存退出，命令是:wq。你当然可以使用vim之外的编辑软件来编辑Podfile文件。 注：cocoapods-1.0.0.beta版本后规定Podfile文件必须如上所示格式（加上target） 当然，采用创建Podfile文件的另一种方式，终端cd到你的项目所在目录下执行命令 pod init 会自动生成格式，自己试一下你会喜欢的～ 终端cd到你的项目所在目录下执行如下命令来利用CocoPods下载第三方库： 1$ pod install 如下图所示则下载成功： 提示：[!] Please close any current Xcode sessions and use Your_App_Name.xcworkspace for this project from now on. 打开Your_App_Name.xcworkspace 工程之后会看到 Pods 文件，AFNetwoking已经成功导入项目了。 你或许应当点击前往CocoaPods官网查看对pod install vs. pod update的介绍。 注：当你 clone 别人的项目到本地后也需要终端cd到项目所在目录下执行命令 $ pod install 关于Podfile.lock的文件执行pod install之后，CocoaPods会生成一个名为Podfile.lock的文件。并锁定当前各依赖库的版本，之后如果多次执行pod install或者团队中的其它人check下来这份包含Podfile.lock文件的工程后再执行pod install命令时，获取下来的Pods依赖库的版本就和最开始用户获取到的版本一致。如果没有Podfile.lock文件，执行pod install命令会获取第三方库的最新版本，这就有可能造成同一个团队使用的依赖库版本不一致，这对团队协作的危害无疑是灾难性的！在这种情况下，如果团队想使用当前最新版本的依赖库，有两种方案可修改Podfile.lock的纪录： 更改Podfile中各依赖库的版本 执行pod update命令 鉴于Podfile.lock文件对团队协作如此重要，我们应该将它添加到版本控制里。 点击前往CocoaPods官网查看对Podfile.lock的介绍。 补充：有时执行pod update命令会特别慢，可以尝试使用如下命令： 1$ pod update --verbose --no-repo-update pod install命令同理：1$ pod install --verbose --no-repo-update 发布自己的开源框架到CocoaPods你需要如下图创建一个Framework来打造你自己的开源框架 在工程目录下添加一份开源协议文件，一般为“LICENSE”，在 github 上新建仓库时可以同时新建 README.md 文件及 LICENSE 文件。 在开始之前你应当使用邮箱账号注册 CocoaPods： 1$ pod trunk register my_name@example.com 'my_name' --description='macbook pro' 随后会收到一份验证邮件，点击链接进行验证，之后通过以下命令查看注册结果： 1$ pod trunk me 结果应为： 12345678- Name: my_name- Email: my_name@example.com- Since: August 28th, 05:45- Pods: - my_framework_name- Sessions: - August 28th, 05:45 - January 3rd, 2018 10:00. IP: 116.226.129.252 Description: macbook pro 加下来就是正式开始推送自己的框架到 CocoaPods，发布自己的开源框架到CocoaPods同样需要一个类似Podfile的文件来告诉CocoaPods我们开源库的名称、版本、作者、描述、地址、所需的framework、依赖库等，这个文件叫my_framework_name.podspec，开始创建这个文件 终端cd到工程目录下，执行如下命令： 1$ pod spec create my_framework_name 这样在你的工程目录下会生成一个my_framework_name.podspec文件，大概内容为（将对应名称修改为你自己的）： 12345678910111213141516171819Pod::Spec.new do |s| s.name = "DJLSplitCollectionView" s.summary = "It is my first framework." s.version = "0.0.1" s.license = &#123; :type =&gt; 'MIT', :file =&gt; 'LICENSE' &#125; s.author = &#123; "gonghonglou" =&gt; "gonghonglou@gmail.com" &#125; s.social_media_url = 'http://gonghonglou.com' s.homepage = "https://github.com/gonghonglou/DJLSplitCollectionView" s.platform = :ios, '8.0' s.ios.deployment_target = '8.0' s.source = &#123; :git =&gt; "https://github.com/gonghonglou/DJLSplitCollectionView.git", :tag =&gt; s.version.to_s &#125; s.requires_arc = true s.source_files = 'DJLSplitCollectionView/*.&#123;h,m&#125;' s.public_header_files = 'DJLSplitCollectionView/*.&#123;h&#125;' s.framework = "UIKit"end 然后执行如下命令 12$ git tag 0.0.1 // 给框架打上 tag$ git push origin --tags // 将 tag 推送到 github 检查 podspec 语法和项目是否正常编译，执行如下命令： 1$ pod spec lint my_framework_name.podspec 确保没有任何 error 和 warning ，然后推送 podspec 到 CocoaPods 的主仓库就可以了 1$ pod trunk push my_framework_name.podspec // 提交到 CocoaPods 中心仓库 成功后结果应该为： 1234567891011121314Updating spec repo `master`Validating podspec -&gt; DJLSplitCollectionView (0.0.1)Updating spec repo `master`-------------------------------------------------------------------------------- 🎉 Congrats 🚀 DJLSplitCollectionView (0.0.1) successfully published 📅 August 28th, 09:39 🌎 https://cocoapods.org/pods/DJLSplitCollectionView 👍 Tell your friends!-------------------------------------------------------------------------------- 如图： 大功告成，几秒或者几分钟后 pod search my_framework_name 搜索一下吧～如果搜不到的话，建议执行如下方法：12rm ~/Library/Caches/CocoaPods/search_index.jsonpod search my_framework_name 后记 小白出手，请多指教。如言有误，还望斧正！ 转载请保留原文地址：http://gonghonglou.com/2016/04/01/CocoaPods Reference Using CocoaPods CocoaPods安装和使用教程 用CocoaPods做iOS程序的依赖管理 如何打造一个让人愉快的框架]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[初识ReactiveCocoa]]></title>
    <url>%2F2016%2F03%2F17%2Fmeet-ReactiveCocoa%2F</url>
    <content type="text"><![CDATA[ReactiveCocoa 是一个Objective-C 框架，受 Functional Reactive Programming的启发。它提供了一系列用来组合和转换值流的API。 如果你早已熟悉了函数响应式编程或者知道ReactiveCocoa的基本前提，看看Documentation这个文件夹里的framework overview等文件更深一步来了解它是怎样在实践中工作的。 介绍ReactiveCocoa受functional reactive programming的启发。在那些能被替换和修改的地方，RAC提供信号(由RACSignal代表)来捕获当前和将来的值而不是使用可变的变量。 通过链接，组合，和反馈的信号，软件可以不需要写那些持续观察和更新value的代码。 例如，一个文本框能够根据它的改变被绑定到最后一次的值，而不是使用额外的代码每秒去监控时钟和更新文本框。这点跟KVO很像，不过是使用了block，而非-observeValueForKeyPath:ofObject:change:context: 信号也可以进行异步操作，就像futures and promises。这极大的简化了异步软件中网络连接的代码。 RAC的重大优势之一就是它提供信号(signal)这种方式来统一的处理所有异步的行为，包括代理方法、block 回调、target-action 机制、通知和KVO。 这里是简单的例子： 1234567// 当self.username改变时，打印新的名字到控制台//// RACObserve(self, username)创建一个新的RACSignal，当前self.username的值发生改变时，发送新值给newName// -subscribeNext: 当信号发送值时将触发block[RACObserve(self, username) subscribeNext:^(NSString *newName) &#123; NSLog(@"%@", newName);&#125;]; 与KVO 通知不同的是信号能够进行统一的链式操作： 12345678910// 只有当名字的开头为"j"时才打印//// -filter 只有当block返回YES时才会创建一个新的RACSignal发送一个新值[[RACObserve(self, username) filter:^(NSString *newName) &#123; return [newName hasPrefix:@"j"]; &#125;] subscribeNext:^(NSString *newName) &#123; NSLog(@"%@", newName); &#125;]; 信号也能被用来派生状态。在响应新值中RAC代替观察属性和设置其他的属性，能够在信号和运行周期内传达属性： 1234567891011// 当self.password 和 self.passwordConfirmation相同时创建一个单向的binding使得self.createEnabled为true//// RAC() 是一个宏指令使得binding看起来nicer// // +combineLatest:reduce: 建一个信号数组// 当任一个信号的最后一个值发生改变时触发这个block，返回一个新的RACSignal，将block返回的值作为values发送出去RAC(self, createEnabled) = [RACSignal combineLatest:@[ RACObserve(self, password), RACObserve(self, passwordConfirmation) ] reduce:^(NSString *password, NSString *passwordConfirm) &#123; return @([passwordConfirm isEqualToString:password]); &#125;]; 信号不仅是在KVO上，还能在建立在随着时间而改变的值流上。例如，它们可以代表按钮点击： 123456789// 当按钮被点击时打印信息//// RACCommand创建信号去表示UI行为。例如，每一个信号可以表示一个按钮的点击、与它相关联的附加工作//// -rac_command是封装的NSButton方法. 当按钮被点击时触发该命令self.button.rac_command = [[RACCommand alloc] initWithSignalBlock:^(id _) &#123; NSLog(@"button was pressed!"); return [RACSignal empty];&#125;]; 或者是异步网络操作： 123456789101112131415161718// 连接"Log in"按钮给网络登录//// 当登录命令执行时运行block，开始登录进度self.loginCommand = [[RACCommand alloc] initWithSignalBlock:^(id sender) &#123; // 假设当网络请求完成时 -logIn 方法返回一个信号发送一个value return [client logIn];&#125;];// -executionSignals 每次执行该命令时，这个方法返回一个信号，包括以前的block返回的信号[self.loginCommand.executionSignals subscribeNext:^(RACSignal *loginSignal) &#123; // 成功登录时打印信息 [loginSignal subscribeCompleted:^&#123; NSLog(@"Logged in successfully!"); &#125;];&#125;];// 按钮被点击时执行登录命令self.loginButton.rac_command = self.loginCommand; 信号也可以代表定时器，其他的UI事件，或者别的什么随时间而改变的事件。 在异步操作方面，通过链接和转换信号可以建立更复杂的行为。在一组完整的操作之后更简单的来执行工作： 12345678910// 执行2个网络操作，当它们都完成时打印信息到控制台//// +merge: 当数组里的所有信号完成时，返回一个新的RACSignal//// -subscribeCompleted: 当信号完成时将执行这个block[[RACSignal merge:@[ [client fetchUserRepos], [client fetchOrgRepos] ]] subscribeCompleted:^&#123; NSLog(@"They're both done!"); &#125;]; 信号可以被链接到顺序执行异步操作，而不是使用一堆block回调。通常这样简单的来使用futures and promises： 123456789101112131415161718192021// 用户登录，下载缓存信息，获取服务器信息。都完成后将信息打印到控制台//// 假设登录之后 -logInUser 方法返回一个信号//// -flattenMap: 当信号发送一个value时触发这个block// 并且返回一个新的RACSignal来整合从block返回的所有的信号到一个单一信号中[[[[client logInUser] flattenMap:^(User *user) &#123; // 下载缓存信息，给用户返回一个信号 return [client loadCachedMessagesForUser:user]; &#125;] flattenMap:^(NSArray *messages) &#123; // Return a signal that fetches any remaining messages. return [client fetchMessagesAfterMessage:messages.lastObject]; &#125;] subscribeNext:^(NSArray *newMessages) &#123; NSLog(@"New messages: %@", newMessages); &#125; completed:^&#123; NSLog(@"Fetched all messages."); &#125;]; RAC甚至可以简单的建立在一个异步操作的结果上： 1234567891011121314151617// 创建一个单向的binding，让 self.imageView.image 来放置下载下来的user的头像//// 假设 -fetchUserWithUsername: 方法返回一个信号发送给user//// -deliverOn: 创建新的信号在其他的队列中进行他们的工作// 在这个例子中，此方法被用来将工作转移到后台队列和回到主线程//// -map: 每个user调用这个block，获取并且返回一个新的RACSignal，并且将从block返回的值发送出去RAC(self.imageView, image) = [[[[client fetchUserWithUsername:@"joshaber"] deliverOn:[RACScheduler scheduler]] map:^(User *user) &#123; // 下载头像 (在后台队列中进行). return [[NSImage alloc] initWithContentsOfURL:user.avatarURL]; &#125;] // 此时这个任务将在主线程中执行 deliverOn:RACScheduler.mainThreadScheduler]; 这是一些使用RAC的示范操作，但是它并不能说明RAC为什么如此强大。更多示例代码参见C-41 或 GroceryList,这些是使用ReactiveCocoa编写的iOS APP。在这个文件夹Documentation中可以查到更多的关于RAC的信息。 使用ReactiveCocoa乍一看ReactiveCocoa是非常抽象的，很难理解该怎样将它应用到具体的问题上。 这有一些示例来展示RAC的优势 处理异步或事件驱动的数据源许多Cocoa编程的重点是对用户事件的反应或应用状态的变化。处理这些事件的代码很快变得非常复杂的就像意大利面一样，伴随着许多回调函数和状态变量处理顺序的问题。 表面上看起来模式不同，比如UI回调，网络响应和KVO通知，实际上有很多共同之处。RACSignal统一了所有的这些不同的API，使他们可以组合在一起，并以同样的方式操纵。 例如这样的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546static void *ObservationContext = &amp;ObservationContext;- (void)viewDidLoad &#123; [super viewDidLoad]; [LoginManager.sharedManager addObserver:self forKeyPath:@"loggingIn" options:NSKeyValueObservingOptionInitial context:&amp;ObservationContext]; [NSNotificationCenter.defaultCenter addObserver:self selector:@selector(loggedOut:) name:UserDidLogOutNotification object:LoginManager.sharedManager]; [self.usernameTextField addTarget:self action:@selector(updateLogInButton) forControlEvents:UIControlEventEditingChanged]; [self.passwordTextField addTarget:self action:@selector(updateLogInButton) forControlEvents:UIControlEventEditingChanged]; [self.logInButton addTarget:self action:@selector(logInPressed:) forControlEvents:UIControlEventTouchUpInside];&#125;- (void)dealloc &#123; [LoginManager.sharedManager removeObserver:self forKeyPath:@"loggingIn" context:ObservationContext]; [NSNotificationCenter.defaultCenter removeObserver:self];&#125;- (void)updateLogInButton &#123; BOOL textFieldsNonEmpty = self.usernameTextField.text.length &gt; 0 &amp;&amp; self.passwordTextField.text.length &gt; 0; BOOL readyToLogIn = !LoginManager.sharedManager.isLoggingIn &amp;&amp; !self.loggedIn; self.logInButton.enabled = textFieldsNonEmpty &amp;&amp; readyToLogIn;&#125;- (IBAction)logInPressed:(UIButton *)sender &#123; [[LoginManager sharedManager] logInWithUsername:self.usernameTextField.text password:self.passwordTextField.text success:^&#123; self.loggedIn = YES; &#125; failure:^(NSError *error) &#123; [self presentError:error]; &#125;];&#125;- (void)loggedOut:(NSNotification *)notification &#123; self.loggedIn = NO;&#125;- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context &#123; if (context == ObservationContext) &#123; [self updateLogInButton]; &#125; else &#123; [super observeValueForKeyPath:keyPath ofObject:object change:change context:context]; &#125;&#125; … 可以用RAC这样的表示： 1234567891011121314151617181920212223242526272829303132333435- (void)viewDidLoad &#123; [super viewDidLoad]; @weakify(self); RAC(self.logInButton, enabled) = [RACSignal combineLatest:@[ self.usernameTextField.rac_textSignal, self.passwordTextField.rac_textSignal, RACObserve(LoginManager.sharedManager, loggingIn), RACObserve(self, loggedIn) ] reduce:^(NSString *username, NSString *password, NSNumber *loggingIn, NSNumber *loggedIn) &#123; return @(username.length &gt; 0 &amp;&amp; password.length &gt; 0 &amp;&amp; !loggingIn.boolValue &amp;&amp; !loggedIn.boolValue); &#125;]; [[self.logInButton rac_signalForControlEvents:UIControlEventTouchUpInside] subscribeNext:^(UIButton *sender) &#123; @strongify(self); RACSignal *loginSignal = [LoginManager.sharedManager logInWithUsername:self.usernameTextField.text password:self.passwordTextField.text]; [loginSignal subscribeError:^(NSError *error) &#123; @strongify(self); [self presentError:error]; &#125; completed:^&#123; @strongify(self); self.loggedIn = YES; &#125;]; &#125;]; RAC(self, loggedIn) = [[NSNotificationCenter.defaultCenter rac_addObserverForName:UserDidLogOutNotification object:nil] mapReplace:@NO];&#125; 链接依赖操作依赖在网络请求中是常见的，在下一个请求建立之前，需要完成当前对服务器的请求，比如： 12345678910111213[client logInWithSuccess:^&#123; [client loadCachedMessagesWithSuccess:^(NSArray *messages) &#123; [client fetchMessagesAfterMessage:messages.lastObject success:^(NSArray *nextMessages) &#123; NSLog(@"Fetched all messages."); &#125; failure:^(NSError *error) &#123; [self presentError:error]; &#125;]; &#125; failure:^(NSError *error) &#123; [self presentError:error]; &#125;];&#125; failure:^(NSError *error) &#123; [self presentError:error];&#125;]; 在ReactiveCocoa中可以这样简单的实现： 123456789101112[[[[client logIn] then:^&#123; return [client loadCachedMessages]; &#125;] flattenMap:^(NSArray *messages) &#123; return [client fetchMessagesAfterMessage:messages.lastObject]; &#125;] subscribeError:^(NSError *error) &#123; [self presentError:error]; &#125; completed:^&#123; NSLog(@"Fetched all messages."); &#125;]; 并行独立工作与独立的数据集合并行工作，然后将它们合并成一个non-trivial函数到Cocoa，并经常涉及大量的同步： 123456789101112131415161718192021222324252627__block NSArray *databaseObjects;__block NSArray *fileContents; NSOperationQueue *backgroundQueue = [[NSOperationQueue alloc] init];NSBlockOperation *databaseOperation = [NSBlockOperation blockOperationWithBlock:^&#123; databaseObjects = [databaseClient fetchObjectsMatchingPredicate:predicate];&#125;];NSBlockOperation *filesOperation = [NSBlockOperation blockOperationWithBlock:^&#123; NSMutableArray *filesInProgress = [NSMutableArray array]; for (NSString *path in files) &#123; [filesInProgress addObject:[NSData dataWithContentsOfFile:path]]; &#125; fileContents = [filesInProgress copy];&#125;]; NSBlockOperation *finishOperation = [NSBlockOperation blockOperationWithBlock:^&#123; [self finishProcessingDatabaseObjects:databaseObjects fileContents:fileContents]; NSLog(@"Done processing");&#125;]; [finishOperation addDependency:databaseOperation];[finishOperation addDependency:filesOperation];[backgroundQueue addOperation:databaseOperation];[backgroundQueue addOperation:filesOperation];[backgroundQueue addOperation:finishOperation]; 上面的代码可以用简单的合成信号来清理和优化： 1234567891011121314151617181920212223RACSignal *databaseSignal = [[databaseClient fetchObjectsMatchingPredicate:predicate] subscribeOn:[RACScheduler scheduler]];RACSignal *fileSignal = [RACSignal startEagerlyWithScheduler:[RACScheduler scheduler] block:^(id&lt;RACSubscriber&gt; subscriber) &#123; NSMutableArray *filesInProgress = [NSMutableArray array]; for (NSString *path in files) &#123; [filesInProgress addObject:[NSData dataWithContentsOfFile:path]]; &#125; [subscriber sendNext:[filesInProgress copy]]; [subscriber sendCompleted];&#125;];[[RACSignal combineLatest:@[ databaseSignal, fileSignal ] reduce:^ id (NSArray *databaseObjects, NSArray *fileContents) &#123; [self finishProcessingDatabaseObjects:databaseObjects fileContents:fileContents]; return nil; &#125;] subscribeCompleted:^&#123; NSLog(@"Done processing"); &#125;]; 简化collection转换高阶函数比如 map, filter, fold/reduce在Foundation中是非常缺少的，导致循环中的代码像这样： 123456789NSMutableArray *results = [NSMutableArray array];for (NSString *str in strings) &#123; if (str.length &lt; 2) &#123; continue; &#125; NSString *newString = [str stringByAppendingString:@"foobar"]; [results addObject:newString];&#125; RACSequence允许所有Cocoa collection在统一的和声明的方式下被操作： 1234567RACSequence *results = [[strings.rac_sequence filter:^ BOOL (NSString *str) &#123; return str.length &gt;= 2; &#125;] map:^(NSString *str) &#123; return [str stringByAppendingString:@"foobar"]; &#125;]; 后记 以上文章摘译自ReactiveCocoa的Objective-C官方文档ReactiveCocoa Documentation 以上内容介绍了RAC的基本用法，仅限于使用，所以墙裂建议仔细学习下节的参考链接，了解RAC原理及高阶用法。 小白出手，请多指教。如言有误，还望斧正！ 转载请保留原文地址：http://gonghonglou.com/2016/03/17/meet-ReactiveCocoa Reference ReactiveCocoa的Objective-C官方文档ReactiveCocoa Documentation 雷纯锋的ReactiveCocoa v2.5 源码解析之架构总览 吖了个峥的最快让你上手ReactiveCocoa之基础篇 和 最快让你上手ReactiveCocoa之进阶篇 李忠的ReactiveCocoa与Functional Reactive Programming 唐巧的ReactiveCocoa 讨论会]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[iOS开发tips之日期与星期的对应]]></title>
    <url>%2F2016%2F03%2F03%2Fdate-week%2F</url>
    <content type="text"><![CDATA[前言前段时间练手模拟校园app写了个Demo，其中在写课程表的界面时，加上了当前日期，为了让日期与星期对应也是前后折腾了好几次，主要还是对日期的情况思考的不够全面吧（比如判断每月天数和月初月末的交替），不过最终还是完成需求。最后意外发现简便方法，写下来分享。 对校园app的Demo有兴趣的话，请移驾GitHub: QLU-BlogDemo 正文首先看一下模样吧（如图中红框所示）最基本的：获取当前日期的方法 12345678910111213141516171819// 获取当前时间NSDate *senddate = [NSDate date];NSDateFormatter *dateformatter = [[NSDateFormatter alloc] init];[dateformatter setDateFormat:@"yyy"];NSString *yearString = [dateformatter stringFromDate:senddate];[dateformatter setDateFormat:@"MM"];NSString *monthString = [dateformatter stringFromDate:senddate];[dateformatter setDateFormat:@"dd"];NSString *dayString = [dateformatter stringFromDate:senddate];[dateformatter setDateFormat:@"EEE"]; NSString *weekString = [dateformatter stringFromDate:senddate];NSLog(@"-%@",weekString);int year = [yearString intValue];NSLog(@"-%d", year);int month = [monthString intValue];NSLog(@"--%d", month);int day = [dayString intValue];NSLog(@"---%d", day); 看打印结果：然后就是把获取到的日期放到对应星期上去了,需要格外注意的要判断的几点： 不同月的天数 月底时，显示下个月月初的日期 月初时，显示上个月月底的日期 首先获取不同月的天数,并抽离成类方法方便后边调用 123456789101112131415// 获取某年某月总共多少天 + (int)getDaysInMonth:(int)year month:(int)imonth &#123; // imonth == 0的情况是应对在CourseViewController里month-1的情况 if((imonth == 0)||(imonth == 1)||(imonth == 3)||(imonth == 5)||(imonth == 7)||(imonth == 8)||(imonth == 10)||(imonth == 12)) return 31; if((imonth == 4)||(imonth == 6)||(imonth == 9)||(imonth == 11)) return 30; if((year%4 == 1)||(year%4 == 2)||(year%4 == 3)) return 28; if(year%400 == 0) return 29; if(year%100 == 0) return 28; return 29; &#125; 放置label的方法，在label上写下日期 123456789// 添加日期- (void)setDateLabel:(CGRect)rect number:(NSString *)number&#123; UILabel *label = [[UILabel alloc] initWithFrame:rect]; label.textColor = [UIColor colorWithRed:100.0/255 green: 73.0/255 blue:250.0/255 alpha:1]; label.textAlignment = NSTextAlignmentCenter; label.text = number; label.font = [UIFont systemFontOfSize:14]; [self.view addSubview:label];&#125; 开始判断。拿到周一是几号后面的日数递增就OK了，注意月末月初交替的特殊情况（看机智如我，走起) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 判断当前天是周几，从而计算出当周的周一是几号（负数表示上个月月末）if ([weekString isEqual: @"周一"]) &#123; day = day - 1; // 因为下面有 day++;&#125; else if ([weekString isEqual:@"周二"]) &#123; day = day - 2;&#125; else if ([weekString isEqual:@"周三"]) &#123; day = day - 3;&#125; else if ([weekString isEqual:@"周四"]) &#123; day = day - 4;&#125; else if ([weekString isEqual:@"周五"]) &#123; day = day - 5;&#125; else if ([weekString isEqual:@"周六"]) &#123; day = day - 6;&#125; else if ([weekString isEqual:@"周日"]) &#123; day = day - 7;&#125; if (day&lt;0) &#123; // 月初时显示上个月月末的日期 for (int i = 0; i &lt; 7; i++) &#123; // 上个月末往后的月初数字 int days = [GetDays getDaysInMonth:year month:month-1]; day++; if (day &gt; days) &#123; day = 0; day++; &#125; // 月初之前的月末数字 switch (day) &#123; case 0: day = days; break; case -1: day = days-1; break; case -2: day = days-2; break; case -3: day = days-3; break; case -4: day = days-4; break; case -5: day = days-5; break; default: break; &#125; [self setDateLabel:CGRectMake(i*((self.view.frame.size.width-33.5)/7+0.5)+30.5, kTopY, (self.view.frame.size.width-33.5)/7, 15) number:[NSString stringWithFormat:@"%d", day]]; &#125;&#125; else &#123; // 月末 for (int i = 0; i &lt; 7; i++) &#123; int days = [GetDays getDaysInMonth:year month:month]; day++; if (day &gt; days) &#123; day = 0; day++; &#125; [self setDateLabel:CGRectMake(i*((self.view.frame.size.width-33.5)/7+0.5)+30.5, kTopY, (self.view.frame.size.width-33.5)/7, 15) number:[NSString stringWithFormat:@"%d", day]]; &#125;&#125; 劳心劳力，大功告成。接下来小L要告诉大家，上边的判断看看就好了（哭吧）我们还有so so so easy的方法（嘿） 方法推荐：获取几年几月几日后的日期,并抽离成类方法方便后边调用 1234567891011121314151617181920/** * 获取几年几月几日后的日期，0表示当天，负数表示之前 * 这里只要取到日就好了，年月置0，表示当年当月 */+ (int)getOneDay:(int)day &#123; int year = 0, month = 0; NSCalendar *calendar = [[NSCalendar alloc] initWithCalendarIdentifier:NSCalendarIdentifierGregorian]; NSDateComponents *comps = nil; comps = [calendar components:NSCalendarUnitYear|NSCalendarUnitMonth|NSCalendarUnitDay fromDate:[NSDate date]]; NSDateComponents *adcomps = [[NSDateComponents alloc] init]; [adcomps setYear:year]; [adcomps setMonth:month]; [adcomps setDay:day]; NSDate *newdate = [calendar dateByAddingComponents:adcomps toDate:[NSDate date] options:0]; NSDateFormatter *formatter = [[NSDateFormatter alloc] init]; [formatter setDateFormat:@"dd"]; NSString * dayString = [formatter stringFromDate:newdate]; return [dayString intValue];&#125; 重点来了： 123456789101112131415161718192021// 判断当前天是周几，从而计算出当周的周一是几号（负数表示上个月月末）if ([weekString isEqual: @"周一"]) &#123; day = 0; // 因为下面有 day++;&#125; else if ([weekString isEqual:@"周二"]) &#123; day = -1;&#125; else if ([weekString isEqual:@"周三"]) &#123; day = -2;&#125; else if ([weekString isEqual:@"周四"]) &#123; day = -3;&#125; else if ([weekString isEqual:@"周五"]) &#123; day = -4;&#125; else if ([weekString isEqual:@"周六"]) &#123; day = -5;&#125; else if ([weekString isEqual:@"周日"]) &#123; day = -6;&#125;// 放置日期for (int i = 0; i &lt; 7; i++) &#123; [self setDateLabel:CGRectMake(i*((self.view.frame.size.width-33.5)/7+0.5)+30.5, kTopY, (self.view.frame.size.width-33.5)/7, 15) number:[NSString stringWithFormat:@"%d", [GetOneDay getOneDay:day++]]];&#125; 如此才是万事大吉！比上边的判断简单了许多，不过上边的判断也是一种思路，所以记录下来，给大家一个借鉴！ 后记小白出手，请多指教。如言有误，还望斧正！ 转载请保留原文地址：http://gonghonglou.com/2016/03/03/date-week 迁移文章 首发于2015-10-13]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[由丢失一部iPhone6引发的祸端]]></title>
    <url>%2F2016%2F03%2F03%2Fprotect-apple-id%2F</url>
    <content type="text"><![CDATA[前言：刚从售后拿到Mac 回学校的公交车上。记录下这悲惨的经历告诫各位果友篇幅略长，怕有些读者看不下去遂将告诫先写在前面： 为保护手机，在iPhone设置–iCloud里有查找我的iPhone功能，确保开启（默认开启）万一不幸手机丢失，尽快登录iCloud官网或在查找我的iPhone app里将iPhone设为丢失模式或锁定iPhone，为保护隐私可选抹掉iPhone（会删除iPhone里的所有数据，不可逆） Mac和iPad一样如此 手机在丢失模式下，锁屏界面会显示你设置的一个联系号码。若是好心人送还手机自然大喜。但也要提防钓鱼网站，伪造Apple身份给你发短信或邮件，骗取iCloud密码（lz已上当羞耻哭晕在厕所） 万一不幸iCloud密码泄漏，请及时修改Apple ID的验证问题和Apple ID的密码。切勿以为只改密码万事大吉，盗取你的密码就能获取你的验证问题的答案，有了验证问题答案就能查看你更改的密码（怕）并且可以远程操作（锁定、抹掉…）你的设备（lz已受害二次哭晕在厕所） 为防万一，建议在iCloud的管理我的Apple ID里开启两步验证，此后要操作远程命令就需要短信验证码再加上密码或验证问题。（开启两步验证会给你一份字母加数字的密钥，很重要，是你丢失密码或手机卡后的唯一凭证，切记保存好） 那么故事是这样的：事情发生在15年10月8号，却并非起始于这个日期。8号上午如往常一样打开Mac准备码字，联网之后弹出一个提示iCloud什么的对话框，点了确定Mac就重启了，重启之后竟出现这样的界面：这是什么鬼？刚开始四个方框上提示：输入锁定此系统的PIN码来解锁。what？PIN码？我没有啊，崩溃！百度一些提示说按住option键重新开机。然后出现了一个锁头（这就是固件锁）并没有什么卵用，遂拨打4006-272273（苹果技术支持热线）寻助AppleCare，一系列问答之后大概明白了应该是iCloud密码泄漏，Mac被远程恶意锁定。客服询问我的Apple ID是和别人共用还是怎样泄漏过，才回想起7月份失窃一部iPhone6（新机、心痛） 这就是故事的起点：失窃iPhone后随即登录iCloud将iPhone6设为丢失模式（这时可留下一个联系方式显示在手机解锁屏幕上）几天后收到一条短信（来自香港号码）以苹果的身份，大体意思说 您的iPhone在苹果售后申请换机，因凭证信息不符被Apple售后截下，若情况符实请登录 iCloud网站（一段网址）申请扣机，确认信息后Apple会联系警察交还手机。。。。。 一开始没注意是因为对于找回手机已经不抱希望了（尽管我还没有锁定iPhone，汗）后来看到可申请扣机（其实一开始是短信太长没看懂，笑）因为失窃后已报警，又看到希望的我内心是鸡冻的。然后就上网登录”iCoud.com”(和平常登录时的iCloud界面一个模样)熟练输入帐号密码，登录之后找半天并没有找回iPhone啊，遂电话Apple客服被惨痛告知：这是钓鱼网站骗取Apple ID密码的常见手法。赶紧到iCloud官网查看我的设备，已不见iPhone6的踪影（哭）这里要说客服态度很好，在我传达了收到的短信后，他们首先关注的是我是否已输入了登录密码。 如此看来便是那时候泄漏的iCloud密码了。之后一直没有改密码（汗）而可恶的盗窃者在盗取我的iCloud密码后竟默默蛰伏至今我在6号晚12点左右因为6s的某原因在手机上修改了iCloud密码，在Mac被锁后发现一份iCloud邮件提示我的Mac在7号下午八点多的时候被锁定。以此推断应该是我改密码的行为触动了盗窃者所以远程锁定了我的Mac，之前我以为改密码在Mac被锁之前账号应该是安全的，后来才知并非如此（如前言所述）前后打了四五次400，有一次为查看Apple ID的动态要转接Apple的最高级别安全部门，转接等待一个半小时没接通（汗）不过客服们的态度都特别热情，这点很欣慰！只是她们貌似对PIN码什么的也说不太清，大概认定为被人远程恶意锁定了。 解决方案：到售后解锁，赶到市里，售后态度也很好，只是他们也说不清楚PIN码什么的，今天取Mac时一位技术大哥总算给讲明白怎么回事，解释如下：1）在查找我的iPhone里锁定我的iPhone或iPad可通过密码解锁，若忘记密码可向苹果申请解锁（需要设备的购买凭证，必须要且有效）2）但是，锁定Mac时会输入一个密码，这个密码就是上面提到的PIN码 输入PIN码可以进入系统但是不能进行更改硬盘操作 若是忘记PIN码或者是被恶意锁定的，按组合键Command+Option+P+R可以清空PIN码然后进入系统但仍然不能进行更改硬盘操作。 开机时按住option键进入磁盘分区时就会出现固件锁，在这里输入PIN码也可以进入系统仍然不能进行更改硬盘操作。怎样才能解开固件锁，只有去售后了，他们向Apple提供固件锁的信息，Apple做一个解密包发回来解锁，济南售后花费300大洋，倒是不贵可是心痛（哭） 为保安全，你也可以为你的Mac加上固件锁，自行百度（甚用，忘了心情就不好了。。。） 最后不幸中的万幸是，盗窃者或许先点的锁定Mac这一不可逆的过程导致抹掉Mac不可用，又或者其他的网络连接什么的原因总之我的硬盘资料没有被抹。技术大哥说之前解掉的几个固件锁打开后数据都是被抹掉的，连系统都没了（庆幸）发现资料还在时心情是无法用语言表达的，就用微博上一帅哥的表情来表达吧 再次告诫广大果友： 在保护好自己apple设备的同时更要保护好自己的Apple ID密码，最好开启两步验证。 对于重要文件及时做好备份，Apple的锁做的很强大，极好的保护了我们的设备和数据，可是一旦泄露iCloud密码伤害也会很致命 对于备份，Mac上有Time Machine备份工具甚是好用，听起来（嘿）也是售后的技术大哥告知的，感谢AppleCare和Apple售后的好态度。 后记转载请保留原文地址：http://gonghonglou.com/2016/03/03/protect-apple-id 迁移文章 首发于2015-10-10]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Mac上搭建基于GitHub的Hexo博客]]></title>
    <url>%2F2016%2F02%2F03%2Ffirstblog%2F</url>
    <content type="text"><![CDATA[这是一篇详细文章来讲述用Mac搭建Hexo博客于Github上的完整历程， 也是踩了无数的坑搭起来的，现在写下些经验来分享，希望能帮大家少踩些坑。 曾买过一款阿里的云虚拟主机，后来才发现不能自己装软件只能上传网站程序，除非另买ECS，对于第一个月的实习工资还没拿到手的我想想还是算了，先用Wordpress搭起来玩玩吧。然而在上传网站程序中几次失败，本就觉得没劲，遂一怒转向Github。好了，废话少说，开始吧。 环境配置Hexo官网上本就有对Hexo安装及使用的详细介绍，墙裂推荐。这里来讲述自己安装的亲身步骤，或有区别。 1.Node.js用来生成静态页面。移步Node.js官网，下载v5.5.0 Stable 一路安装即可。 2.Git用来将本地Hexo内容提交到Github上。Xcode自带Git，这里不再赘述。如果没有Xcode可以参考Hexo官网上的安装方法。 安装Hexo当Node.js和Git都安装好后就可以正式安装Hexo了，终端执行如下命令：1$ sudo npm install -g hexo 输入管理员密码（Mac登录密码）即开始安装 (sudo:linux系统管理指令 -g:全局安装) 注意坑一：Hexo官网上的安装命令是$ npm install -g hexo-cli，安装时不要忘记前面加上sudo，否则会因为权限问题报错。 初始化终端cd到一个你选定的目录，执行hexo init命令： 1$ hexo init blog blog是你建立的文件夹名称。cd到blog文件夹下，执行如下命令，安装npm：1$ npm install 执行如下命令，开启hexo服务器：1$ hexo s 此时，浏览器中打开网址http://localhost:4000，能看到如下页面： 本地设置好后，接下来开始关联Github。 关联Github1.创建仓库登录你的Github帐号，新建仓库，名为用户名.github.io固定写法，如gonghonglou.github.io即下图中1所示： 本地的blog文件夹下内容为：1234567_config.yml db.json node_modules package.jsonscaffoldssourcethemes 终端cd到blog文件夹下，vim打开_config.yml，命令如下：1$ vim _config.yml 打开后往下滑到最后，修改成下边的样子：1234deploy: type: git repository: https://github.com/gonghonglou/gonghonglou.github.io.git branch: master 你需要将repository后gonghonglou换成你自己的用户名，地址在上图2位置获取。hexo 3.1.1版本后type:值为git。 注意坑二：在配置所有的_config.yml文件时（包括theme中的），在所有的冒号:后边都要加一个空格，否则执行hexo命令会报错，切记 切记 在blog文件夹目录下执行生成静态页面命令：1$ hexo generate 或者：hexo g 此时若出现如下报错： ERROR Local hexo not found in ~/blog ERROR Try runing: 'npm install hexo --save' 则执行命令： npm install hexo --save 若无报错，自行忽略此步骤。 再执行配置命令：1$ hexo deploy 或者：hexo d 注意坑三：若执行命令hexo deploy仍然报错：无法连接git或找不到git，则执行如下命令来安装hexo-deployer-git： $ npm install hexo-deployer-git --save 再次执行hexo generate和hexo deploy命令。 若你未关联Github，则执行hexo deploy命令时终端会提示你输入Github的用户名和密码，即12Username for 'https://github.com':Password for 'https://github.com': hexo deploy命令执行成功后，浏览器中打开网址http://gonghonglou.github.io（将gonghonglou换成你的用户名）能看到和打开http://localhost:4000时一样的页面。 为避免每次输入Github用户名和密码的麻烦，可参照第二节方法 2.添加ssh key到Github1.1.检查SSH keys是否存在Github执行如下命令，检查SSH keys是否存在。如果有文件id_rsa.pub或id_dsa.pub，则直接进入步骤1.3将SSH key添加到Github中，否则进入下一步生成SSH key。1$ ls -al ~/.ssh 1.2.生成新的ssh key执行如下命令生成public/private rsa key pair，注意将your_email@example.com换成你自己注册Github的邮箱地址。1$ ssh-keygen -t rsa -C "your_email@example.com" 默认会在相应路径下（~/.ssh/id_rsa.pub）生成id_rsa和id_rsa.pub两个文件。 1.3.将ssh key添加到Github中Find前往文件夹~/.ssh/id_rsa.pub打开id_rsa.pub文件，里面的信息即为SSH key，将这些信息复制到Github的Add SSH key页面即可。 进入Github –&gt; Settings –&gt; SSH keys –&gt; add SSH key: Title里任意添一个标题，将复制的内容粘贴到Key里，点击下方Add key绿色按钮即可。 3.发布文章终端cd到blog文件夹下，执行如下命令新建文章：1$ hexo new "postName" 名为postName.md的文件会建在目录/blog/source/_posts下，postName是文件名，为方便链接不建议掺杂汉字。你当然可以用vim来编辑文章。我在用Mou编辑器，支持预览，虽然其预览主题并非我喜欢，如果你有好用的markdown编辑器请推荐给我，感激不尽！ 文章编辑完成后，终端cd到blog文件夹下，执行如下命令来发布：123hexo generate //生成静态页面hexo deploy //将文章部署到Github 至此，Mac上搭建基于Github的Hexo博客就完成了。下面的内容是介绍安装theme和绑定个人域名，如果有兴趣且还有耐心的话，请继续吧。 安装theme你可以到Hexo官网主题页去搜寻自己喜欢的theme。这里以hexo-theme-next为例 终端cd到 blog 目录下执行如下命令：1$ git clone https://github.com/iissnan/hexo-theme-next themes/next 将blog目录下_config.yml里theme的名称landscape修改为next 终端cd到blog目录下执行如下命令(每次部署文章的步骤)：12345$ hexo clean //清除缓存文件 (db.json) 和已生成的静态文件 (public)$ hexo g //生成缓存和静态文件$ hexo d //重新部署到服务器 至于更改theme内容比如名称、描述、头像等去修改blog/_config.yml文件和blog/themes/next/_config.yml文件中对应的属性名称即可， 不要忘记冒号:后加空格。 NexT 使用文档里有极详细的介绍。 绑定个人域名现在使用的域名是Github提供的二级域名，也可以绑定为自己的个性域名。购买域名，可以到GoDaddy官网，网友亲切称呼为：狗爹，也可以到阿里万网购买。我是在万网买的，可直接在其网站做域名解析。 1.Github端在/blog/themes/next/source目录下新建文件名为：CNAME文件，注意没有后缀名！直接将自己的域名如：gonghonglou.com写入。 终端cd到blog目录下执行如下命令重新部署：12345$ hexo clean$ hexo g$ hexo d 注意坑四：网上许多都是说在Github上直接新建CNAME文件，如果这样的话，在你下一次执行hexo d部署命令后CNAME文件就消失了，因为本地没有此文件嘛。 2.域名解析如果将域名指向一个域名，实现与被指向域名相同的访问效果，需要增加CNAME记录。登录万网，在你购买的域名后边点击：解析 –&gt; 添加解析 记录类型：CNAME 主机记录：将域名解析为example.com（不带www），填写@或者不填写 记录值：gonghonglou.github.io. (不要忘记最后的.，gonghonglou改为你自己的用户名)，点击保存即可，如下图： 此时，点击访问http://gonghonglou.com和访问http://gonghonglou.github.io效果一致。 大功告成！ ——11.10更新 以下————————————————1、解决 deploy 后博客空白问题昨晚更新了一下 blog 做了个部署，结果blog就挂了，打开 gonghonglou.com 页面显示一片空白。然而 hexo s 开启本地服务器 localhost:4000 访问是没问题的。上网查了一下，原来是 GitHub Pages 禁止了 source/vendors 目录的访问。Github 在 11 月 3 日更新了版本。其中包括升级了 Jekyll 到 3.3。Jekyll 为了加快构建速度，忽略 vendor 和 node_modules 文件夹。所以部署到 GitHub 后，识别不到本地下的的这个文件夹 blog/themes/next/source/vendor，你只需要给这个文件夹换个名字再重新部署一次就 OK 了。nexT 在 GitHub 上的 isusses 已经给出了解决方案：#1214 还有另一种解决方案就是升级 nexT 主题，cd 到 blog/themes/next/ 下执行命令 git pull 更新。然而，有可能升级后多说评论等第三方工具会失效，慎用。 2、将个人博客同时部署到 GitHub 和 Coding1、首先到 Coding 上注册并开一个项目，项目名称和用户个性后缀相同（方便二级域名访问博客），拿到项目的 https 地址 2、打开本地 blog 目录下的 _config.yml 文件，修改如下123456deploy: type: git repository: github: https://github.com/gonghonglou/gonghonglou.github.io.git coding: https://git.coding.net/gonghonglou/gonghonglou.git branch: master 3、cd 到本地 blog/source 目录下执行如下命令新建 Staticfile 文件1$ touch Staticfile #名字必须是Staticfile 原因是 coding.net 需要以这个文件来作为静态文件部署的标志，就是说看到这个 Staticfile 就知道按照静态文件来发布。 4、执行发布命令 hexo g 、 hexo d 5、个人域名添加两条 CNAME 解析。将 gonghonglou.github.io. 解析为 [海外] ，将 gonghonglou.coding.me. 解析为 [默认] 这样就是为了从国内访问 gonghonglou.com 就是访问 Coding 上的博客项目，从国外访问 gonghonglou.com 就是访问 GitHub 上的博客项目。 6、到 Coding 上的博客项目主页，点击 Pages服务 输入部署分支 master 立即开启 这样就可以访问自己在 Coding 上的个人博客了 gonghonglou.coding.me/gonghonglou 如果像这样你的用户后缀名与博客项目名称相同你还可以省略项目名称直接访问 gonghonglou.coding.me 7、添加域名绑定，输入个人域名就 OK 了，可能需要耐心等待几分钟，这样在国内访问自己的博客就快得多了。 试了一下在国内访问 gonghonglou.com 拦不住 要飞起来了😂 ——11.10更新 以上————————————————后记以上便是我搭建与佳期的个人博客(gonghonglou.com)的全过程，希望对大家有所帮助，欢迎吐槽～ 转载请保留原文地址：http://gonghonglou.com/2016/02/03/firstblog Reference Hexo官网 HEXO 如何生成SSH key]]></content>
      <categories>
        <category>Technology</category>
      </categories>
  </entry>
</search>